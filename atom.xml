<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>橘生淮南</title>
  
  <subtitle>记录学习中的点点滴滴</subtitle>
  <link href="https://suenning.com.cn/atom.xml" rel="self"/>
  
  <link href="https://suenning.com.cn/"/>
  <updated>2023-02-01T00:10:12.000Z</updated>
  <id>https://suenning.com.cn/</id>
  
  <author>
    <name>sunning</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E4%BD%A0%E6%83%B3%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E5%9C%A8%E8%BF%99%E9%87%8C/"/>
    <id>https://suenning.com.cn/2023/02/01/%E4%BD%A0%E6%83%B3%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E5%9C%A8%E8%BF%99%E9%87%8C/</id>
    <published>2023-02-01T08:11:37.394Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>开篇声明，小萌新创作这篇文章的初衷只是想介绍一些关于黑客方面的基础知识，从读者的角度去满足一些计算机爱好者的好奇心，那我们就开始吧！</p><p><img src="https://img-blog.csdnimg.cn/20200222180723440.jpg" alt="在这里插入图片描述"><br>在此引用前辈的语句作为文章的开篇，成为黑客的第一步，开始阅读吧！</p><blockquote><p>安全问题的本质是信任的问题</p></blockquote><h5 id="Web安全简史"><a href="#Web安全简史" class="headerlink" title="Web安全简史"></a>Web安全简史</h5><ul><li>起初，研究计算机系统和网络的人，被称为Hacker，他们对计算机系统有着深入的理解，因此往往能够发现其中的问题。Hacker在中国按照音译，被称为黑客。在计算机安全领域，黑客是一群破坏规则、不喜欢被拘束的人，因此总想着能够找到系统的漏洞，以获得一些规则之外的权力。对于现代计算机系统来说，在用户态的最高权限是Root，也是黑客们最渴望能够获取的系统最高权限。漏洞利用代码能够帮助黑客们达成这一目标。在黑客的世界里，有的黑客，精通计算机技术，能自己挖掘漏洞，而有的黑客，则只对攻击本身感兴趣，对计算机原理和各种编程技术的了解比较粗浅，因此只懂得编译别人的代码，自己并没有动手能力，这种黑客被称为脚本小子。在现实世界里，真正造成破坏的，往往并非那些挖掘并研究漏洞的黑客们，而是这些脚本小子。</li></ul><p><strong>黑客简史</strong></p><ul><li>中国黑客的发展分为启蒙时代，黄金时代，黑暗时代：</li><li>首先是启蒙时代，这个时期大概处在 20 世纪 90 年代，此时中国的互联网也刚刚处于起步阶段，一些热爱新兴技术的青年受到国外黑客技术的影响，开始研究安全漏洞。启蒙时代的黑客们大多是由于个人爱好而走上这条道路，好奇心与求知欲是驱使他们前进的动力，没有任何利益的瓜葛。这个时期的中国黑客们通过互联网，看到了世界，因此与西方发达国家同期诞生的黑客精神是一脉相传的，他们崇尚分享、自由、免费的互联网精神，并热衷于分享自己的最新研究成果。</li><li>接下来是黄金时代，这个时期以中美黑客大战为标志。在这个历史背景下，黑客这个特殊的群体一下子几乎吸引了社会的所有眼球，而此时黑客圈子所宣扬的黑客文化以及黑客技术的独特魅力也吸引了无数的青少年走上这条道路。自此事件后，各种黑客组织如雨后春笋般冒出。此阶段的中国黑客，其普遍的特点是年轻，有活力，充满激情，但在技术上也许还不够成熟。此时期黑客圈子里贩卖漏洞、恶意软件的现象开始升温，同时因为黑客群体的良莠不齐，也开始出现以赢利为目的的攻击行为，黑色产业链逐渐成型。</li><li>最后是黑暗时代，这个阶段从几年前开始一直延续到今天，也许还将继续下去。在这个时期黑客组织也遵循着社会发展规律，优胜劣汰，大多数的黑客组织没有坚持下来。在上一个时期非常流行的黑客技术论坛越来越缺乏人气，最终走向没落。所有门户型的漏洞披露站点，也不再公布任何漏洞相关的技术细节。伴随着安全产业的发展，黑客的功利性越来越强。黑色产业链开始成熟，这个地下产业每年都会给互联网造成数十亿的损失。而在上一个时期技术还不成熟的黑客们，凡是坚持下来的，都已经成长为安全领域的高级人才，有的在安全公司贡献着自己的专业技能，有的则带着非常强的技术进入了黑色产业。此时期的黑客群体因为互相之间缺失信任已经不再具有开放和分享的精神，最为纯粹的黑客精神实质上已经死亡。</li></ul><p><strong>黑帽白帽</strong><img src="https://img-blog.csdnimg.cn/20200222184318189.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>正如一个硬币有两面一样，黑客也有好坏之分。在黑客的世界中，往往用帽子的颜色来比喻黑客的好坏。</li></ul><blockquote><ul><li>白帽子，则是指那些精通安全技术，但是工作在反黑客领域的专家们</li><li>黑帽子，则是指利用黑客技术造成破坏，甚至进行网络犯罪的群体</li></ul></blockquote><ul><li>同样是研究安全，白帽子和黑帽子在工作时的心态是完全不同的。对于黑帽子来说，只要能够找到系统的一个弱点，就可以达到入侵系统的目的；而对于白帽子来说，必须找到系统的所有弱点，不能有遗漏，才能保证系统不会出现问题。这种差异是由于工作环境与工作目标的不同所导致的。白帽子一般为企业或安全公司服务，工作的出发点就是要解决所有的安全问题，因此所看所想必然要求更加的全面、宏观；黑帽子的主要目的是要入侵系统，找到对他们有价值的数据，因此黑帽子只需要以点突破，找到对他们最有用的一点，以此渗透，因此思考问题的出发点必然是有选择性的、微观的。</li><li>从对待问题的角度来看，黑帽子为了完成一次入侵，需要利用各种不同漏洞的组合来达到目的，是在不断地组合问题；而白帽子在设计解决方案时，如果只看到各种问题组合后产生的效果，就会把事情变复杂，难以细致入微地解决根本问题，所以白帽子必然是在不断地分解问题，再对分解后的问题逐个予以解决。这种定位的不对称，也导致了白帽子的安全工作比较难做。破坏永远比建设容易，但凡事都不是绝对的。要如何扭转这种局面，一般来说，白帽子选择的方法，是克服某种攻击方法，而并非抵御单次的攻击。</li><li>在安全领域也普遍认为：“最大的漏洞就是人”。写得再好的程序，在有人参与的情况下，就可能会出现各种各样不可预知的情况，比如管理员的密码有可能泄露，程序员有可能关掉了安全的配置参数等等。安全问题往往发生在一些意想不到的地方。另一方面，防御技术在不断完善的同时，攻击技术也在不断地发展。这就像一场军备竞赛，看谁跑在前面。白帽子们刚把某一种漏洞全部堵上，黑帽子们转眼又会玩出新花样。谁能在技术上领先，谁就能占据主动。互联网技术日新月异，在新技术领域的发展中，也存在着同样的博弈过程。可现状是，如果新技术不在一开始就考虑安全设计的话，防御技术就必然会落后于攻击技术，导致历史不断地重复。</li></ul><h5 id="计算机漏洞"><a href="#计算机漏洞" class="headerlink" title="计算机漏洞"></a>计算机漏洞</h5><ul><li>计算机漏洞是系统的一组特性，恶意的主体（攻击者或者攻击程序）能够利用这组特性，通过手段和方式获取对资源的未授权访问，或者对系统造成损害。</li><li>漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统。</li><li>漏洞会影响到很大范围的软硬件设备，包括作系统本身及其支撑软件，网络客户和服务器软件，网络路由器和安全防火墙等。换言之，在这些不同的软硬件设备中都可能存在不同的安全漏洞问题。在不同种类的软、硬件设备，同种设备的不同版本之间，由不同设备构成的不同系统之间，以及同种系统在不同的设置条件下，都会存在各自不同的安全漏洞问题。</li></ul><blockquote><p>漏洞问题是与时间紧密相关的</p></blockquote><ul><li>一个系统从发布的那一天起，随着用户的深入使用，系统中存在的漏洞会被不断暴露出来，这些早先被发现的漏洞也会不断被系统供应商发布的补丁软件修补，或在以后发布的新版系统中得以纠正。而在新版系统纠正了旧版本中具有漏洞的同时，也会引入一些新的漏洞和错误。因而随着时间的推移，旧的漏洞会不断消失，新的漏洞会不断出现。漏洞问题也会长期存在。因而脱离具体的时间和具体的系统环境来讨论漏洞问题是毫无意义的。只能针对目标系统的作系统版本、其上运行的软件版本以及服务运行设置等实际环境来具体谈论其中可能存在的漏洞及其可行的解决办法。同时应该看到，对漏洞问题的研究必须要跟踪当前最新的计算机系统及其安全问题的最新发展动态。这一点如同对计算机病毒发展问题的研究相似。如果在工作中不能保持对新技术的跟踪，就没有谈论系统安全漏洞问题的发言权，既使是以前所作的工作也会逐渐失去价值。</li></ul><h5 id="漏洞问题与不同安全级别计算机系统之间的关系"><a href="#漏洞问题与不同安全级别计算机系统之间的关系" class="headerlink" title="漏洞问题与不同安全级别计算机系统之间的关系"></a>漏洞问题与不同安全级别计算机系统之间的关系</h5><ul><li><p>橘皮书正式名称是“受信任计算机系统评量基准”。橘皮书中对可信任系统的定义是这样的：一个由完整的硬件及软件所组成的系统，在不违反访问权限的情况下，它能同时服务于不限定个数的用户，并处理从一般机密到最高机密等不同范围的信息。</p></li><li><p>橘皮书将一个计算机系统可接受的信任程度加以分级，凡符合某些安全条件、基准规则的系统即可归类为某种安全等级。橘皮书将计算机系统的安全性能由高而低划分为A、B、C、D四大等级。其中：</p></li></ul><blockquote><p>**D级——最低保护（Minimal Protection)**，凡没有通过其他安全等级测试项目的系统即属于该级，如Dos，Windows个人计算机系统</p></blockquote><blockquote><p>**C级——自主访问控制（Discretionary Protection)**，该等级的安全特点在于系统的客体（如文件、目录）可由该系统主体（如系统管理员、用户、应用程序）自主定义访问权。例如：管理员可以决定系统中任意文件的权限</p></blockquote><blockquote><p>**B级——强制访问控制（Mandatory Protection)**，该等级的安全特点在于由系统强制对客体进行安全保护，在该级安全系统中，每个系统客体（如文件、目录等资源）及主体（如系统管理员、用户、应用程序）都有自己的安全标签Security Label，系统依据用户的安全等级赋予其对各个对象的访问权限</p></blockquote><blockquote><p>**A级——可验证访问控制（Verified Protection)**，而其特点在于该等级的系统拥有正式的分析及数学式方法可完全证明该系统的安全策略及安全规格的完整性与一致性</p></blockquote><ul><li><p>可见，根据定义，系统的安全级别越高，理论上该系统也越安全。可以说，系统安全级别是一种理论上的安全保证机制。是指在正常情况下，在某个系统根据理论得以正确实现时，系统应该可以达到的安全程度。系统安全漏洞是指可以用来对系统安全造成危害，系统本身具有的，或设置上存在的缺陷。总之，漏洞是系统在具体实现中的错误。比如在建立安全机制中规划考虑上的缺陷，作系统和其他软件编程中的错误，以及在使用该系统提供的安全机制时人为的配置错误等。</p></li><li><p>安全漏洞的出现，是因为人们在对安全机制理论的具体实现中发生了错误，是意外出现的非正常情况。而在一切由人类实现的系统中都会不同程度的存在实现和设置上的各种潜在错误。因而在所有系统中必定存在某些安全漏洞，无论这些漏洞是否已被发现，也无论该系统的理论安全级别如何。所以可以认为，在一定程度上，安全漏洞问题是独立于作系统本身的理论安全级别而存在的。并不是说，系统所属的安全级别越高，该系统中存在的安全漏洞就越少。可以这么理解，当系统中存在的某些漏洞被入侵者利用，使入侵者得以绕过系统中的一部分安全机制并获得对系统一定程度的访问权限后，在安全性较高的系统当中，入侵者如果希望进一步获得特权或对系统造成较大的破坏，必须要克服更大的障碍。</p></li></ul><h5 id="安全漏洞与系统攻击之间的关系"><a href="#安全漏洞与系统攻击之间的关系" class="headerlink" title="安全漏洞与系统攻击之间的关系"></a>安全漏洞与系统攻击之间的关系</h5><ul><li>系统安全漏洞是在系统具体实现和具体使用中产生的错误，但并不是系统中存在的错误都是安全漏洞。只有能威胁到系统安全的错误才是漏洞。许多错误在通常情况下并不会对系统安全造成危害，只有被人在某些条件下故意使用时才会影响系统安全。</li><li>漏洞虽然可能最初就存在于系统当中，但一个漏洞并不是自己出现的，必须要有人发现。在实际使用中，用户会发现系统中存在错误，而入侵者会有意利用其中的某些错误并使其成为威胁系统安全的工具，这时人们会认识到这个错误是一个系统安全漏洞。系统供应商会尽快发布针对这个漏洞的补丁程序，纠正这个错误。这就是系统安全漏洞从被发现到被纠正的一般过程。</li><li>系统攻击者往往是安全漏洞的发现者和使用者，要对于一个系统进行攻击，如果不能发现和使用系统中存在的安全漏洞是不可能成功的。对于安全级别较高的系统尤其如此。<br>系统安全漏洞与系统攻击活动之间有紧密的关系。因而不该脱离系统攻击活动来谈论安全漏洞问题。了解常见的系统攻击方法，对于有针对性的理解系统漏洞问题，以及找到相应的补救方法是十分必要的。</li></ul><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>IP是Internet Protocol（网际互连协议）的缩写，是TCP&#x2F;IP体系中的网络层协议。</p><ul><li>设计IP的目的是提高网络的可扩展性：</li><li>一是解决互联网问题，实现大规模、异构网络的互联互通。</li><li>二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据报传输服务。</li></ul><blockquote><p>IP地址，它是为标识Internet上主机位置而设置的。Internet上的每一台计算机都被赋予一个世界上唯一的32位Internet地址，这一地址可用于与该计算机有关的全部通信。为了方便起见，在应用上我们以8比特为一单位，组成四组十进制数字来表示每一台主机的位置。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IP地址分类：</span><br><span class="line">A：1.0.0.0-126.0.0.0</span><br><span class="line">B：128.1.0.0-191.255.0.0</span><br><span class="line">C：192.0.1.0-223.255.255.0</span><br><span class="line">D：224.0.0.0-239.255.255.255</span><br><span class="line">E：240.0.0.0-255.255.255.254 </span><br></pre></td></tr></table></figure><blockquote><ul><li>主机号全为0的地址表示网络地址</li><li>主机号全为1的地址表示广播地址</li></ul></blockquote><h5 id="内网（私有地址）"><a href="#内网（私有地址）" class="headerlink" title="内网（私有地址）"></a>内网（私有地址）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0-10.255.255.255</span><br><span class="line">172.16.0.0-172.31.255.255</span><br><span class="line">192.168.0.0-192.168.255.255 </span><br></pre></td></tr></table></figure><h5 id="端口（Port）"><a href="#端口（Port）" class="headerlink" title="端口（Port）"></a>端口（Port）</h5><blockquote><p>一种数据的传输通道</p></blockquote><p>用于接受某些数据，然后传输给相应的服务，而电脑将这些数据处理后，再将相应的恢复通过开启的端口传给对方。一般每一个端口的开放对应了相应的服务，要关闭这些端口只需要将对应的服务关闭就可以了。 </p><ul><li>在网络技术中，端口大致有两种意思：</li><li>一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用于连接其他网络设备的接口，如RJ-45端口、SC端口等等。</li><li>二是逻辑意义上的端口，一般是指TCP&#x2F;IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</li></ul><blockquote><p>我们这里将要介绍的就是逻辑意义上的端口。我们这里所说的端口，不是计算机硬件的I&#x2F;O端口，而是软件形式上的概念.工具提供服务类型的不同，端口分为两种，一种是TCP端口，一种是UDP端口。计算机之间相互通信的时候，分为两种方式：一种是发送信息以后，可以确认信息是否到达，也就是有应答的方式，这种方式大多采用TCP协议；一种是发送以后就不管了，不去确认信息是否到达，这种方式大多采用UDP协议。对应这两种协议的服务提供的端口，也就分为TCP端口和UDP端口。</p></blockquote><ul><li>按端口号可分为4大类：</li><li>公认端口（Well-Known Ports）：范围从0到1023<br>它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：21端口分配给FTP服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务，135端口分配给RPC（远程过程调用）服务等等。<br>我们在IE的地址栏里输入一个网址的时候（ 比如<a href="http://www.cce.com.cn)是不必指定端口号的,因为在默认情况下www服务的端口/">www.cce.com.cn）是不必指定端口号的，因为在默认情况下WWW服务的端口</a> 号是“80”。<br>网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在 地址栏上指定端口号，方法是在地址后面加上冒号“:”（半角），再加上端口 号。比如使用“8080”作为WWW服务的端口，则需要在地址栏里输入“<a href="http://www.cce.com.cn:8080”。">www.cce.com.cn:8080”。</a><br>但是有些系统协议使用固定的端口号，它是不能被改变的，比如139 端口专门用于NetBIOS与TCP&#x2F;IP之间的通信，不能手动改变。 </li><li>动态端口（Dynamic Ports）：范围从1024到65535<br>之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。动态分配是指当一个系统进程或应用 程序进程需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配 一个供它使用。当这个进程关闭时，同时也就释放了所占用的端口号。</li><li>注册端口（Registered Ports）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用         于许多其它目的。例如：许多系统处理动态端口从1024左右开始。</li><li>私有端口（Private Ports）：从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024    起分配动态端口。但也有例外：SUN的RPC端口从32768开始。</li></ul><h5 id="域名地址"><a href="#域名地址" class="headerlink" title="域名地址"></a>域名地址</h5><ul><li>尽管IP地址能够唯一地标识网络上的计算机，但IP地址是数字型的，用户记忆这类数字十分不方便，于是人们又发明了另一套字符型的地址方案，即所谓的域名地址。</li></ul><blockquote><p>IP地址和域名是一一对应的，域名由两种基本类型组成：以机构性质命名的域和以国家地区代码命名的域</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201128164334665.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201128182355615.png" alt="在这里插入图片描述"><br><strong>域名解析方式</strong></p><ol><li>递归查询法<ol><li>如果DNS服务器无法解析出DNS客户机所要求查询的域名所对应的IP地址时，DNS服务器代表DNS客户机来查询或联系其他DNS服务器，以完全解析该名称，并将应答返回给客户机。</li><li>本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机。</li></ol></li><li>迭代查询法<ol><li>客户机送出查询请求后，若该DNS服务器中不包含所需数据，它会告诉客户机另外一台DNS服务器的IP地址，使客户机自动转向另一台DNS服务器查询，以此类推，直到查询数据，否则由最后一台DNS服务器通知客户机查询失败。</li><li>本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</li></ol></li><li>反向查询<br> 客户机利用IP地址查询其主机完整域名。</li></ol><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><p>统一资源定位器，又叫URL(Uniform Resource Locator)，是专为标识Internet网上资源位置而设的一种编址方式。</p><ul><li>我们平时所说的网页地址指的即是URL，URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。</li></ul><blockquote><p>如URL为：<code>http://china-window.com/shanghai/news/wnw.html</code></p><ul><li>http指超文本传输协议</li><li>china-window.com是其Web服务器域名地址</li><li>shanghai&#x2F;news是网页所在路径，wnw.html是相应的网页文件</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标识Internet网上资源位置的三种方式：　</span><br><span class="line">IP地址：<span class="number">202.206</span><span class="number">.64</span><span class="number">.33</span>　</span><br><span class="line">域名地址：dns.hebust.edu.cn</span><br><span class="line">URL：http:<span class="comment">//china-window.com/shanghai/news/wnw.html</span></span><br></pre></td></tr></table></figure><h5 id="HTTP-请求-x2F-响应的步骤"><a href="#HTTP-请求-x2F-响应的步骤" class="headerlink" title="HTTP 请求&#x2F;响应的步骤"></a>HTTP 请求&#x2F;响应的步骤</h5><ol><li>客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./">http://www.oakcms.cn。</a></li><li>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li><li>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li><li>释放连接TCP连接<br>若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。</li><li>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li></ol><ul><li>如果我们在客户端（客户端）浏览器输入 <code>http://www.baidu.com</code>，而<code>baidu.com</code>为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</li></ul><ol><li>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></li><li>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口，如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>客户端的网络层不用关系应用层或者传输层，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li><li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包。现在就可以传输了，然后发送IP数据包到达服务器的地址。</li></ol><h5 id="肉鸡"><a href="#肉鸡" class="headerlink" title="肉鸡"></a>肉鸡</h5><p>肉鸡，即拥有管理权限的远程电脑，也是指受黑客远程控制的电脑。<br><img src="https://img-blog.csdnimg.cn/2020022220302550.jpeg" alt="在这里插入图片描述"></p><h5 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h5><blockquote><p>web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是web的一个管理工具，可以对web服务器进行操作的权限</p></blockquote><ul><li>webshell是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。</li><li>黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。</li></ul><h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><p>&amp;emsp;&amp;emsp;提高自己在服务器中的权限</p><h5 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h5><ul><li>用某种暴力破解软件，对某种需要密码才能使用的服务，把可能的密码尽量多得聚集在一起，列成一个表格然后一个接一个的试，直到试验出正确的密码，也就是破解成功了。不过这种破解方式成功几率不高，耗费时间多，技术成分低，不是迫不得已是不使用的。</li></ul><h5 id="ASP脚本入门与防御思想"><a href="#ASP脚本入门与防御思想" class="headerlink" title="ASP脚本入门与防御思想"></a>ASP脚本入门与防御思想</h5><ol><li>ASP<br>ASP是Active Server Page的缩写，意为“动态服务器页面”，它可以与数据库和其他程序交互。</li></ol><ul><li>与HTML相比，ASP网页具有以下特点：</li><li>（1）利用ASP可以实现突破静态网页的一些功能限制，实现动态网页技术。</li><li>（2）ASP文件是包含在HTML代码所组成的文件中的，易于修改和测试。</li><li>（3）服务器上的ASP解释程序会在服务器端制定ASP程序，并将结果以HTML格式传送到客户端浏览器上，因此使用各种浏览器都可以正常浏览ASP所产生的网页。</li><li>（4）ASP提供了一些内置对象，使用这些对象可以使服务器端脚本功能更强。例如可以从web浏览器中获取用户通过HTML表单提交的信息，并在脚本中对这些信息进行处理，然后向web浏览器发送信息。</li></ul><ol start="2"><li>ASP的工作原理<br>1、用户向浏览器地址栏输入网址，默认页面的扩展名是.asp<br>2、浏览器向服务器发出请求<br>3、服务器引擎开始运行ASP程序<br>4、ASP文件按照从上到下的顺序开始处理，执行脚本命令，执行HTML页面内容<br>5、页面信息发送到浏览器</li></ol><ul><li>ASP能做什么<ul><li>动态地编辑、改变或者添加网页的任何内容</li><li>对由用户从 HTML 表单提交的查询或者数据作出响应</li><li>访问数据或者数据库，并向浏览器返回结果</li><li>为不同的用户定制网页，提高这些页面的可用性</li><li>提供安全性保障——ASP代码不能从浏览器查看</li><li>优秀的 ASP 编程可最小化网络流量</li></ul></li></ul><ol start="4"><li>ASP脚本防御思想<ul><li>一直以来， ASP给人的印象都是不太安全，实则不然。脚本语言和数据库本身并没有过错。ASP脚本的安全隐患在于管理员的不重视和对 ASP脚本的不了解，实际上只要使用得当， ASP脚本其实可以很安全。</li><li>首先要谈到的就是注入，关于要如何过滤ASP脚本注入，已经不是第一次提到了，但想要过滤非法字符这也不是意见简单的事。防止了Get，Post提交方式注入，还要记得过滤Cookie注入；防止了数字型、字符型注入，还要记得防止搜索型注入；防止了常规的非法字符，还要防范编码和大小写转换等情况。还有表名、字段名的选取问题，很多情况下注入者大都不知道什么是表名和字段名的。可是很多程序员们都喜欢用admin、manage、user、pass、password、username等容易被猜到的表名和字段名，导致ASP脚本变得极度不安全。</li><li>其实，只要在所有表名上加个简单的前缀，就可以有效的防止被人猜到。也不影响正常的使用。还要防止暴库，对密码进行MD5加密、修改默认数据库路径、常给网站程序打补丁、不用sa权限连接数据库、删除SQL server的存储扩展以及禁止非法IP连接1433端口。一般来讲，防守比入侵容易，入侵一个网站的传统方法需要同时满足很多条件，管理只要破坏其中一个条件就能够保住网站，所以防御仅仅是对安全性的重视和耐心。</li></ul></li></ol><h5 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h5><ul><li><p>弱口令没有严格和准确的定义，通常认为容易被别人猜测到或被破解工具破解的口令均为弱口令。弱口令指的是仅包含简单数字和字母的口令，例如“123”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的计算机面临风险，因此不推荐用户使用。</p></li><li><p>弱口令避免措施：</p></li></ul><ol><li>不使用空口令或系统缺省的口令，因为这些口令众所周知，为典型的弱口令</li><li>口令长度不小于8个字符</li><li>口令不应该为连续的某个字符或重复某些字符的组合</li><li>口令应该为以下四类字符的组合，大写字母(A-Z)、小写字母(a-z)、数字(0-9)和特殊字符。每类字符至少包含一个。如果某类字符只包含一个，那么该字符不应为首字符或尾字符</li><li>口令中不应包含本人、父母、子女和配偶的姓名和出生日期、纪念日期、登录名、E-mail地址等等与本人有关的信息，以及字典中的单词</li><li>口令不应该为用数字或符号代替某些字母的单词</li><li>口令应该易记且可以快速输入，防止他人从你身后很容易看到你的输入</li><li>至少90天内更换一次口令，防止未被发现的入侵者继续使用该口令</li></ol><h5 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h5><ul><li><p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p></li><li><p>SQL是操作数据库数据的结构化查询语言，网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。如Web应用程序的开发人员对用户所输入的数据或cookie等内容不进行过滤或验证就直接传输给数据库，就可能导致拼接的SQL被执行，获取对数据库的信息以及提权，发生SQL注入攻击。</p></li></ul><blockquote><p>注入原理：<br>&amp;emsp;&amp;emsp;SQL注入攻击是通过操作输入来修改SQL语句，用以达到执行代码对web服务器进行攻击的方法。简单的说就是在表单、输入域名或页面请求的查询字符串中插入SQL命令，最终使web服务器执行恶意命令的过程。可以通过一个例子简单说明SQL注入攻击。假设某网站页面显示时URL为<code>http://www.example.com?test=123</code>，此时URL实际向服务器传递了值为123的变量test，这表明当前页面是对数据库进行动态查询的结果。由此，我们可以在URL中插入恶意的SQL语句并进行执行。另外，在网站开发过程中，开发人员使用动态字符串构造SQL语句，用来创建所需的应用，这种情况下SQL语句在程序的执行过程中被动态的构造使用，可以根据不同的条件产生不同的SQL语句，比如需要根据不同的要求来查询数据库中的字段。这样的开发过程其实为SQL注入攻击留下了很多的可乘之机。</p></blockquote><p>注入过程：</p><ol><li>SQL注入点探测<br>探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要带有输入提交的动态网页，并且动态网页访问数据库，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。一般通过页面的报错信息来确定是否存在SQL注入漏洞。</li><li>收集后台数据库信息<br>不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断。</li><li>猜解用户名和密码<br>数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。</li><li>查找web后台管理入口<br>web后台管理通常不对普通用户开放，要找到后台管理的登录网址，可以利用web目录扫描工具快速搜索到可能的登录地址，然后逐一尝试，便可以找到后台管理平台的登录网址。</li><li>入侵和破坏<br>一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传木马、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。</li></ol><h5 id="脚本攻击"><a href="#脚本攻击" class="headerlink" title="脚本攻击"></a>脚本攻击</h5><ul><li>脚本是使用一种特定的描述性语言，依据一定的格式编写的可执行文件，又称宏或批处理软件，脚本通常可以由应用程序临时调用并执行。各类脚本目前被广泛地应用于网页设计中。脚本不仅可以较小网页的规模和提高网页浏览速度，而且可以丰富网页的表现，如动画、声音等。</li></ul><h5 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h5><ul><li><p>蜜罐技术本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。</p></li><li><p>蜜罐好像是故意让人攻击的目标，引诱黑客前来攻击。所以攻击者入侵后，你就可以知道他是如何得逞的，随时了解针对服务器发动的最新的攻击和漏洞。还可以通过窃听黑客之间的联系，收集黑客所用的种种工具，并且掌握他们的社交网络。蜜罐是一个包含漏洞的系统，它模拟一个或多个易受攻击的主机，给黑客提供一 个容易攻击的目标。由于蜜罐没有其它任务需要完成，因此所有连接的尝试都应被视为是可疑的。蜜罐的另一个用途是拖延攻击者对其真正目标的攻击，让攻击者在蜜罐上浪费时间。与此同时，最初的攻击目标受到了保护，真正有价值的内容将不受侵犯。</p></li></ul><p>蜜罐使用方法：</p><ul><li><p>迷惑入侵者，保护服务器<br>一般的客户&#x2F;服务器模式里，浏览者是直接与网站服务器连接的，换句话说，整个网站服务器都暴露在入侵者面前，如果服务器安全措施不够，那么整个网站数据都有可能被入侵者轻易毁灭。但是如果在客户&#x2F;服务器模式里嵌入蜜罐，让蜜罐作为服务器角色，真正的网站服务器作为一个内部网络在蜜罐上做网络端口映射，这样可以把网站的安全系数提高，入侵者即使渗透了位于外部的“服务器”，他也得不到任何有价值的资料，因为他入侵的是蜜罐而已。虽然入侵者可以在蜜罐的基础上跳进内部网络，但那要比直接攻下一台外部服务器复杂得多，许多水平不足的入侵者只能望而却步。蜜罐也许会被破坏，可是不要忘记了，蜜罐本来就是被破坏的角色。</p></li><li><p>抵御入侵者，加固服务器<br>入侵与防范一直都是热点问题，而在其间插入一个蜜罐环节将会使防范变得有趣，这台蜜罐被设置得与内部网络服务器一样，当一个入侵者费尽力气入侵了这台蜜罐的时候，管理员已经收集到足够的攻击数据来加固真实的服务器。<br>采用这个策略去布置蜜罐，需要管理员配合监视，否则入侵者攻破了第一台，就有第二台接着承受攻击了……</p></li><li><p>诱捕网络罪犯<br>这是一个相当有趣的应用，当管理员发现一个普通的客户&#x2F;服务器模式网站服务器已经牺牲成肉鸡的时候，如果技术能力允许，管理员会迅速修复服务器。那么下次呢？既然入侵者已经确信自己把该服务器做成了肉鸡，他下次必然还会来查看战果，一些企业的管理员不会罢休，他们会设置一个蜜罐模拟出已经被入侵的状态，做起了姜太公。同样，一些企业为了查找恶意入侵者，也会故意设置一些有不明显漏洞的蜜罐，让入侵者在不起疑心的情况下乖乖被记录下一切行动证据，通过与电信局的配合，可以轻易揪出IP源头的那双黑手。</p></li></ul><h5 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h5><ul><li>后门是指一种绕过安全性控制而获取对程序或系统访问权的方法。在软件的开发阶段，程序员常会在软件内创建后门以便可以修改程序中的缺陷。如果后门被其他人知道，或是在发布软件之前没有删除，那么它就成了安全隐患。</li></ul><h5 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h5><p>计算机病毒（Computer Virus）是编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。</p><ul><li>依附的媒体类型分类：<br>（1）网络病毒：通过计算机网络感染可执行文件的计算机病毒。<br>（2）文件病毒：主攻计算机内文件的病毒。<br>（3）引导型病毒：是一种主攻感染驱动扇区和硬盘系统引导扇区的病毒。  </li><li>计算机特定算法分类：<br>（1）附带型病毒：通常附带于一个EXE文件上，其名称与EXE文件名相同，但扩展是不同的，一般不会破坏更改文件本身，但在DOS读取时首先激活的就是这类病毒。<br>（2）蠕虫病毒：它不会损害计算机文件和数据，它的破坏性主要取决于计算机网络的部署，可以使用计算机网络从一个计算机存储切换到另一个计算机存储来计算网络地址来感染病毒。<br>（3）可变病毒：可以自行应用复杂的算法，很难发现，因为在另一个地方表现的内容和长度是不同的。</li></ul><blockquote><p>计算机病毒有自己的传输模式和不同的传输路径。计算机本身的主要功能是它自己的复制和传播，这意味着计算机病毒的传播非常容易，通常可以交换数据的环境就可以进行病毒传播。有三种主要类型的计算机病毒传输方式：<br>（1）通过移动存储设备进行病毒传播：如U盘、CD、软盘、移动硬盘等都可以是传播病毒的路径，而且因为它们经常被移动和使用，所以它们更容易得到计算机病毒的青睐，成为计算机病毒的携带者。<br>（2）通过网络来传播：这里描述的网络方法也不同，网页、电子邮件、QQ、BBS等都可以是计算机病毒网络传播的途径，特别是近年来，随着网络技术的发展和互联网的运行频率，计算机病毒的速度越来越快，范围也在逐步扩大。<br>（3）利用计算机系统和应用软件的弱点传播：近年来，越来越多的计算机病毒利用应用系统和软件应用的不足传播出去因此这种途径也被划分在计算机病毒基本传播方式中。</p></blockquote><ul><li>隐蔽性<br>计算机病毒不易被发现，这是由于计算机病毒具有较强的隐蔽性，其往往以隐含文件或程序代码的方式存在，在普通的病毒查杀中，难以实现及时有效的查杀。病毒伪装成正常程序，计算机病毒扫描难以发现。并且，一些病毒被设计成病毒修复程序，诱导用户使用，进而实现病毒植入，入侵计算机。因此，计算机病毒的隐蔽性，使得计算机安全防范处于被动状态，造成严重的安全隐患。</li><li>破坏性<br>病毒入侵计算机，往往具有极大的破坏性，能够破坏数据信息，甚至造成大面积的计算机瘫痪，对计算机用户造成较大损失。如常见的木马、蠕虫等计算机病毒，可以大范围入侵计算机，为计算机带来安全隐患。</li><li>传染性<br>计算机病毒的一大特征是传染性，能够通过U盘、网络等途径入侵计算机。在入侵之后，往往可以实现病毒扩散，感染未感染计算机，进而造成大面积瘫痪等事故。随着网络信息技术的不断发展，在短时间之内，病毒能够实现较大范围的恶意入侵。因此，在计算机病毒的安全防御中，如何面对快速的病毒传染，成为有效防御病毒的重要基础，也是构建防御体系的关键。 </li><li>寄生性<br>计算机病毒还具有寄生性特点。计算机病毒需要在宿主中寄生才能生存，才能更好地发挥其功能，破坏宿主的正常机能。通常情况下，计算机病毒都是在其它正常程序或数据中寄生，在此基础上利用一定媒介实现传播，在宿主计算机实际运行过程中，一旦达到某种设置条件，计算机病毒就会被激活，随着程序的启动，计算机病毒会对宿主计算机文件进行不断辅助、修改，使其破坏作用得以发挥。 </li><li>可执行性<br>计算机病毒与其他合法程序一样，是一段可执行程序，但它不是一个完整的程序，而是寄生在其他可执行程序上，因此它享有一切程序所能得到的权力。 </li><li>可触发性<br>病毒因某个事件或数值的出现，诱使病毒实施感染或进行攻击的特征。</li><li>攻击的主动性<br>病毒对系统的攻击是主动的，计算机系统无论采取多么严密的保护措施都不可能彻底地排除病毒对系统的攻击，而保护措施充其量是一种预防的手段而已。 </li><li>病毒的针对性<br>计算机病毒是针对特定的计算机和特定的操作系统的。</li></ul><h5 id="DDOS分布式拒绝服务攻击"><a href="#DDOS分布式拒绝服务攻击" class="headerlink" title="DDOS分布式拒绝服务攻击"></a>DDOS分布式拒绝服务攻击</h5><ul><li><p>可以这么理解，凡是能导致合法用户不能够访问正常网络服务的行为都算是拒绝服务攻击。拒绝服务攻击的目的非常明确，就是要阻止合法用户对正常网络资源的访问，从而达成攻击者不可告人的目的。</p></li><li><p>分布式拒绝服务攻击是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。</p></li></ul><p>攻击原理：</p><ul><li>DDoS是一种基于DoS特殊形式的拒绝服务攻击，是一种分布的、协同的大规模攻击方式。单一的DoS攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。与DoS攻击由单台主机发起攻击相比较，分布式拒绝服务攻击DDoS是借助数百、甚至数千台被入侵后安装了攻击进程的主机同时发起的集团行为。</li></ul><h5 id="ARP内网渗透"><a href="#ARP内网渗透" class="headerlink" title="ARP内网渗透"></a>ARP内网渗透</h5><ul><li><p>协议欺骗是指通过对通信双方使用协议弱点的利用，冒充其中一方与另一方进行通信的行为。对于广播式网络，只要更改自己网卡的接收模式为混杂模式，理论上就可以截获所有内网上的通信。对于交换式网络环境，如果要截获网络上不属于自己的通信，可以通过协议欺骗来实现。</p></li><li><p>内网渗透指的是在网络内部的渗透，在本地局域网内部对网内的其他系统进行渗透的过程。基于ARP欺骗的内网渗透指网络攻击者利用ARP欺骗截获不属于自身的通信，并从这一条件中获取更多利益的行为。</p></li></ul><blockquote><p>ARP地址解析协议是一个位于TCP&#x2F;IP协议栈中的低层协议，负责将局域网中某个IP地址解析成对应的MAC地址。IP地址到MAC地址的映射关系主要是靠ARP协议来实现的。对于网络主机，这个映射关系存放在ARP高速缓存中。</p></blockquote><p>ARP协议工作原理：</p><ol><li>网络通信源机器向网络广播ARP请求包，请求网络通信目的机器IP所对应的MAC地址</li><li>然后使用该IP的机器会向请求方发送一个含有其MAC地址的ARP回应包，这样请求方就知道向哪个MAC地址（目的主机）发送数据</li></ol><blockquote><p>ARP协议存在以下安全问题：无连接、无认证、动态性、广播</p></blockquote><p>ARP协议欺骗的步骤和方法：</p><ul><li>主机在不知道目的IP对应的MAC地址时，进行ARP广播请求，入侵者可以在接收到该ARP请求后以自己的MAC地址应答，进行假冒。</li><li>由于被假冒机器所发送的ARP应答有可能比入侵者发送的应答晚到达请求主机，为了确保请求主机的缓存中绝大部分时间存放的是入侵者的MAC地址，可以在收到ARP请求后稍微延迟一段时间再发送一遍ARP应答。</li><li>有些系统会向自己缓存中的地址发送非广播的ARP请求来更新自己的缓存。在交换网络环境下，如果请求主机缓存中已存有正确的主机MAC地址，入侵者就不能用以上接收请求然后应答的方法来更换被攻击主机缓存内容。由ARP弱点分析可知，应答可以随意发送，不一定要在请求之后。</li></ul><p>无漏洞渗透技术是相对于利用软件漏洞进行网络渗透的技术来说的。在以太网中，只要被渗透机器在网络中传输的数据包经过本地网卡，在本地就可以截获其数据包中的敏感信息，并可以更改数据包内容、替换数据包中的传输实体，使得被渗透机器上的敏感信息泄露，并可以使其在接收到被更改过的数据包之后，产生更多的损失。对内网中的机器进行渗透，不一定需要软件漏洞的存在。将这种不需要软件漏洞进行渗透的技术称为无漏洞渗透技术。</p><blockquote><p>对数据包处理的方式主要有两种，敏感信息的截取和传输实体的获取与替换</p></blockquote><ul><li>报文中敏感信息的获取<br>对于明文传输的面向连接和非面向连接的协议，在截获报文之后，对报文中传输的信息进行还原，并提取其中的敏感信息。</li><li>传输实体的获取与替换<br>明文传输的面向链接的协议中有很多协议支持文件实体的传输，如HTTP协议、FTP协议、SMTP协议。</li></ul><p>在交换式网络中防范ARP欺骗主要有以下几种方法：</p><ol><li><p>使用静态ARP表<br>在关键设备如网关、防火墙和边界路由器等设置静态的ARP，不要让系统刷新设定好的ARP转换表。在网关中使用静态ARP表，则可以避免通过网关进行ARP欺骗。</p></li><li><p>使用ARP服务器<br>在内部网络中设置ARP服务器，通过该服务器查找自己的ARP转换表来响应其他机器的ARP广播，而禁止其他系统响应ARP请求。</p></li><li><p>定期轮询<br>管理员定期轮询网络内部的IP地址与MAC地址的对应关系，通过与已有记录的比较来发现ARP欺骗。</p></li><li><p>主动出击<br>主动出击，用一些安全工具在网络中进行检测，可以检测到本地网络上的ARP欺骗报文。</p></li><li><p>使用加密通信<br>无漏洞渗透的报文中敏感信息的获取和传输实体的替换主要针对非加密通信，将内网的通信进行加密可以有效地防止这类攻击。</p></li><li><p>划分虚拟局域网<br>欺骗攻击无法跨网段工作，将网络进行越细致地分段，无漏洞渗透成功的可能性就越小。将受信任主机设置在同一社区VLAN中，将绝密性主机设置在隔离VLAN中，可以有效地防止无漏洞渗透的渗入。</p></li><li><p>提高防范意识<br>目前，很多容易被攻击者注意的网站，都采用了HTTPS代替了HTTP协议来传输网页和交易数据，已经避免了这类攻击发生的可能。但对于那些没有采用加密通信的web站点来说，web链接替换攻击依然有成功的可能。对这种攻击可以从浏览器终端用户的角度来防范，使用一些较为安全的浏览器来访问网站。<br><img src="https://img-blog.csdnimg.cn/20200222202816583.jpg" alt="在这里插入图片描述"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开篇声明，小萌新创作这篇文章的初衷只是想介绍一些关于黑客方面的基础知识，从读者的角度去满足一些计算机爱好者的好奇心，那我们就开始吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200222180723440.jpg&quot; al</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E6%8A%BD%E6%97%B6%E9%97%B4%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <id>https://suenning.com.cn/2023/02/01/%E6%8A%BD%E6%97%B6%E9%97%B4%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</id>
    <published>2023-02-01T08:11:37.394Z</published>
    <updated>2023-02-01T00:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201129164412796.jpg" alt="在这里插入图片描述"></p><h4 id="1-操作系统的概念及功能"><a href="#1-操作系统的概念及功能" class="headerlink" title="1. 操作系统的概念及功能"></a>1. 操作系统的概念及功能</h4><p>操作系统（OS）是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。<br><img src="https://img-blog.csdnimg.cn/20201129165239495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>操作系统的功能：</strong></p><ol><li>操作系统是系统资源的管理者</li><li>向上层提供方便易用的服务</li><li>是最接近硬件的一层软件</li></ol><p>我们通过使用QQ软件的例子来体会操作系统的功能：<br><img src="https://img-blog.csdnimg.cn/20201129165440188.png" alt="在这里插入图片描述"><br>1.操作系统作为管理者需要做的事情<br><img src="https://img-blog.csdnimg.cn/20201129165553989.png" alt="在这里插入图片描述"><br>2.理解向上层提供方便易用的服务<br>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p><p>那么具体提供方便易用的服务有哪些呢？<br>（1）GUI：图形化用户接口<br>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令，参数。<br>（2）命令接口<br><img src="https://img-blog.csdnimg.cn/20201129165717646.png" alt="在这里插入图片描述"><br>3.操作系统作为最接近硬件的层次<br><img src="https://img-blog.csdnimg.cn/202011291658229.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201129165915944.png" alt="在这里插入图片描述"></p><h4 id="2-操作系统的四个特征"><a href="#2-操作系统的四个特征" class="headerlink" title="2. 操作系统的四个特征"></a>2. 操作系统的四个特征</h4><p>操作系统有 <strong>并发，共享，虚拟，异步</strong> 这四个基本特征，其中并发和共享是两个最基本的特征，二者互为存在条件。</p><p>（1）并发：指两个或多个事件在同一时间间隔内发生。在这些事件宏观上是同时发生的。<br>注意：这里通常与并行混淆，并行是指两个或多个事件在同一时刻同时发生。</p><p>为了方便理解，我们来个例子！老渣和小渣<br><img src="https://img-blog.csdnimg.cn/20201129170302735.png" alt="在这里插入图片描述"></p><ol><li>操作系统的并发性：指计算机系统中同时运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着多道程序技术而出现的。因此，操作系统和程序并发是一起诞生的。</li><li>单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行。多核CPU同一时刻可以同时执行多个程序，多个程序可以并行的执行。</li></ol><p>（2）共享：即资源共享，是指系统中地资源可供内存中多个并发执行地进程共同使用。</p><ul><li><p>两种资源共享方式：互斥共享方式与同时共享方式</p></li><li><p>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p></li><li><p>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程同时对它们进行访问。所谓的同时往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）。</p></li></ul><blockquote><p>举个例子：<br>互斥共享方式：比如在使用QQ和微信视频，同一时间段内摄像头只能分配给其中一个进程。<br>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p></blockquote><ul><li>并发和共享的关系<br><img src="https://img-blog.csdnimg.cn/20201129171121702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发和共享是两个最基本的特征，二者互为存在条件</span><br></pre></td></tr></table></figure><p>（3）虚拟：是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。<br>（4）异步：指多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。<br><img src="https://img-blog.csdnimg.cn/20201129171408659.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201129171502469.png" alt="在这里插入图片描述"></p><h4 id="3-操作系统的运行机制"><a href="#3-操作系统的运行机制" class="headerlink" title="3. 操作系统的运行机制"></a>3. 操作系统的运行机制</h4><p><img src="https://img-blog.csdnimg.cn/2020112917162170.png" alt="在这里插入图片描述"><br>程序是如何运行的:<br><img src="https://img-blog.csdnimg.cn/20201129175118783.png" alt="在这里插入图片描述"><br>注意：指令就是处理器（CPU）能识别，执行的最基本命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序运行的过程其实就是CPU执行一条一条的机器指令的过程</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内核是操作系统最重要最核心的部分，也是最接近硬件的部分</span><br></pre></td></tr></table></figure><ul><li>特权指令与非特权指令</li><li>应用程序只能使用非特权指令，如：加法指令，减法指令等。<br>操作系统内核作为管理者，有时会让CPU执行一些特权指令，如：内存清零指令。</li></ul><p>在CPU设计和生产的时候划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。</p><p><strong>内核态与用户态</strong><br>CPU既然能判断出指令类型，但是它怎么区分此时正在运行的是内核程序或者是应用程序呢？</p><blockquote><p>其实，CPU有两种状态，即内核态和用户态</p></blockquote><ul><li>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</li><li>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</li></ul><p>CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示内核态，0表示用户态。<br><img src="https://img-blog.csdnimg.cn/20201129175638794.png" alt="在这里插入图片描述"><br>&amp;emsp;&amp;emsp;内核程序在合适的时候主动让出CPU，从核心态切换到用户态，即将让应用程序在CPU上运行。一旦CPU处于用户态时，我们的应用程序将会在此用户态下运行，此时CPU会执行应用程序中一条又一条的指令。但是如果此时在应用程序中恶意植入了一条特权指令，那么此时CPU当执行这条特权指令时，会检查自己的PSW，发现自己依然处于用户态却要执行这条特权指令，那么这个非法事件会引发一个中断信号发送给CPU，使得CPU强行从用户态转成核心态，并且CPU会拒绝执行该特权指令以及暂停执行后面的其他指令。转而CPU会执行一个处理中断信号的内核程序。<br>&amp;emsp;&amp;emsp;换句话说，在发生中断信号之后，中断使操作系统内核再次夺回CPU的控制权，从用户态再次切换到核心态，操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序。</p><ol><li>当操作系统从内核态切换到用户态时：<br><img src="https://img-blog.csdnimg.cn/2020112917590134.png" alt="在这里插入图片描述"></li><li>当操作系统从用户态切换到内核态时：<br><img src="https://img-blog.csdnimg.cn/20201129175926589.png" alt="在这里插入图片描述"><br>从用户态切换到内核态的前提是由中断引发的，除了非法使用特权指令之外，还有许多事件会触发中断信号。一个共性是，但凡需要操作系统介入的工作地方，都会触发中断信号。</li></ol><p>小结：<br><img src="https://img-blog.csdnimg.cn/20201129180027737.png" alt="在这里插入图片描述"></p><h4 id="4-操作系统的中断与异常"><a href="#4-操作系统的中断与异常" class="headerlink" title="4. 操作系统的中断与异常"></a>4. 操作系统的中断与异常</h4><p><img src="https://img-blog.csdnimg.cn/20201130173142375.png" alt="在这里插入图片描述"><br>我们知道在CPU上会运行两种程序，一种是操作系统的内核程序，一种是应用程序。内核程序是整个系统的管理者，在计算机启动时，CPU处于内核态，只是在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。一个应用程序在上CPU运行之后，它就会一直运行下去，除非发送中断。</p><p>（1）中断的作用</p><blockquote><p>中断是让操作系统内核夺回CPU使用权的唯一途径，使CPU由用户态变为内核态。</p></blockquote><ul><li>那么问题来了，如果没有中断机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。如果CPU一直运行同一个应用程序，将如何实现多道程序并发这个事情呢？<br><img src="https://img-blog.csdnimg.cn/20201130173500721.png" alt="在这里插入图片描述"></li></ul><p>（2）中断的类型</p><blockquote><p>中断分为内中断与外中断</p></blockquote><ul><li>内中断：与当前执行的指令有关，中断信号来源于CPU内部</li><li>外中断：与当前执行的指令无关，中断信号来源于CPU外部</li></ul><p>我们来看内中断的例子：</p><ol><li>试图在用户态下执行特权指令<br><img src="https://img-blog.csdnimg.cn/20201130173817644.png" alt="在这里插入图片描述"></li><li>执行除法指令时发现除数为0<br>总之，若当前执行的指令是非法的，或执行指令的参数是非法的，那么就会引发一个中断信号。</li><li>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号。</li></ol><blockquote><p>执行陷入指令，意味着应用程序主动地将CPU控制权还给操作系统内核，系统调用就是通过陷入指令完成的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">陷入指令是一种特殊的指令不是特权指令</span><br></pre></td></tr></table></figure><p>我们再来看外中断的例子：</p><ol><li>时钟中断——由时钟部件发来的中断信号<br><img src="https://img-blog.csdnimg.cn/20201130174132106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">系统中想要并发的运行两个应用程序，首先应用程序1运行在用户态，CPU执行其指令，假如当CPU执行两条指令后，时钟部件检测已经执行过了50ms，于是时钟部件会给CPU发送一个中断信号，此时CPU会暂停执行应用程序1，转而去执行处理时钟中断的内核程序，去处理这个中断信号。<br><img src="https://img-blog.csdnimg.cn/2020113017423316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时CPU由用户态转为内核态，在处理中断信号的内核程序中，操作系统内核发现应用程序1已经用了50ms，为了公平起见，操作系统内核决定接下来让另一个应用程序2上CPU运行。<br>CPU又从内核态转为用户态，CPU执行应用程序2的指令，同样的，时钟部件检测已经过了50ms，于是时钟部件再次会给CPU发送一个中断信号，此时CPU又会暂停执行应用程序2，转而去执行处理时钟中断的内核程序。<br>在处理中断信号的内核程序中，操作系统内核发现应用程序2已经用了50ms，为了公平起见，操作系统内核决定接下来又让应用程序1上CPU运行，于是将CPU的使用权让给应用程序1，然后应用程序1就会执行它之后的未执行的指令，依次往复。</li><li>I&#x2F;O中断——由输入&#x2F;输出设备发来的中断信号<br>每一条指令执行结束时，CPU都会例行检查是否有外部中断信号<br><img src="https://img-blog.csdnimg.cn/20201130174706781.png" alt="在这里插入图片描述"></li></ol><p>（3）中断机制的基本原理</p><blockquote><p>不同的中断信号，需要用不同的中断处理程序来处理</p></blockquote><p>当CPU检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内存中的存放位置。<br><img src="https://img-blog.csdnimg.cn/20201130174908825.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130175035923.png" alt="在这里插入图片描述"></p><h4 id="5-进程的自述"><a href="#5-进程的自述" class="headerlink" title="5. 进程的自述"></a>5. 进程的自述</h4><p>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。比如在Windows中就是以后缀为.exe的可执行文件</p><p>进程：是动态的，是程序的一次执行过程</p><blockquote><p>同一个程序多次执行会对应多个进程</p></blockquote><p><strong>进程的组成部分——（PCB）</strong><br>那么既然操作系统是这些进程的管理者，它要怎么区分各个进程呢？</p><ul><li>当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的身份证号（PID）</li><li>操作系统要记录PID，进程所属用户ID（UID），操作系统可以根据PID，UID这些基本的进程描述信息，让操作系统区分各个进程。</li><li>操作系统要记录给进程分配了哪些资源（如：分配了多少内存，正在使用哪些I&#x2F;O设备，正在使用哪些文件），这些信息可以用于实现操作系统对资源的管理。</li><li>操作系统要记录进程的运行情况（如：CPU使用时间，磁盘使用情况，网络流量使用情况等），这些信息可以实现操作系统对进程的控制，调度。</li></ul><p>那么既然操作系统要记录这么多信息，那该如何整理呢?</p><ul><li>其实这些信息都被保存在一个数据结构PCB中，即进程控制块。总之，操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。<br><img src="https://img-blog.csdnimg.cn/20201130193018688.png" alt="在这里插入图片描述"><br> PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会收回其PCB。</li></ul><p><strong>进程的组成部分：PCB，程序段，数据段</strong><br><img src="https://img-blog.csdnimg.cn/20201130193201923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>这里需要明确的是PCB是给操作系统用的，而程序段，数据段是给进程自己用的。</p></blockquote><p><strong>什么是程序的运行？</strong></p><ol><li>我们知道程序在运行之前，都需要通过编译器将代码“翻译”成二进制的机器指令，一条高级语言的代码翻译过来可能会对应多条机器指令。那么程序运行的过程其实就是CPU执行一条一条的机器指令的过程。</li><li>当我们写完一个程序之后，经过编译链接等一系列的步骤，最终会形成一个后缀为.exe的可执行文件，这个可执行文件一直是存放在硬盘当中的，在系统运行这个可执行文件前需要把程序放入内存中，同时操作系统会为其创建相应的PCB，以及一些程序段也会调入内存中，我们知道程序段中包含了一条一条的指令，我们的CPU就是从内存中取出这些指令。此外，程序是基于代码的，那代码的一些运算结果同样需要被调用。换句话说，数据段也要被调入到内存之中，数据段包含了运行过程中产生的，需要使用的各种数据，比如我们定义了某些变量，就是包含在数据段里的。<br><img src="https://img-blog.csdnimg.cn/2020113019361064.png" alt="在这里插入图片描述"><br><strong>总结：一个进程的实体（进程映像）是由PCB，程序段，数据段组成的</strong></li></ol><p>进程的深度解读：<br><img src="https://img-blog.csdnimg.cn/20201130193747283.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PCB是进程存在的唯一标志！</span><br></pre></td></tr></table></figure><p>进程的特征：<br><img src="https://img-blog.csdnimg.cn/20201130193835815.png" alt="在这里插入图片描述"><br>注意：<br>（1）进程是动态的，动态性是进程最基本的特征<br>（2）异步性会导致并发程序执行结果的不确定性</p><p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130193951744.png" alt="在这里插入图片描述"></p><h4 id="6-进程的状态与转换"><a href="#6-进程的状态与转换" class="headerlink" title="6. 进程的状态与转换"></a>6. 进程的状态与转换</h4><p><img src="https://img-blog.csdnimg.cn/20201130194057456.png" alt="在这里插入图片描述"><br><strong>进程的状态——创建态，就绪态</strong><br>（1）进程正在被创建时，它的状态是创建态，在这个阶段操作系统会为进程分配资源，初始化PCB。<br>（2）当进程创建完成后，便进入就绪态，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行。<br><img src="https://img-blog.csdnimg.cn/20201130194218498.png" alt="在这里插入图片描述"><br><strong>进程的状态——运行态</strong><br>在一个进程中可能会有很多个进程都处于就绪态，当CPU空闲时，操作系统就会选择一个就绪进程，让它上处理机运行。<br><img src="https://img-blog.csdnimg.cn/2020113019432257.png" alt="在这里插入图片描述"><br>如果一个进程此时在CPU上运行，那么这个进程处于运行态。换句话说，此时CPU会执行该进程对应的程序（执行指令序列）。</p><p><strong>进程的状态——阻塞态</strong><br>在进程运行的过程中，可能会请求等待某个事件的发生，如等待某种系统资源的分配，或者等待其他进程的响应。<br>在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入阻塞态。当CPU空闲时，又会选择另一个就绪态进程上CPU运行。</p><p><strong>进程的状态——终止态</strong><br>假设此时运行在CPU上的进程1已经运行结束了，在运行结束时会发出一个（exit）的系统调用，请求操作系统终止该进程。<br><img src="https://img-blog.csdnimg.cn/20201130194630981.png" alt="在这里插入图片描述"><br>此时该进程会进入终止态，操作系统会让该进程下CPU，并回收内存空间等资源，最后还是要回收该进程的CPU。当终止进程的工作完成之后，这个进程就彻底消失了。<br><img src="https://img-blog.csdnimg.cn/20201130194710961.png" alt="在这里插入图片描述"><br>进程状态的转换（图解）：<br><img src="https://img-blog.csdnimg.cn/20201130194757461.png" alt="在这里插入图片描述"><br>进程的状态：<br><img src="https://img-blog.csdnimg.cn/20201130194845294.png" alt="在这里插入图片描述"><br>进程PCB中，会有一个变量state来表示进程的当前状态。如：1表示创建态，2表示就绪态，3表示运行态。为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p><ul><li>那么如何将各个进程的PCB组织起来？</li></ul><p><strong>链接方式与索引方式</strong></p><ol><li>链接方式<br>（1）执行指针——指向当前处于运行状态（执行态）的进程<br>（2）就绪队列指针——指向当前处于就绪状态的进程<br>（3）阻塞队列指针——指向当前处于阻塞态的进程</li></ol><p><img src="https://img-blog.csdnimg.cn/20201130195149110.png" alt="在这里插入图片描述"></p><ol start="2"><li>索引方式<br><img src="https://img-blog.csdnimg.cn/20201130195253889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020113019532145.png" alt="在这里插入图片描述"></li></ol><p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130195352126.png" alt="在这里插入图片描述"></p><h4 id="7-进程控制及原语"><a href="#7-进程控制及原语" class="headerlink" title="7. 进程控制及原语"></a>7. 进程控制及原语</h4><p><img src="https://img-blog.csdnimg.cn/20201130195509421.png" alt="在这里插入图片描述"><br><strong>（1）什么是进程控制？</strong><br>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能。</p><blockquote><p>简单的说：<strong>进程控制就是要实现进程状态转换</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201130195631854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>（2）如何实现进程控制？</strong><br><strong>进程实现进程不同状态的转换是需要用“原语”来实现的</strong><br><img src="https://img-blog.csdnimg.cn/20201130195730788.png" alt="在这里插入图片描述"></p><ul><li>原语是一种特殊的程序，它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断。</li></ul><p><strong>那么思考一个问题，为什么进程控制（状态转换）的过程要一气呵成?</strong><br><img src="https://img-blog.csdnimg.cn/20201130195902903.png" alt="在这里插入图片描述"><br>我们假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少做这样两件事：<br>（1）将PCB2的（state）设为1<br>（2）将PCB2从阻塞队列放到就绪队列</p><p>如果此时我们已经将PCB2的（state）设为1，如图：<br><img src="https://img-blog.csdnimg.cn/20201130200004558.png" alt="在这里插入图片描述"><br>但是恰好此时收到了中断信号，那么PCB2的（state）&#x3D;1本来表示就绪状态却被放在阻塞队列里，这时如果不能一气呵成，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。所以这就是为什么进程状态的转换必须一气呵成！</p><p><strong>（3）如何实现原语的原子性?</strong><br>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用关中断指令和开中断指令这两个特权指令实现原子性。</p><p>CPU正常情况下运行：<br><img src="https://img-blog.csdnimg.cn/20201130200238278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>CPU执行了关中断与开中断指令：<br><img src="https://img-blog.csdnimg.cn/20201130200312609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况?</p><ul><li>这样就意味着我们可以在程序的开头植入一个关中断指令，然后在程序的末尾植入一个开中断指令，如此只要该程序上CPU运行，那程序就可以一直霸占CPU，显然这是不应该发生的。</li></ul><blockquote><p>所以开中断与关中断是两条特权指令</p></blockquote><p>（4）进程控制相关的原语</p><ol><li>进程的创建<br><img src="https://img-blog.csdnimg.cn/20201130200543676.png" alt="在这里插入图片描述"></li><li>进程的终止<br><img src="https://img-blog.csdnimg.cn/20201130200621590.png" alt="在这里插入图片描述"></li><li>进程的阻塞和唤醒<br><img src="https://img-blog.csdnimg.cn/20201130200704575.png" alt="在这里插入图片描述"></li><li>进程的切换<br><img src="https://img-blog.csdnimg.cn/2020113020074790.png" alt="在这里插入图片描述"><br>总结：无论哪个进程控制原语，要做的无非是三件事情：<br>1.更新PCB中的信息，修改进程状态（state）保存和恢复运行环境<br>2.将PCB插入合适的队列<br>3.分配和回收资源</li></ol><p>小结：<br><img src="https://img-blog.csdnimg.cn/2020113020093581.png" alt="在这里插入图片描述"></p><h4 id="8-线程与多线程模型"><a href="#8-线程与多线程模型" class="headerlink" title="8. 线程与多线程模型"></a>8. 线程与多线程模型</h4><p><img src="https://img-blog.csdnimg.cn/20201130201102948.png" alt="在这里插入图片描述"><br>在没有引入进程之前，系统中的各个程序只能串行执行，换句话说我们如果想要一边听音乐，一边玩QQ是不可以的。在引入进程之后，我们可以一边听音乐，一边玩QQ。但是问题来了，QQ中许多的功能，比如视频，文字聊天，传送文件等，可我们知道进程是程序的一次执行，那么这些功能显然不可能是由一个程序顺序处理就能实现的。<br><img src="https://img-blog.csdnimg.cn/20201130201206621.png" alt="在这里插入图片描述"><br>因此我们引入了线程的概念：<br><img src="https://img-blog.csdnimg.cn/20201130201242870.png" alt="在这里插入图片描述"><br><strong>传统的进程是程序执行流的最小单位，但在引入线程后，线程成为了程序执行流的最小单位。</strong></p><blockquote><p>同样，我们可以把线程理解为轻量级的进程</p></blockquote><p>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务，这时进程只作为除CPU之外的系统资源的分配单元</p><p>引入线程机制后，有什么变化?<br><img src="https://img-blog.csdnimg.cn/20201130201557296.png" alt="在这里插入图片描述"><br>线程的属性：<br><img src="https://img-blog.csdnimg.cn/2020113020163869.png" alt="在这里插入图片描述"><br>线程的实现方式与多线程模型<br><img src="https://img-blog.csdnimg.cn/20201130201717759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）用户级线程<br><img src="https://img-blog.csdnimg.cn/20201130201811431.png" alt="在这里插入图片描述"><br>很多编程语言提供了强大的线程库，可以实现线程的创建，销毁，调度等功能。</p><ul><li>那么线程的管理工作由谁来完成的?</li></ul><blockquote><p>线程的管理工作由应用程序提供的线程库来完成的，并不是由操作系统来完成的。</p></blockquote><ul><li><p>线程切换是否需要CPU从用户态转换为内核态?</p><blockquote><p>其实线程切换是由应用程序的线程库自己完成的，在用户态下就可以完成线程切换，不需要操作系统的切换。</p></blockquote></li><li><p>操作系统是否能意识到用户级线程的存在?</p></li></ul><blockquote><p>不能，只有用户才能感知到用户级线程的存在。</p></blockquote><p>用户级线程的优缺点：</p><ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li></ul><p>（2）内核级线程<br>内核级线程，由操作系统支持的线程<br><img src="https://img-blog.csdnimg.cn/20201130202217866.png" alt="在这里插入图片描述"><br>注意：内核级线程与用户级线程不同</p><ol><li>内核级线程的管理工具由操作系统内核完成</li><li>线程调度，切换等工作都由内核负责，因此内核级线程的切换必须需要在核心态下才能完成</li><li>操作系统会为每个内核级线程建立相应的TCB(线程控制块)，通过TCB对线程进行管理。内核级线程就是从操作系统内核视角看能看到的线程。</li></ol><p>内核级线程的优缺点：</p><ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul><p><strong>多线程模型</strong><br>之前我们讨论了用户级线程与内核级线程的优缺点，那么我们是否可以将这两种线程方式结合起来呢？<br>（1）一对一模型<br><img src="https://img-blog.csdnimg.cn/20201130202425320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（2）多对一模型<br><img src="https://img-blog.csdnimg.cn/20201130202458186.png" alt="在这里插入图片描述"><br>（3）多对多模型<br><img src="https://img-blog.csdnimg.cn/20201130202545249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总结：内核级线程与用户级线程</span><br><span class="line">（1）用户级线程是代码逻辑的载体</span><br><span class="line">（2）内核级线程是运行机会的载体</span><br><span class="line">（3）内核级线程才是处理机分配的单位</span><br><span class="line">（4）一段代码逻辑只有获得了运行机会才能被CPU执行</span><br></pre></td></tr></table></figure><blockquote><p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。</p></blockquote><p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130202806858.png" alt="在这里插入图片描述"></p><h4 id="9-处理机调度"><a href="#9-处理机调度" class="headerlink" title="9. 处理机调度"></a>9. 处理机调度</h4><p><img src="https://img-blog.csdnimg.cn/20201130202916595.png" alt="在这里插入图片描述"><br>调度的基本原理：<br>当我们去银行取钱时，我们或许需要排队等待，作为普通客户，一般银行遵循着先到先服务的顺序。但是如果有VIP客户的话，他们未必需要排队就可以优先被服务。<br><img src="https://img-blog.csdnimg.cn/20201130203017174.png" alt="在这里插入图片描述"><br>当有一堆任务要处理，但由于资源有限，任务没法同时处理这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。</p><p><strong>高级调度</strong></p><p>作业：一个具体的任务</p><blockquote><p>用户向系统提交一个作业 &#x3D; 用户让操作系统启动一个程序（来处理一个具体的任务）</p></blockquote><p>但是问题来了，我们的内存空间有限，有时无法将用户提交的作业全部放入内存，那该这么办呢？</p><ul><li>所谓高级调度（作业调度），是按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</li></ul><p><strong>低级调度</strong></p><ul><li>指按照某种策略从就绪队列中选择一个进程，将处理机分配给它。</li><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201130203455354.png" alt="在这里插入图片描述"><br><strong>中级调度</strong><br>内存不够时，可将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存。暂时调到外存等待的进程状态为挂起状态，被挂起的进程PCB会被组织成挂起队列。<br><img src="https://img-blog.csdnimg.cn/20201130203603869.png" alt="在这里插入图片描述"></p><ul><li>所谓中级调度（内存调度）是指按照某种策略决定将哪个处于挂起状态的进程重新调入内存。</li><li>一个进程可能会被多次调出，调入内存，因此中级调度发生的频率要比高级调度更高。</li></ul><p><strong>挂起状态</strong><br><img src="https://img-blog.csdnimg.cn/2020113020371124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130203735243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>三层调度的联系与对比：<br><img src="https://img-blog.csdnimg.cn/20201130203813793.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130203852552.png" alt="在这里插入图片描述"></p><h4 id="10-进程调度的时机"><a href="#10-进程调度的时机" class="headerlink" title="10. 进程调度的时机"></a>10. 进程调度的时机</h4><p><img src="https://img-blog.csdnimg.cn/20201130204022410.png" alt="在这里插入图片描述"><br><strong>进程调度的时机</strong><br>我们知道进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。那什么时候进行进程调度与切换的情况?<br>（1）当前运行的进程主动放弃处理机<br>（2）当前运行的进程被动放弃处理机</p><p><img src="https://img-blog.csdnimg.cn/20201130204127288.png" alt="在这里插入图片描述"></p><ul><li>进程在操作系统内核程序临界区中不能进行调度与切换</li><li>进程处于临界区时不能进行处理机调度</li></ul><p><strong>临界资源：是指一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源。</strong></p><p><strong>临界区：指访问临界资源的这段代码。</strong></p><ul><li>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</li></ul><p>举两个例子：<br>（1）内核程序临界区访问的临界资源需要尽快的释放，不可以进行进程调度和切换<br><img src="https://img-blog.csdnimg.cn/20201130204416676.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130204441942.png" alt="在这里插入图片描述"><br>（2）普通临界区访问的临界资源时可以进行进程调度和切换<br><img src="https://img-blog.csdnimg.cn/20201130204522128.png" alt="在这里插入图片描述"><br><strong>进程调度的方式</strong></p><ol><li><strong>非剥夺调度方式</strong>，又称非抢占式。即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终于或主动要求进入阻塞状态。</li><li><strong>剥夺调度方式</strong>，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li></ol><ul><li><p>非剥夺调度方式实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p></li><li><p>剥夺调度方式可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能，适合于分时操作系统，实时操作系统。</p></li></ul><p><strong>进程的切换与过程</strong></p><ul><li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程</li><li>广义的进程调度包含了选择一个进程和进程切换两个步骤</li></ul><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。<br><img src="https://img-blog.csdnimg.cn/20201130204820966.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130204919507.png" alt="在这里插入图片描述"></p><h4 id="11-调度算法的评价指标"><a href="#11-调度算法的评价指标" class="headerlink" title="11. 调度算法的评价指标"></a>11. 调度算法的评价指标</h4><p><img src="https://img-blog.csdnimg.cn/20201130205043610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>CPU的利用率</strong></p><p>CPU利用率：是指CPU忙碌的时间占总时间的比例<br><img src="https://img-blog.csdnimg.cn/20201130205145579.png" alt="在这里插入图片描述"><br>来道例题：<br><img src="https://img-blog.csdnimg.cn/20201130205232301.png" alt="在这里插入图片描述"><br><strong>系统吞吐量</strong></p><p>系统吞吐量是指：单位时间内完成作业的数量<br><img src="https://img-blog.csdnimg.cn/20201130205326598.png" alt="在这里插入图片描述"><br>来道例题：<br><img src="https://img-blog.csdnimg.cn/20201130205348799.png" alt="在这里插入图片描述"><br><strong>周转时间</strong></p><p>周转时间是指：从作业被提交给系统开始，到作业完成为止的这段时间间隔</p><ul><li>周转时间包括四个部分：</li></ul><ol><li>作业在外存后备队列上等待作业调度（高级调度）的时间</li><li>进程在就绪队列等待进程调度（低级调度）的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I&#x2F;O操作完成的时间</li></ol><p><strong>周转时间与平均周转时间</strong><br><img src="https://img-blog.csdnimg.cn/20201130205710800.png" alt="在这里插入图片描述"><br><strong>带权周转时间</strong></p><p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。<br><img src="https://img-blog.csdnimg.cn/20201130205808761.png" alt="在这里插入图片描述"><br>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">带权周转时间必然大于（等于）1</span><br><span class="line">带权周转时间与周转时间都是越小越好</span><br></pre></td></tr></table></figure><p><strong>平均带权周转时间</strong><br><img src="https://img-blog.csdnimg.cn/20201130205929946.png" alt="在这里插入图片描述"><br><strong>等待时间</strong></p><p>等待时间：指进程（作业）处于等待处理机状态时间之和，等待时间越长，用户满意度越低。<br><img src="https://img-blog.csdnimg.cn/20201130210054872.png" alt="在这里插入图片描述"><br>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。</p><p><strong>响应时间</strong></p><p>响应时间：指从用户提交请求到首次产生响应所用的时间。</p><p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130210304160.png" alt="在这里插入图片描述"></p><h4 id="12-调度算法思想及规则（上）"><a href="#12-调度算法思想及规则（上）" class="headerlink" title="12. 调度算法思想及规则（上）"></a>12. 调度算法思想及规则（上）</h4><p><img src="https://img-blog.csdnimg.cn/20201130210458236.png" alt="在这里插入图片描述"><br><strong>一. 先来先服务调度算法（FCFS）</strong></p><p>（1）算法思想：</p><ul><li>主要是从公平的角度考虑（类似于我们生活中排队买东西的例子）</li></ul><p>（2）算法规则：</p><ul><li>按照作业&#x2F;进程到达的先后顺序进行服务</li><li>按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务</li></ul><p>（3）用于作业（进程）调度：</p><ul><li>用于作业调度时，考虑的是哪个作业先到达后备队列</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li></ul><p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130210703184.png" alt="在这里插入图片描述"><br>（4）先来先服务调度算法的优缺点：</p><ul><li>优点：公平，算法实现简单</li><li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li><li>即先来先服务调度算法对长作业有利，对短作业不利</li><li>先来先服务调度算法是不会导致饥饿的</li></ul><p>（5）先来先服务调度算法概述：<br><img src="https://img-blog.csdnimg.cn/20201130210935307.png" alt="在这里插入图片描述"><br><strong>二. 短作业优先调度算法（SJF）</strong></p><p>（1）算法思想：</p><ul><li>追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</li></ul><p>（2）算法规则：</p><ul><li>最短的作业&#x2F;进程优先得到服务（所谓”最短“，是指要求服务时间最短）</li></ul><p>（3）用于作业（进程）调度：</p><ul><li>即可用于作业调度，也可用于进程调度</li><li>用于进程调度时称为”短进程优先算法（SPF）</li></ul><p>（4）是否可抢占：</p><ul><li>SJF和SPF是非抢占式的算法</li><li>但是也有抢占式的版本——最短剩余时间优先算法（SRTN）</li></ul><p>例题：<br>使用非抢占式的短作业优先调度算法SJF<br><img src="https://img-blog.csdnimg.cn/20201130211155717.png" alt="在这里插入图片描述"><br>使用抢占式的短作业优先调度算法SRTN<br><img src="https://img-blog.csdnimg.cn/20201130211246631.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130211314119.png" alt="在这里插入图片描述"><br>使用短作业优先算法需要注意：<br><img src="https://img-blog.csdnimg.cn/20201130211352171.png" alt="在这里插入图片描述"><br>（5）短作业优先调度算法的优缺点：</p><ul><li>优点：最短的平均等待时间，平均周转时间</li><li>缺点：对短作业有利，对长作业不利。可能产生饥饿现象。</li></ul><p>（6）短作业优先调度算法概述：<br><img src="https://img-blog.csdnimg.cn/20201130211613567.png" alt="在这里插入图片描述"><br>对FCFS和SJF两种算法的思考：</p><blockquote><p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题。</p></blockquote><blockquote><p>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。</p></blockquote><p><strong>那么，我们能不能设计一个算法，即考虑到各个作业的等待时间，也能兼顾运行时间?</strong></p><p><strong>三. 高响应比优先调度算法（HRRN）</strong></p><p>（1）算法思想</p><ul><li>要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</li></ul><p>（2）算法规则</p><ul><li>在每次调度时先计算各个作业（进程）的响应比，选择响应比最高的作业（进程）为其服务<br><img src="https://img-blog.csdnimg.cn/20201130211754256.png" alt="在这里插入图片描述"></li></ul><p>（3）用于作业（进程）调度</p><ul><li>即可用于作业调度，也可用于进程调度</li></ul><p>（4）是否可抢占?</p><ul><li>非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比</li></ul><p>（5）高响应比优先算法优缺点</p><ul><li>优点：综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF的优点） 要求服务时间相同时，等待时间长的优先（FCFS的优点）</li><li>缺点：对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li></ul><p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130212008856.png" alt="在这里插入图片描述"><br>（6）高响应比优先算法概述<br><img src="https://img-blog.csdnimg.cn/20201130212058968.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130212130899.png" alt="在这里插入图片描述"></p><h4 id="13-调度算法思想及规则（下）"><a href="#13-调度算法思想及规则（下）" class="headerlink" title="13. 调度算法思想及规则（下）"></a>13. 调度算法思想及规则（下）</h4><p><img src="https://img-blog.csdnimg.cn/20201130212331519.png" alt="在这里插入图片描述"><br><strong>四. 时间片轮转调度算法（RR）</strong></p><p>（1）算法思想</p><ul><li>公平的，轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</li></ul><p>（2）算法规则</p><ul><li>按照各进程到达就绪队列的顺序，轮转让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li></ul><p>（3）用于作业（进程）调度</p><ul><li>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li></ul><p>（4）是否可抢占?</p><ul><li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。</li></ul><p>（5）时间片轮转调度算法的优缺点</p><ul><li>优点：公平：响应快，适用于分时操作系统，不会导致饥饿</li><li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</li></ul><p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130212553334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.当时间片大小为2时：<img src="https://img-blog.csdnimg.cn/20201130212649602.png" alt="在这里插入图片描述"><br>时刻流程图：<br>（1）0-5时刻（2）6-11时刻（3）12-16时刻<br><img src="https://img-blog.csdnimg.cn/20201130212749185.png" alt="在这里插入图片描述"><br>2.当时间片大小为5时：<br><img src="https://img-blog.csdnimg.cn/20201130212856809.png" alt="在这里插入图片描述"><br>同一道例题，我们对比用先来先服务调度算法<br><img src="https://img-blog.csdnimg.cn/20201130212939750.png" alt="在这里插入图片描述"></p><blockquote><ul><li>我们发现：如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li><li>如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</li></ul></blockquote><p>（6）时间片轮转调度算法概述<br><img src="https://img-blog.csdnimg.cn/2020113021310935.png" alt="在这里插入图片描述"><br><strong>五. 优先级调度算法</strong></p><p>（1）算法思想</p><ul><li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li></ul><p>（2）算法规则</p><ul><li>每个作业（进程）有各自的优先级，调度时选择优先级最高的作业&#x2F;进程</li></ul><p>（3）用于作业（进程）调度</p><ul><li>既可以用与作业调度，也可以用于进程调度。甚至还会用于I&#x2F;O调度。</li></ul><p>（4）是否可抢占?</p><ul><li>抢占式，非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可。而抢占式还需要在就绪队列变化时，检查是否会发生抢占。</li></ul><p>（5）优先级调度算法的优缺点</p><ul><li>优点：用优先级区分紧急程度，重要程度，适合于实时操作系统。可灵活的调整对各种作业（进程）的偏好程度。</li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。</li></ul><p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130213317568.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130213344547.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130213417756.png" alt="在这里插入图片描述"><br>（6）优先级调度算法概述<br><img src="https://img-blog.csdnimg.cn/20201130213614701.png" alt="在这里插入图片描述"><br>思考：<br><img src="https://img-blog.csdnimg.cn/20201130213647557.png" alt="在这里插入图片描述"><br><strong>六. 多级反馈队列调度算法（简述）</strong><br><img src="https://img-blog.csdnimg.cn/20201130213738863.png" alt="在这里插入图片描述"><br>例题：<br><img src="https://img-blog.csdnimg.cn/20201130213856668.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130213937102.png" alt="在这里插入图片描述"></p><h4 id="14-进程同步与进程互斥"><a href="#14-进程同步与进程互斥" class="headerlink" title="14. 进程同步与进程互斥"></a>14. 进程同步与进程互斥</h4><p><img src="https://img-blog.csdnimg.cn/20201130214104149.png" alt="在这里插入图片描述"><br><strong>什么是进程同步?</strong></p><p>我们来看一个管道通信的例子：<br><img src="https://img-blog.csdnimg.cn/20201130214341266.png" alt="在这里插入图片描述"></p><blockquote><p>异步性是指：各并发执行的进程以各自独立的，不可预知的速度向前推进</p></blockquote><ul><li>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。</li><li>进程间的直接制约关系就是源于它们之间的相互合作。</li></ul><p><strong>什么是进程互斥?</strong><br><strong>进程的并发需要共享的支持，各个并发执行的进程不可避免地需要共享一些系统资源。</strong><br><img src="https://img-blog.csdnimg.cn/20201130214558494.png" alt="在这里插入图片描述"><br>对临界资源地互斥访问，可以在逻辑上分为如下四个部分：<br>1.进入区 2.临界区 3.退出区 4.剩余区</p><blockquote><p>注意：<br>临界区是进程中访问临界资源的代码段<br>进入区和退出区是负责实现互斥的代码段 </p></blockquote><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：<br><img src="https://img-blog.csdnimg.cn/20201130214717696.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130214754398.png" alt="在这里插入图片描述"></p><h4 id="15-生产者消费者问题"><a href="#15-生产者消费者问题" class="headerlink" title="15. 生产者消费者问题"></a>15. 生产者消费者问题</h4><p>问题描述：</p><blockquote><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（这里的产品理解为某种数据）</p></blockquote><p>1.整理思路<br>（1）生产者，消费者共享一个初始为空，大小为n的缓冲区。<br>如图：缓冲区的大小为5<br><img src="https://img-blog.csdnimg.cn/20201130215058140.png" alt="在这里插入图片描述"><br>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p><p>（2）如果缓冲区已经满了，生产者进程依然向缓冲区里写数据，此时生产者进程必须等待，当缓冲区中有空的时候才能向缓冲区里写数据。<br><img src="https://img-blog.csdnimg.cn/20201130215223162.png" alt="在这里插入图片描述"><br>（3）只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。<br><img src="https://img-blog.csdnimg.cn/20201130215336495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（4）缓冲区是临界资源，各进程必须互斥地访问。<br><img src="https://img-blog.csdnimg.cn/20201130215509458.png" alt="在这里插入图片描述"><br>2.关系分析<br><img src="https://img-blog.csdnimg.cn/20201130215623641.png" alt="在这里插入图片描述"></p><ul><li>当生产者进程向缓冲区放入一个产品后，此时信号量需要执行一个V操作</li><li>当消费者进程在缓冲区取走一个产品前，此时信号量需要执行一个P操作</li></ul><p>3.代码实现<br><img src="https://img-blog.csdnimg.cn/20201130215737664.png" alt="在这里插入图片描述"><br>实现两对同步关系：<br><img src="https://img-blog.csdnimg.cn/20201130215814431.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为缓冲区是临界资源，各进程必须互斥地访问，所以我们还需要设置互斥信号量</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201130215918585.png" alt="在这里插入图片描述"><br>4. 代码分析<br>执行V操作的进程会唤醒对应执行P操作的进程：<br><img src="https://img-blog.csdnimg.cn/20201130220006653.png" alt="在这里插入图片描述"><br><strong>思考：能否改变相邻P，V操作的顺序?</strong><br><img src="https://img-blog.csdnimg.cn/20201130220054407.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130220153459.png" alt="在这里插入图片描述"></p><h4 id="16-读者与写者问题"><a href="#16-读者与写者问题" class="headerlink" title="16. 读者与写者问题"></a>16. 读者与写者问题</h4><p>问题描述：</p><blockquote><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致不一致的错误。</p></blockquote><p>因此要求：<br>（1）允许多个读者可以同时对文件执行读操作<br>（2）只允许一个写者往文件中写信息<br>（3）任意写者在完成写操作之前不允许其他读者或写者工作<br>（4）写者执行写操作前，应让己有的读者和写者全部退出</p><p>注意：</p><ul><li>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据。</li><li>读进程与写进程同时共享数据，可能导致读出的数据不一致的问题。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020113022041482.png" alt="在这里插入图片描述"><br>如果两个写进程同时共享数据，可能导致数据错误覆盖的问题</p><p>1.关系分析<br><img src="https://img-blog.csdnimg.cn/20201130220524804.png" alt="在这里插入图片描述"><br>2.如何实现<br><img src="https://img-blog.csdnimg.cn/20201130220617786.png" alt="在这里插入图片描述"><br>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能饿死。因此，这种算法中，读进程是优先的。</p><p>那么如何解决写进程饿死的状态呢，我们来看代码：<br><img src="https://img-blog.csdnimg.cn/2020113022072152.png" alt="在这里插入图片描述"><br>结论：在这种算法中，连续进入的多个读者可以同时读文件。写者和其他进程不能同时访问文件，写者不会饥饿，但也并不会是真正的写优先，而是相对公平的先来先服务原则。</p><blockquote><p>读者写者问题为我们解决复杂的互斥问题提供了一个参考思路。其核心思想在于设置了一个计数器（count）用来记录当前正在访问共享文件的读进程数。我们可以用（count）的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对（count）变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现一气呵成，自然应该想到用互斥信号量。</p></blockquote><h4 id="17-哲学家进餐问题"><a href="#17-哲学家进餐问题" class="headerlink" title="17. 哲学家进餐问题"></a>17. 哲学家进餐问题</h4><p>问题描述：</p><blockquote><p>一个圆桌上坐着5名哲学家，每两个哲学家之间的桌子上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。<br><img src="https://img-blog.csdnimg.cn/20201130221720966.png" alt="在这里插入图片描述"></p></blockquote><p>1.关系分析</p><ul><li>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li></ul><p>2.整理思路</p><ul><li>哲学家问题只有互斥关系，但与之前遇到的问题不是的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li></ul><p>3.解决方案</p><ul><li>信号量设置。定义互斥信号量数组<code>chopstick[5]=&#123;1,1,1,1,1&#125;</code>用于实现对5个筷子的互斥访问。并对哲学家按<code>0-4</code>编号，哲学家<code>i</code>左边的筷子编号为<code>i</code>，右边的筷子编号为<code>(i+1)%5</code>，每个哲学家吃饭前依次拿起左，右两支筷子。<br><img src="https://img-blog.csdnimg.cn/20201130221927735.png" alt="在这里插入图片描述"></li><li>但是如果5个哲学家并发地拿起了自己左手边的筷子，那么会出现的问题是每位哲学家循环等待右边的人放下筷子（阻塞），发生死锁。<br><img src="https://img-blog.csdnimg.cn/2020113022201948.png" alt="在这里插入图片描述"></li></ul><p>如何防止死锁的发生呢?<br><img src="https://img-blog.csdnimg.cn/20201130222150915.png" alt="在这里插入图片描述"></p><p>4.解决思路<br>（1）最多允许四个哲学家同时进餐<br>（2）在每个哲学家进餐之前先判断哲学家是奇数还是偶数</p><p>当然，我们还可以这样解决死锁问题：</p><blockquote><p>我们可以规定仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020113022232081.png" alt="在这里插入图片描述"><br>我们用信号量<code>mutex</code>，保证了哲学家拿筷子这件事必须互斥的进行。即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p><h4 id="18-死锁的自述"><a href="#18-死锁的自述" class="headerlink" title="18. 死锁的自述"></a>18. 死锁的自述</h4><p><img src="https://img-blog.csdnimg.cn/20201130222532258.png" alt="在这里插入图片描述"><br>什么是死锁?<br>（1）我们来看一个哲学家进餐的问题<br><img src="https://img-blog.csdnimg.cn/20201130222622674.png" alt="在这里插入图片描述"><br>每位哲学家都在等待自己右边的人放下筷子，这些哲学家进程都因为等待筷子资源而被阻塞，即发生死锁。</p><p><strong>那么在并发环境下，各进程因竞争资源而造成的一种相互等待对方手里的资源，导致各进程都被阻塞，都无法向前推进的现象，就是死锁。</strong></p><p>死锁，饥饿，死循环的区别：<br><img src="https://img-blog.csdnimg.cn/20201130222819351.png" alt="在这里插入图片描述"><br><strong>死锁产生的必要条件：</strong></p><blockquote><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生</p></blockquote><ol><li><p>互斥条件<br>只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子，打印机设备）。像内存，扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这些资源）。</p></li><li><p>不剥夺条件<br>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p></li><li><p>请求和保持条件<br>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p></li><li><p>循环等待条件<br>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p></li></ol><blockquote><p>注意： </p><ul><li>发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）。</li><li>如果同类资源大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</li></ul></blockquote><p>什么时候会发生死锁?<br><img src="https://img-blog.csdnimg.cn/20201130223110264.png" alt="在这里插入图片描述"><br><strong>总之，对不可剥夺资源的不合理分配，可能导致死锁</strong></p><p>死锁的处理策略：<br><img src="https://img-blog.csdnimg.cn/20201130223156758.png" alt="在这里插入图片描述"><br>预防死锁：<br><img src="https://img-blog.csdnimg.cn/2020113022323250.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130223317453.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201129164412796.jpg&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-操作系统的概念及功能&quot;&gt;&lt;a href=&quot;#1-操作系统的概念及功能&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>https://suenning.com.cn/2023/02/01/%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</id>
    <published>2023-02-01T08:11:37.394Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.哈夫曼树<br><img src="https://img-blog.csdnimg.cn/20200515195432101.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HC=((d,<span class="number">0</span>),(i,<span class="number">10</span>),(a,<span class="number">110</span>),(n,<span class="number">111</span>))</span><br></pre></td></tr></table></figure><p>2.如何构造哈夫曼树</p><blockquote><p>构造哈夫曼树非常简单，将所有的节点放到一个队列中，用一个节点替换两个频率最低的节点，新节点的频率就是这两个节点的频率之和。这样，新节点就是两个被替换节点的父节点了。如此循环，直到队列中只剩一个节点(树根)。</p></blockquote><ol><li><p>对给定的<code>n</code>个权值<code>&#123;W1,W2,W3,…,Wi,…,Wn&#125;</code>构成<code>n</code>棵二叉树的初始集合<code>F= &#123;T1,T2,T3,…,Ti,…,Tn&#125;</code>，其中每棵二叉树<code>Ti</code>中只有一个权值为<code>Wi</code>的根结点，它的左右子树均为空。</p></li><li><p>在<code>F</code>中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。</p></li><li><p>从<code>F</code>中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合<code>F</code>中。</p></li><li><p>重复二和三两步，直到集合<code>F</code>中只有一棵二叉树为止。</p></li></ol><p>举个例子：</p><ul><li>如图有A，B，C，D共4棵二叉树，其权值分别为5，7，2，13<br><img src="https://img-blog.csdnimg.cn/20200515200508431.png" alt="在这里插入图片描述"></li></ul><ol><li>选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，即A和C，新二叉树的根结点的权值为其左右子树的根结点的权值之和，即<code>2+5=7</code><br><img src="https://img-blog.csdnimg.cn/20200515200658514.png" alt="在这里插入图片描述"></li><li>继续在此基础上，选择一棵根节点结点权值小的树作为新构造的二叉树的左子树，即B和7，新二叉树的根结点的权值为其左右子树的根结点的权值之和，即<code>7+7=14</code><br><img src="https://img-blog.csdnimg.cn/20200515200808213.png" alt="在这里插入图片描述"></li><li>继续在此基础上，选择一棵根节点结点权值小的树作为新构造的二叉树的左子树，即D和14，新二叉树的根结点的权值为其左右子树的根结点的权值之和，即<code>13+14=27</code><br><img src="https://img-blog.csdnimg.cn/20200515201156806.png" alt="在这里插入图片描述"></li><li>此时哈夫曼树构成</li><li>引入二进制编码，各叶子结点的二进制编码如下：<code>D(0),B(10),C(110),(111)</code></li></ol><p>编程题：<br>1.领会哈夫曼的构造过程以及哈夫曼编码的生产过程<br>2.构造一棵哈夫曼树，输出对应的哈夫曼编码和平均查找长度<br><img src="https://img-blog.csdnimg.cn/20200515193739158.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2 * N-1 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">5</span>]; </span><br><span class="line"><span class="type">int</span> weight; </span><br><span class="line"><span class="type">int</span> parent; </span><br><span class="line"><span class="type">int</span> lchild; </span><br><span class="line"><span class="type">int</span> rchild; </span><br><span class="line">&#125;HTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> cd[N]; </span><br><span class="line"><span class="type">int</span> start; </span><br><span class="line">&#125;HCode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHT</span><span class="params">(HTNode ht[],<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,k,lnode,rnode;</span><br><span class="line"><span class="type">int</span> min1,min2;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++) </span><br><span class="line">ht[i].parent=ht[i].lchild=ht[i].rchild=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (i=n;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line">min1=min2=<span class="number">32767</span>; </span><br><span class="line">lnode = rnode = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;=i<span class="number">-1</span>;k++) </span><br><span class="line"><span class="keyword">if</span>(ht[k].parent==<span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ht[k].weight&lt;min1)</span><br><span class="line">&#123;</span><br><span class="line">min2=min1;</span><br><span class="line">rnode=lnode;</span><br><span class="line">min1=ht[k].weight;</span><br><span class="line">lnode=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ht[k].weight&lt;min2)</span><br><span class="line">&#123;</span><br><span class="line">min2=ht[k].weight;</span><br><span class="line">rnode=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ht[lnode].parent=i;</span><br><span class="line">ht[rnode].parent=i;</span><br><span class="line">ht[i].weight=ht[lnode].weight+ht[rnode].weight;</span><br><span class="line">ht[i].lchild=lnode;</span><br><span class="line">ht[i].rchild=rnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHCode</span><span class="params">(HTNode ht[],HCode hcd[],<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,f,c;</span><br><span class="line">HCode hc;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">&#123;</span><br><span class="line">hc.start=n;</span><br><span class="line">c=i;</span><br><span class="line">f=ht[i].parent; </span><br><span class="line"><span class="keyword">while</span>(f!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ht[f].lchild==c) </span><br><span class="line">hc.cd[hc.start--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">hc.cd[hc.start--]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">c=f;</span><br><span class="line">f=ht[f].parent;</span><br><span class="line">&#125;</span><br><span class="line">hc.start++; </span><br><span class="line">hcd[i]=hc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispHCode</span><span class="params">(HTNode ht[],HCode hcd[],<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,k; </span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>,m=<span class="number">0</span>,j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输出哈夫曼编码:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s:\t&quot;</span>,ht[i].data);</span><br><span class="line"><span class="keyword">for</span>(k=hcd[i].start;k&lt;=n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,hcd[i].cd[k]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">m+=ht[i].weight;</span><br><span class="line">sum+=ht[i].weight * j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n平均长度=%g\n&quot;</span>,<span class="number">1.0</span> * sum/m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">15</span>,i;</span><br><span class="line"><span class="type">char</span> * str[]=&#123;<span class="string">&quot;The&quot;</span>,<span class="string">&quot;of&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;to&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;in&quot;</span>,<span class="string">&quot;that&quot;</span>,<span class="string">&quot;he&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;at&quot;</span>,<span class="string">&quot;on&quot;</span>,<span class="string">&quot;for&quot;</span>,<span class="string">&quot;His&quot;</span>,<span class="string">&quot;are&quot;</span>,<span class="string">&quot;be&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> fnum[]=&#123;<span class="number">1192</span>,<span class="number">677</span>,<span class="number">541</span>,<span class="number">518</span>,<span class="number">462</span>,<span class="number">450</span>,<span class="number">242</span>,<span class="number">195</span>,<span class="number">190</span>,<span class="number">181</span>,<span class="number">174</span>,<span class="number">157</span>,<span class="number">138</span>,<span class="number">124</span>,<span class="number">123</span>&#125;;</span><br><span class="line">HTNode ht[M];</span><br><span class="line">HCode hcd[N];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(ht[i].data,str[i]);</span><br><span class="line">ht[i].weight=fnum[i];</span><br><span class="line">&#125;</span><br><span class="line">CreateHT(ht,n);</span><br><span class="line">CreateHCode(ht,hcd,n);</span><br><span class="line">DispHCode(ht,hcd,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.哈夫曼树&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200515195432101.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-02-01T08:11:37.378Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道在C语言中是没有<strong>字符串</strong>这个数据类型的，那我们如何来处理字符串呢？事实上我们是把字符串当成<strong>字符数组</strong>来处理。</p><p>**字符串的实质是：字符数组+’\0’**，用反斜杠0来表示字符串的结尾。<br><strong>那当字符串作为数组的元素，我们如何操作呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[<span class="number">5</span>]=<span class="string">&quot;hello&quot;</span>; <span class="comment">//字符数组</span></span><br></pre></td></tr></table></figure><p>那么如果我们要表示:<strong>{“aaa”,”aaa”,”aaa”,”aaa”,”aaa”}<strong>，该用什么数据类型呢？<br><strong>【指针数组】</strong><br><strong>指针数组</strong>是指</strong>数组元素为指针</strong>的<strong>数组</strong>；</p><p> <strong>指针数组是由二维数组演化而来</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;；</span><br></pre></td></tr></table></figure><p>我们都知道二维数组可以看成是<strong>元素是数组的一维数组</strong>，也就是可以把上面改为：<code>int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</code>，每一行用括号括起来。换句话说，可以表示为<code>int a[2]=&#123;a1[3],a2[3]&#125;;</code></p><blockquote><p>元素是数组的数组</p></blockquote><p>这里的<code>a1[3]=&#123;1,2,3&#125;</code>，<code>a2[3]=&#123;4,5,6&#125;</code>，既然如此，我们便可以声明两个指针p1，p2，由于数组名是首地址，即<code>int *p1=a1</code>，<code>int *p2=a2</code>，所以我们可以得到<code>int *a[2]=&#123;p1,p2&#125;;</code></p><blockquote><p>元素是指针的数组</p></blockquote><p><strong>【字符串是一种特殊的数组】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>字符串&#x3D;字符串+‘\0’</strong><br><strong>字符串的名称就是字符串的首地址</strong></p><p>我们声明三个字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>]=<span class="string">&quot;welcome&quot;</span>;</span><br><span class="line"><span class="type">char</span> str3[<span class="number">10</span>]=<span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们再声明三个指针，分别指向三个字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p1= str1;</span><br><span class="line"><span class="type">char</span> *p2= str2;</span><br><span class="line"><span class="type">char</span> *p3= str3;</span><br></pre></td></tr></table></figure><p>我们把三个指针放到字符数组里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="built_in">string</span>[<span class="number">3</span>]=&#123;p1,p2,p3&#125;;<span class="comment">//因为存放的是指针，所以数组名前要加星号</span></span><br></pre></td></tr></table></figure><p>将p1,p2,p3用字符串首地址代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="built_in">string</span>[<span class="number">3</span>]=&#123;str1,str2,str3&#125;</span><br></pre></td></tr></table></figure><p>再将字符串的值代入数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="built_in">string</span>[<span class="number">3</span>]=&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;welcome&quot;</span>,<span class="string">&quot;string&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>字符串做元素的数组，这个数组的类型是字符串指针类型，也就是char *类型。</p><p>我们来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *week[<span class="number">7</span>]=&#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Satuaday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> day=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input day(1...7):&quot;</span>)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);</span><br><span class="line"><span class="keyword">if</span>(day==<span class="number">7</span>&amp;&amp;day==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n equ:%s\n&quot;</span>,day,week[day<span class="number">-1</span>]);<span class="comment">//下标是0-6，所以要减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串指针的性质</strong><br>1.字符串可以当作数组来处理；<br>2.可以声明一个指针p，利用指针偏移量来访问数组；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p=str;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*(p+i));<span class="comment">//指针偏移量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串与字符数组的联系</strong><br>1.字符串被当做字符数组来处理；<br>2.字符串的首地址是字符串名，字符数组的首地址是数组名，其性质相同；</p><p><strong>字符串与字符数组的区别</strong><br>1.字符串有终止符‘\0’，而字符数组没有；<br>2.可以通过指针类型来修改字符数组的元素，但是不能修改字符串中的字符；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家都知道在C语言中是没有&lt;strong&gt;字符串&lt;/strong&gt;这个数据类型的，那我们如何来处理字符串呢？事实上我们是把字符串当成&lt;strong&gt;字符数组&lt;/strong&gt;来处理。&lt;/p&gt;
&lt;p&gt;**字符串的实质是：字符数组+’\0’**，用反斜杠0来表示字符串的结尾。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/"/>
    <id>https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-01T08:11:37.378Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天萌新博主来给大家介绍C语言指针中指针与数组部分，在这一块也是非常难以理解的，闲言少叙，咱们开始吧！</p><p>大家都知道数组与指针有着紧密的联系，数组是由一组若干个元素构成，我们在访问数组的时候，采用的是循环体的方式，就是把数组的下标逐步的循环一次，这样我们就可以读出所有数组元素的值。那么重点来了，<strong>数组下标与地址的之间的关系</strong>，如果我们掌握好，大家学起来指针与数组就会非常的吃力，萌新博主与大家也是感同身受啊！</p><p><strong>【数组的存储方式】</strong><br><img src="https://img-blog.csdnimg.cn/2020022513483051.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>数组的三个特点：<br>1.数组有若干个元素<br>2.元素的数据类型必须相同<br>3.数组中的数据元素是有序排列的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">arr2[<span class="number">4</span>]=&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">//这两个数组不一样</span></span><br></pre></td></tr></table></figure><p>数组元素占用的字节长度都是相等的；<br>指向数组的指针的初始值就是数组的首地址；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每个元素占用的字节长度为：sizeof(int)；</p></blockquote><p>若sizeof(int)&#x3D;&#x3D;2，假设数组的第一个元素a[0]的地址为0x00000001，则数组的第二个元素a[1]的地址为0x00000003，则数组的第三个元素a[2]的地址为0x00000005</p><blockquote><p>所以说数组中的数据元素是有序排列的，那我们在查找数组元素的时候，只需要查找到第一个元素的地址，就能按照顺序找到相应的元素了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[0]=%p\n&quot;</span>,&amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[1]=%p\n&quot;</span>,&amp;arr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[2]=%p\n&quot;</span>,&amp;arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[3]=%p\n&quot;</span>,&amp;arr[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/2020022516132579.png" alt="在这里插入图片描述"><br>那我们再来看指针的性质：<br><strong>【指针与整数的运算】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针加n=指针原来的值+n*<span class="keyword">sizeof</span>(指针所指变量类型)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针减n=指针原来的值-n*<span class="keyword">sizeof</span>(指针所指变量类型)</span><br></pre></td></tr></table></figure><p>int *p&#x3D;NULL<br>p&#x3D;&amp;arr[0]<br>p&#x3D;0x000001<br>p+1&#x3D;0x000001+1×sizeof(int)<br>p+2&#x3D;0x000001+2×sizeof(int)<br>p+3&#x3D;0x000001+3×sizeof(int)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;<span class="comment">//声明一个指针</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">p=&amp;arr[<span class="number">0</span>];<span class="comment">//等价于p=arr;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(int)=%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[0]=%p\n&quot;</span>,&amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[1]=%p\n&quot;</span>,&amp;arr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[2]=%p\n&quot;</span>,&amp;arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[3]=%p\n&quot;</span>,&amp;arr[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p+%d=%p\n&quot;</span>,i,p+i);<span class="comment">//循环输出指针的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>)=<span class="number">4</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">0019F</span>F20</span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">0019F</span>F24</span><br><span class="line">arr[<span class="number">2</span>]=<span class="number">0019F</span>F28</span><br><span class="line">arr[<span class="number">3</span>]=<span class="number">0019F</span>F2C</span><br><span class="line">p+<span class="number">0</span>=<span class="number">0019F</span>F20</span><br><span class="line">p+<span class="number">1</span>=<span class="number">0019F</span>F24</span><br><span class="line">p+<span class="number">2</span>=<span class="number">0019F</span>F28</span><br><span class="line">p+<span class="number">3</span>=<span class="number">0019F</span>F2C</span><br></pre></td></tr></table></figure><p>我们不难发现，我们可以通过<strong>指针来访问一维数组</strong><img src="https://img-blog.csdnimg.cn/20200225192915226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：以上对应关系的成立，指针p必须指向数组元素的首地址。</p><p><strong>【那指针是如何访问数组的呢？】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    p=arr;<span class="comment">//指针指向首地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[i]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+i\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p+%d=%d\n&quot;</span>,i,*(p+i));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200225195221216.png" alt="在这里插入图片描述"><br><strong>【访问指针的四种方法】</strong><br>1.直接下标法<br>有一个数组<code>a[i]</code><br><code>int *p=a</code>等价于<code>int *p=&amp;a[0]</code></p><p>2.首地址自加法*(a+i)<br>数组名就是首地址：a等价于p</p><p>3.指针自加法*(p+i)</p><p>4.指针下标法p[i]<br><img src="https://img-blog.csdnimg.cn/20200226083020614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>通过指针可以修改数组元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">8</span>]=&#123;省略&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">8</span>]=&#123;省略&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p1=arr1;<span class="comment">//使指针p指向arr的首地址</span></span><br><span class="line"><span class="type">int</span> *p2=arr2;</span><br><span class="line">p1=p2;<span class="comment">//改变指针指向</span></span><br><span class="line">p++;<span class="comment">//让指针指向下一个元素</span></span><br></pre></td></tr></table></figure><p>注意：指针可以自加，但是数组名不可以自加，如<code>arr1++</code>，同时数组名也不能相互赋值，如<code>arr1=arr2</code>;</p><p><strong>【用数组访问与用指针访问的区别】</strong><br>1.访问方式不同</p><blockquote><p>使用数组名访问时直接访问，使用指针是间接访问;<br>下标从0开始的原因：因为下标的实质是地址偏移量</p></blockquote><p>2.占用空间不同</p><blockquote><p>系统为arr分配了“sizeof(类型)*元素个数”个字节，给指针分配了“sizeof(类型)”个字节</p></blockquote><p>换句话说<strong>使用指针可以降低空间复杂度</strong>，我们来看个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    p=arr;<span class="comment">//指针指向首地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr)=%d\n&quot;</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(*p)=%d\n&quot;</span>,<span class="keyword">sizeof</span>(*p));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200226084909874.png" alt="在这里插入图片描述"><br>很明显，系统为arr分配了32个字节，给指针分配了4个字节。</p><p><strong>【让我们来回顾二维数组】</strong><br>二维数组a[i][j]，具有两个下标：<strong>行下标与列下标</strong>。<br>存储方式：<strong>先存储行下标，再存储列下标</strong><br>即先在一个行下标内把a[0]列存满，再存a[1]列的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>],a[<span class="number">0</span>][<span class="number">2</span>],a[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>],a[<span class="number">1</span>][<span class="number">1</span>],a[<span class="number">1</span>][<span class="number">2</span>],a[<span class="number">1</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>【二维数组arr[ ][ ]的首地址有多种表达形式】</strong><br>1.将二维数组看成元素是一维数组的元素<br>2.数组中第0行第0列的地址，&amp;arr[0][0]<br>3.由于二维数组先存储行，所以第一行的第一个元素的地址，即&amp;a[0]也是首地址</p><p>二维数组的元素个数：i×j</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">2</span>][<span class="number">3</span>]=&#123;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)&#125;</span><br><span class="line">arr[<span class="number">2</span>][<span class="number">3</span>]=&#123;arr1[<span class="number">3</span>],arr2[<span class="number">3</span>]&#125;</span><br><span class="line">二维数组的首地址：&amp;arr[<span class="number">0</span>][<span class="number">0</span>]，&amp;arr[<span class="number">0</span>]</span><br><span class="line">二维数组的数组名，不是首地址</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[i][j];</span><br><span class="line"><span class="type">int</span> *p=&amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>此时p指向第一行第一个元素，即arr[0][0]，而列指针是arr[i]，指向第(i+1)列的元素。</p><p>不允许操作：p&#x3D;arr或声明的时候使用int *p&#x3D;arr(arr会指向一整行的地址)</p><p><strong>那我们从a[0][0]跳到a[2][2]，如何操作？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]=%d\t&quot;</span>,i,j,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200226093812224.png" alt="在这里插入图片描述"><br>a[0][0]是第一行第一列的元素 ，p&#x3D;&amp;[0][0]<br>a[2][2]是第三行第三列的元素</p><p>有一个指针p指向二维数组的首地址:&amp;a[0][0]<br>指针的偏移量为：<strong>p+行数×行下标+列下标；</strong></p><p>我们来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]=%d\t&quot;</span>,i,j,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+N*%d+%d\t&quot;</span>,i,j,*(p+<span class="number">3</span>*i+j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+N*i+j\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200226102039477.png" alt="在这里插入图片描述"><br>于是我们得到二维数组的四种表现形式，如下图<br><img src="https://img-blog.csdnimg.cn/20200226102512800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>【二维数组的矩阵转置】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//p指向首地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;转置前：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]==%d\t&quot;</span>,i,j,*(p+<span class="number">3</span>*i+j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;转置后：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]==%d\t&quot;</span>,i,j,*(p+<span class="number">3</span>*i+j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200226105244218.png" alt="在这里插入图片描述"><br>在for循环中，我们只需要把i换成j，j换成i就可以实现矩阵的转置，而不需要中间变量。</p><p><strong>【二维数组形参的形式】</strong><br>另外当我们用数组作为函数的形式参数，我们需要给函数传递<strong>一个数组首地址和一个数组长度</strong></p><p><strong>【将数组和数组长度分别作为形参】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[],<span class="type">int</span> size)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> *arry,<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure><p>我们再来一个例子<br><strong>【在一个升序数组中查找大于3的元素】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printarray</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">p=arr;</span><br><span class="line"><span class="keyword">while</span>(*p&lt;<span class="number">3</span>)<span class="comment">//while循环对指针p进行取值</span></span><br><span class="line">&#123;</span><br><span class="line">p++;<span class="comment">//如果p的值&lt;3,则将地址下移，再继续与3比较</span></span><br><span class="line">&#125;</span><br><span class="line">printarray(p,<span class="number">9</span>-(p-arr));<span class="comment">//经过3次自加后，指针由指向元素1到指向元素4</span></span><br><span class="line"><span class="comment">//那么指针p将以arr[3]为首地址传到函数中,(p-arr)为arr[3]与首地址arr[0]的差值，也就之间的个数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/2020022614202161.png" alt="在这里插入图片描述"><br><strong>【用二维数组形参函数来完成矩阵倒置】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> M,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(p+i*N+j));<span class="comment">//也可以用*p++:输出当前值，地址下移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function2</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> M,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(p+i*N+j));<span class="comment">//*(p+i*N+j)是指针偏移量法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意形参M,N是行列长度，不是下标</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">p=&amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">function1(p,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">function2(p,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200226144400947.png" alt="在这里插入图片描述"><br><strong>二维数组形参的其他形式</strong><br><img src="https://img-blog.csdnimg.cn/20200226145712778.png" alt="在这里插入图片描述"><br><strong>数组首地址表示法</strong><br><img src="https://img-blog.csdnimg.cn/20200226145838474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天萌新博主来给大家介绍C语言指针中指针与数组部分，在这一块也是非常难以理解的，闲言少叙，咱们开始吧！&lt;/p&gt;
&lt;p&gt;大家都知道数组与指针有着紧密的联系，数组是由一组若干个元素构成，我们在访问数组的时候，采用的是循环体的方式，就是把数组的下标逐步的循环一次，这样我们就可以读</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/Kali%202020%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%88%E5%8C%85%E5%90%AB%E9%94%90%E6%8D%B7%EF%BC%89/"/>
    <id>https://suenning.com.cn/2023/02/01/Kali%202020%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%88%E5%8C%85%E5%90%AB%E9%94%90%E6%8D%B7%EF%BC%89/</id>
    <published>2023-02-01T08:11:37.378Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>小萌新相信大家在安装Kali的过程中，尤其在配置网络这一块遇到过各种问题，博主也是一样，亲测整理了一些解决方案供大家参考学习。才疏学浅，但真心想帮助大家解决一些问题！笔芯！</p><p><strong>问题1.网络有线连接失败“设备未托管” 解决办法：</strong><br>可以在命令行中输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/NetworkManager/NetworkManager.conf</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200915000632866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>将managed&#x3D;false改成true，重启网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service networking restart//重启网络命令</span><br></pre></td></tr></table></figure><p><strong>问题2.虚拟机中没有eth0解决方法：</strong></p><p>1.首先启动eth0，在命令行中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth0 up</span><br></pre></td></tr></table></figure><p>2.之后在&#x2F;etc&#x2F;network&#x2F;interfaces文件中加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iface eth0 inet dhcp(或是静态static)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200915123901926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3.最后重启网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service networking restart </span><br></pre></td></tr></table></figure><p>4.查看ifconfig，可以发现添加eth0成功<br><img src="https://img-blog.csdnimg.cn/20200915124011152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>问题3.使用NAT模式配置网络</strong><br>（1）在虚拟机中打开设置，选择Kali的连接方式为NAT模式<br><img src="https://img-blog.csdnimg.cn/20200915001535427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）在编辑中选择虚拟网络编辑器，查看NAT模式下所属的网段，如我自己的虚拟机在NAT下的网段为192.168.220.0，网关为192.168.220.2<br><img src="https://img-blog.csdnimg.cn/202009150018261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200915162705966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>如果使用校园网锐捷认证，注意：VMware NAT Service这个服务要开启！至于为什么后面会详细叙述！</strong><br><img src="https://img-blog.csdnimg.cn/20200915123353892.png#pic_center" alt="在这里插入图片描述"><br>（3）在命令行中输入<code>vim /etc/network/interfaces</code>修改静态网络的IP信息，保持与NAT在同一网段，如我设置的IP地址为192.168.220.20，最后注意保存</p><blockquote><p>注意：如果这个文件打不开可能是因为权限不够，可以使用chmod命令更改文件权限</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200915003004882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）配置DNS<br>在命令行中输入<code>vim /etc/resolv.conf</code></p><blockquote><p>注意：如果这个文件打不开可能是因为权限不够，可以使用chmod命令更改文件权限</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200915013325287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>114.114.114.114和8.8.8.8，这两个IP地址都属于公共域名解析服务DNS其中的一部分，而且由于不是用于商业用途的，这两个DNS都很纯净，不用担心因ISP运营商导致的DNS劫持等问题，而且都是免费提供给用户使用的。</p></blockquote><blockquote><p>114.114.114.114是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS；<br>8.8.8.8是Google公司提供的DNS，该地址是全球通用的，相对来说，更适合国外以及访问国外网站的用户使用；</p></blockquote><p>（5）选择桌面右下角网络小图标，右击编辑连接<br><img src="https://img-blog.csdnimg.cn/20200915124910195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）选择设置配置eth0</p><p><img src="https://img-blog.csdnimg.cn/20200915124948887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）手动添加网络地址，添加与在文件&#x2F;etc&#x2F;network&#x2F;interfaces中保持相同IP地址</p><p><img src="https://img-blog.csdnimg.cn/20200915125018790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>查看网络连接信息<br><img src="https://img-blog.csdnimg.cn/20200915124910195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200915125106621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（8）重启网络服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/networking restart</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200915123538530.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service networking restart</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200915123618649.png#pic_center" alt="在这里插入图片描述"></p><p>（9）查看虚拟机网络信息<code>sudo ifconfig</code><br><img src="https://img-blog.csdnimg.cn/20200915124716921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200915153443930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>问题4.更换Kali的更新源</strong></p><p>在命令行中输入：<code>vim /etc/apt/sources.list</code><br><img src="https://img-blog.csdnimg.cn/2020091500485628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>添加以下更新源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#中科大</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line"> </span><br><span class="line"><span class="comment">#阿里云</span></span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line"> </span><br><span class="line"><span class="comment">#清华大学</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line"> </span><br><span class="line"><span class="comment">#浙大</span></span><br><span class="line">deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line"> </span><br><span class="line"><span class="comment">#东软大学</span></span><br><span class="line">deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line"> </span><br><span class="line"><span class="comment">#官方源</span></span><br><span class="line">deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line"> </span><br><span class="line">deb http://mirrors.163.com/debian/ jessie main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian/ jessie-updates main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian/ jessie-backports main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ jessie main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ jessie-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ jessie-backports main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200915163446965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>保存后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get update  <span class="comment"># 取回更新的软件包列表信息</span></span><br><span class="line">apt-get upgrade <span class="comment"># 进行一次升级</span></span><br><span class="line">apt-get clean <span class="comment"># 删除已经下载的安装包</span></span><br><span class="line">reboot  <span class="comment">#重启</span></span><br></pre></td></tr></table></figure><p><strong>问题5.锐捷下连接网络！亲测NAT下成功几率不高</strong><br>众所周知毒瘤的锐捷会定时强制关闭NAT服务，导致虚拟机连不上网</p><p> VMware提供的NAT联网功能，利用网络地址转换原理使虚拟机与主机共享一个外网IP地址，从而实现主机与虚拟机同时访问Internet，十分方便。然而如果我们使用了锐捷客户端作为网络认证的工具其多网卡限制措施会每隔固定时间将<strong>Vmware NAT Service</strong>服务关闭，导致虚拟机无法访问外部网络</p><p>1.外部使用桥接模式<br><img src="https://img-blog.csdnimg.cn/20200915152247177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>VMware NAT Service这个服务要开启！锐捷会杀掉VMware NAT Service服务</strong><br><img src="https://img-blog.csdnimg.cn/20200915123353892.png#pic_center" alt="在这里插入图片描述"><br>至于如果暴力杀锐捷，可以参考<a href="https://www.cnblogs.com/qswg/p/9805831.html">https://www.cnblogs.com/qswg/p/9805831.html</a></p><p>2.内部使用NAT模式（配置静态IP地址）<br><img src="https://img-blog.csdnimg.cn/202009150018261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在命令行中输入 <code>vim /etc/network/interfaces</code>修改静态网络的IP信息，保持与NAT在同一网段，同上NAT配置网络一样<br><img src="https://img-blog.csdnimg.cn/20200915003004882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3.手动配置网络<br><img src="https://img-blog.csdnimg.cn/20200915154023546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>4.查看连接信息<br><img src="https://img-blog.csdnimg.cn/20200915153949578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>5.重启网络服务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/networking restart</span><br></pre></td></tr></table></figure><p><strong>6.外言</strong><br>锐捷客户端会大概每37秒关闭<strong>VMware NAT Service，</strong> 因此如果我们在它关闭之后的极短时间里重新开启该服务，则可以继续使用网络。<br>我们可以使用一个批处理程序，具体如何解决锐捷客户端与NAT的冲突，可参考文件<a href="https://jingyan.baidu.com/article/6fb756ec900e1f241958fb51.html">https://jingyan.baidu.com/article/6fb756ec900e1f241958fb51.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//.bat文件</span><br><span class="line">@echo off</span><br><span class="line">:s</span><br><span class="line">ping -n 1 127.1&gt;null</span><br><span class="line">net start|findstr /i /c:&quot;VMware NAT Service&quot;&gt;nul&amp;&amp;set k=1||set k=0</span><br><span class="line">if %k%==0 (net start &quot;VMware NAT Service&quot;) </span><br><span class="line">goto s</span><br></pre></td></tr></table></figure><p><strong>问题6.有时候Kali中ping不通外网</strong><br><img src="https://img-blog.csdnimg.cn/20200915154752800.png#pic_center" alt="在这里插入图片描述"><br>如果添加了DNS还是无法ping外网，<br>原因一可能是VMware NAT Service服务关闭，如果不是，那就要查看路由中的网关设置 </p><p>使用命令：<code>netstat -rn</code><br><img src="https://img-blog.csdnimg.cn/20200915154231932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>若网关没有设置则需要添加路由网关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add  <span class="keyword">default</span> gw <span class="number">192.168</span><span class="number">.220</span><span class="number">.2</span>（我的路由网关）</span><br></pre></td></tr></table></figure><p>再次查看<code>netstat -rn</code>ping一下百度，发现连接成功<br><img src="https://img-blog.csdnimg.cn/20200915155019983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>最后，希望自己整理的一些配置网络过程中遇到的问题可以为大家提供必要的参考。Kali 是一个安全工具，对于一个专业用户来说，它是一个极好的工具。如果你是一个网络管理员，想对你的网络做一个真实的测试，Kali 可以做到你所希望的一切事情。Kali 也有一些优秀的开发工具，用于去实时审计它们的应用程序。当然，如果你正好有兴趣学习关于安全的知识，你可以在某些受控环境中去使用 Kali，它可以教你学习很多的非常优秀的知识。总之，对于专业用户来说，它有难以置信的好处，但是对于一些不怀好意的人来说，也可以产生很多大麻烦，加油！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小萌新相信大家在安装Kali的过程中，尤其在配置网络这一块遇到过各种问题，博主也是一样，亲测整理了一些解决方案供大家参考学习。才疏学浅，但真心想帮助大家解决一些问题！笔芯！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题1.网络有线连接失败“设备未托管” 解决办法：&lt;/strong&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <id>https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0/</id>
    <published>2023-02-01T08:11:37.363Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>【指针能否作为函数的形式参数？】</strong><br>其实指针是可以作为函数的形式参数的，我们使用指针形参，实际上是<strong>传地址</strong>到函数中（注意，是传地址喔！）<br>●普通的形参，只是将实参的<strong>值</strong>传入函数；<br>●指针形参，将实参的<strong>地址</strong>传入函数；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function1</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span><span class="comment">//形式参数</span></span><br></pre></td></tr></table></figure><p>1.我们注意星号表示这个地方是传进来的是一个指针，要与普通的形式参数区分开；<br>2.函数的执行结果必须是void类型；</p><p><strong>【指针形参的性质】</strong><br>●普通形参不会造成实参的值的改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t=a;</span><br><span class="line">a=b;</span><br><span class="line">b=t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after swap\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\t&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\t&quot;</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num1=<span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> num2=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before swap:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\t&quot;</span>,num1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\t&quot;</span>,num2);</span><br><span class="line"><span class="comment">//调用函数前输出</span></span><br><span class="line">swap(num1,num2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after swap:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\t&quot;</span>,num1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\t&quot;</span>,num2);</span><br><span class="line"><span class="comment">//调用函数后输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before swap：</span><br><span class="line">a=<span class="number">9</span>，b=<span class="number">8</span></span><br><span class="line"></span><br><span class="line">after swap </span><br><span class="line">a=<span class="number">8</span>，b=<span class="number">9</span>；</span><br><span class="line"></span><br><span class="line">after swap： </span><br><span class="line">a=<span class="number">9</span>，b=<span class="number">8</span>；</span><br></pre></td></tr></table></figure><p><strong>●指针形参会造成实参的值的改变</strong></p><blockquote><p>因为指针形参会导致两个变量的地址“搬家”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *pa,<span class="type">int</span> *pb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t=*pa;</span><br><span class="line">*pa=*pb;</span><br><span class="line">*pb=t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after swap\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\t&quot;</span>,*pa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\t&quot;</span>,*pb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num1=<span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> num2=<span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> *pa=&amp;num1;<span class="comment">//取地址</span></span><br><span class="line"><span class="type">int</span> *pb=&amp;num2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before swap:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\t&quot;</span>,*pa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\t&quot;</span>,*pb);</span><br><span class="line"><span class="comment">//调用函数前输出</span></span><br><span class="line">swap(pa,pb);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after swap:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\t&quot;</span>,*pa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\t&quot;</span>,*pb);</span><br><span class="line"><span class="comment">//调用函数后输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before swap：</span><br><span class="line">a=<span class="number">9</span>，b=<span class="number">8</span></span><br><span class="line"></span><br><span class="line">after swap </span><br><span class="line">a=<span class="number">8</span>，b=<span class="number">9</span>；</span><br><span class="line"></span><br><span class="line">after swap： </span><br><span class="line">a=<span class="number">8</span>，b=<span class="number">9</span>；</span><br></pre></td></tr></table></figure><p><strong>【定义指针形参的函数一般需要以下步骤】</strong></p><blockquote><p>1.定义一个含有指针变量的函数<br>2.在主函数定义一个指针变量<br>3.以这个指针变量作为实参调用函数</p></blockquote><p><strong>指针函数指的是：返回值是一个指针的函数</strong></p><p>声明：数据类型  *函数名</p><p>我们来看个例子，使用指针函数求最大值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">max</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> *c)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *flag=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(*a&gt;*b)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*a&gt;*c)</span><br><span class="line">   &#123;</span><br><span class="line">   flag=a;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">  flag=c;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(*b&gt;*c)</span><br><span class="line">  &#123;</span><br><span class="line">  flag=b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  flag=c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num1=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num2=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num3=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input num1:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input num2:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input num3:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num3);</span><br><span class="line"></span><br><span class="line">p=max(&amp;num1,&amp;num2,&amp;num3);<span class="comment">//三个变量的地址传给函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the max:%d\n&quot;</span>,*p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以尝试运行一下！</p><p><strong>【指向函数的指针】</strong><br>C语言的函数也是由内存空间来存放的。<br>如果有一个函数声明为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function1</span><span class="params">(<span class="type">int</span> t1,<span class="type">int</span> t2)</span></span><br></pre></td></tr></table></figure><p>则可以声明一个指针来指向这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  (*fp)function1(<span class="type">int</span> t1,<span class="type">int</span> t2)</span><br></pre></td></tr></table></figure><p>而在<code>int  (*fp)function1(int t1,float t2)</code>中，有一个形参和函数指针类型不符，所以这个函数声明是错误的，注意：<strong>函数类型和函数形参都必须和函数指针类型完全相同。</strong></p><p><strong>【函数指针的赋值】</strong></p><blockquote><p>先得到函数地址，再带上参数列表</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fp)function1(<span class="type">int</span> t1,<span class="type">int</span> t2)</span><br><span class="line"><span class="comment">//此处省略函数模块</span></span><br><span class="line"></span><br><span class="line">fp(<span class="number">5</span>,<span class="number">6</span>)<span class="comment">//直接取地址调用</span></span><br><span class="line">（*fp）(<span class="number">5</span>,<span class="number">6</span>)<span class="comment">//取函数值进行调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：函数值就等于函数的地址</span></span><br></pre></td></tr></table></figure><p><strong>【通过函数指针调用求和函数】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//声明一个普通函数（普通形参）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;<span class="comment">//求和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span> a,<span class="type">int</span> b);</span><br><span class="line">fp=add;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3+4=%d\n&quot;</span>,fp(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3+4=%d\n&quot;</span>,(*fp)(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200225132023179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后注意一点：<br><strong>【void指针表示：无类型指针】</strong><br>●可以使用void指向任何类型；<br>●不能对void指针做加减运算；<br>●不能对void指针进行取值操作；<br>●void指针一般用来做函数的形参；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;【指针能否作为函数的形式参数？】&lt;/strong&gt;&lt;br&gt;其实指针是可以作为函数的形式参数的，我们使用指针形参，实际上是&lt;strong&gt;传地址&lt;/strong&gt;到函数中（注意，是传地址喔！）&lt;br&gt;●普通的形参，只是将实参的&lt;strong&gt;值&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2023-02-01T08:11:37.363Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>【我们为什么要使用结构体？】</strong><br>假如我们要设计一个员工管理系统，一共有100名员工，我们需要记录每一个员工的姓名，性别，职位，地址，电话号码等相关信息，如果我们逐一去申请变量，那么我们需要用到600个变量，显然不好操作；那我们如果定义数组，显然也是不可采取的，因为定义每一个员工中需要用到数据的类型都各不相同。那我们怎么办呢？</p><p>为了方便处理数据，结构体就是把一些相关的，类型不同的子项数据结合在一起，结构体实际上是一种自定义的数据类型，可以包含若干个数据类型相同或者不同的数据项。<br>简单的来说，<strong>结构体可以将多个单一的数据结合在一起，方便处理数据</strong></p><p><strong>【定义结构体】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  结构体名 &#123;</span> </span><br><span class="line"></span><br><span class="line">数据类型  结构体成员;</span><br><span class="line"></span><br><span class="line"> &#125; 结构体变量名(可选);</span><br></pre></td></tr></table></figure><p>来个例子吧！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person_info</span>&#123;</span><span class="comment">//描述人的信息，struct一定不能丢</span></span><br><span class="line"><span class="type">char</span> name[];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> add[];</span><br><span class="line">...</span><br><span class="line">&#125;Rual,Kobe;<span class="comment">//可以定义结构体变量，也可以不定义</span></span><br></pre></td></tr></table></figure><p>结构体的成员可以是人员类型，也可以包括其他结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person_infor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> job[];</span><br><span class="line"><span class="type">char</span> add[];</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> phone;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">time</span>;</span><span class="comment">//结构体的成员可以是其他结构体，但是必须提前定义好</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以根据结构体来定义结构体变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person_info</span>&#123;</span></span><br><span class="line"><span class="type">char</span> name[];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> add[];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">employee_infor</span> <span class="title">Kobe</span>;</span><span class="comment">//定义变量Kobe</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">employee_infor</span> <span class="title">Gasol</span>;</span><span class="comment">//定义变量Gasol</span></span><br></pre></td></tr></table></figure><p><strong>注意：<br>1.我们在定义结构体与结构体变量时，struct一定不能丢，函数体必须在函数体外定义，也可以把结构体定义在头文件中，然后在程序中用#include包含。<br>2.定义结构体必须在函数体外，使用结构体的时候必须在函数体外。</strong></p><p>来个例子吧！估计大家又听不懂了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pe_info</span>//定义结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>];<span class="comment">//切记不要初始化变量</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> add[<span class="number">100</span>];</span><br><span class="line">&#125;;<span class="comment">//注意;表示定义结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pe_info Kobe;这样定义变量是错误的</span></span><br><span class="line"><span class="comment">//pe_info Gasol;这样定义变量是错误的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pe_info</span> <span class="title">Kobe</span>=</span>&#123;<span class="string">&quot;Kobe&quot;</span>,<span class="number">37</span>,<span class="string">&quot;Lakers&quot;</span>&#125;;<span class="comment">//赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pe_info</span> <span class="title">Gasol</span>=</span>&#123;<span class="string">&quot;Gasol&quot;</span>,<span class="number">35</span>,<span class="string">&quot;bull&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//加上struct是为了区分普通变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问Kobe的姓名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Kobe lst mem %s\n&quot;</span>,Kobe.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Gasol lst mem %s\n&quot;</span>,Gasol.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200227203301304.png" alt="在这里插入图片描述"><br><strong>如何访问结构体的成员？</strong><br><strong>形式：结构体变量名.成员</strong></p><p>我们在<strong>初始化结构体变量</strong>的时候，也可以用<code>typedef</code>，去简化结构体变量名。<br>我们来看一段代码：<br>我们用<code>pinf</code>来简化<code>struct pe_info</code>；与上面代码的效果是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pe_info</span>//定义结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>];<span class="comment">//切记不要初始化变量</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> add[<span class="number">100</span>];</span><br><span class="line">&#125;pinf;<span class="comment">//注意;表示定义结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pe_info Kobe;这样定义变量是错误的</span></span><br><span class="line"><span class="comment">//pe_info Gasol;这样定义变量是错误的</span></span><br><span class="line">pinf Kobe=&#123;<span class="string">&quot;Kobe&quot;</span>,<span class="number">37</span>,<span class="string">&quot;Lakers&quot;</span>&#125;;<span class="comment">//赋值</span></span><br><span class="line">pinf Gasol=&#123;<span class="string">&quot;Gasol&quot;</span>,<span class="number">35</span>,<span class="string">&quot;bull&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//加上struct是为了区分普通变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问Kobe的姓名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Kobe lst mem %s\n&quot;</span>,Kobe.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Gasol lst mem %s\n&quot;</span>,Gasol.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200227210500228.png" alt="在这里插入图片描述"><br>我们再来个例子：给结构体赋值并输出结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pe_info</span>//定义结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>];<span class="comment">//切记不要初始化变量</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> add[<span class="number">100</span>];</span><br><span class="line">&#125;pinf;<span class="comment">//注意;表示定义结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pe_info Kobe;这样定义变量是错误的</span></span><br><span class="line"><span class="comment">//pe_info Gasol;这样定义变量是错误的</span></span><br><span class="line">pinf Kobe=&#123;<span class="string">&quot;Kobe&quot;</span>,<span class="number">37</span>,<span class="string">&quot;Lakers&quot;</span>&#125;;<span class="comment">//赋值</span></span><br><span class="line">pinf Gasol=&#123;<span class="string">&quot;Gasol&quot;</span>,<span class="number">35</span>,<span class="string">&quot;bull&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//加上struct是为了区分普通变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问Kobe的姓名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Kobe lst mem %s\n&quot;</span>,Kobe.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Kobe 2st mem %d\n&quot;</span>,Kobe.age);<span class="comment">//注意年龄是int整型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Kobe 3st mem %s\n&quot;</span>,Kobe.add);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Gasol lst mem %s\n&quot;</span>,Gasol.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Gasol 2st mem %d\n&quot;</span>,Gasol.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;struct pe_for Gasol 3st mem %s\n&quot;</span>,Gasol.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200227211538294.png" alt="在这里插入图片描述"><br><strong>那么结构体在内存中是怎么处理的呢？</strong><br>我们看下面的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date_typ</span>&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line">&#125;tt;</span><br></pre></td></tr></table></figure><blockquote><p>int a————4个字节<br>char b———1个字节<br>double c——16个字节</p></blockquote><p>所以<strong>结构体总长度</strong>为4+1+16&#x3D;21字节；</p><p><strong>【结构体数组】</strong><br>结构体数组和基本数组定义方法相同</p><blockquote><p>先定义结构体，再声明结构体数组</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pe_infor</span>&#123;</span></span><br><span class="line"><span class="type">char</span> name[SIZE];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> team[SIZE];</span><br><span class="line">&#125;pe_info;</span><br><span class="line"></span><br><span class="line">pe_info pers[<span class="number">30</span>];<span class="comment">//声明一个数组，包含30个元素</span></span><br></pre></td></tr></table></figure><p>我们用结构体数组来写个程序：输入5个同学的学号，姓名和成绩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu_info</span>//定义结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;s_inf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">s_inf stu[<span class="number">5</span>];<span class="comment">//定义一个长度为5的结构体数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//循环输入学生信息</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input %d stu_name:&quot;</span>,i+<span class="number">1</span>);<span class="comment">//姓名</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;stu[i].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input %d stu_id:&quot;</span>,i+<span class="number">1</span>);<span class="comment">//学号</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu[i].id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input %d stu_score:&quot;</span>,i+<span class="number">1</span>);<span class="comment">//分数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu[i].score);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200227231108313.png" alt="在这里插入图片描述"><br><strong>【指向结构体的指针】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pe_infor</span>&#123;</span></span><br><span class="line"><span class="type">char</span> name[SIZE];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> team[SIZE];</span><br><span class="line">&#125;pe_info;</span><br><span class="line"></span><br><span class="line">pe_info *p;<span class="comment">//赋值</span></span><br><span class="line">p=&amp;pe_info;</span><br></pre></td></tr></table></figure><p>结构体指针一般用<code>-&gt;</code>符号来引用变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pe_info *p=<span class="literal">NULL</span>;<span class="comment">//定义结构体类型的指针，分别引用结构体成员</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;name;等价于(*p).name;</span><br><span class="line">p-&gt;age;等价于(*p).age;</span><br><span class="line">p-&gt;team;等价于(*p).team;</span><br><span class="line"><span class="comment">//指向结构体的指针p-&gt;结构体成员</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;【我们为什么要使用结构体？】&lt;/strong&gt;&lt;br&gt;假如我们要设计一个员工管理系统，一共有100名员工，我们需要记录每一个员工的姓名，性别，职位，地址，电话号码等相关信息，如果我们逐一去申请变量，那么我们需要用到600个变量，显然不好操作；那我们如果定义数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    <id>https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-01T08:11:37.363Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们把数据类型分为<strong>基本数据类型</strong>与<strong>高级数据类型</strong>，基本数据类型中有：整数，浮点数，字符，指针，数组（已经定义好的），而高级数据类型：像结构体，共用体，枚举等。</p><p><strong>链表与数组</strong><br>相同点：<br>链表与数组都是<strong>按顺序存储若干个相同数据类型或相同成员的结构体</strong><br>不同点：<br>●数组各个元素的空间必须连续，而链表各个元素的空间不一定连续，可以分散存储在内存中。<br>●查找数组元素，只需要给出下标，而查找链表元素，需要根据链表的首结点记录地址，顺序查找下去；<br>●删除数组一个非尾部的元素，就要将后面的元素依次向前移动，以保证数组空间的连续性，而删除链表中的一个节点，只需要修改删除节点前后的指针。</p><p><strong>【链表的好处】</strong><br>●不需要预先分配存储空间；<br>●分配的空间可以根据程序的需要扩大和缩小；<br>●如果数据的数量不确定，或者经常变化，就要优先考虑使用链表；<br>●节约内存空间；</p><p><strong>如果元素个数确定，优先使用数组，如果元素个数不确定，优先使用链表</strong></p><p><strong>【链表的存储结构】</strong><br>链表的节点不仅包括元素值，也包括下一个元素的地址（数据域，指针域），即（元素，地址）<br>举个例子：如果链表包含四个元素，而首地址是1255，则：<br><img src="https://img-blog.csdnimg.cn/20200228122929885.png" alt="在这里插入图片描述"></p><p><strong>结点的表示：元素值与下一个元素的地址</strong></p><p>如上图：地址1255是结点自身的地址，不是指针域，Link1是数据域，1356是指向下一个结点的地址。</p><p><strong>【链表是一个结构体】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;<span class="comment">//存放数据（数据域）</span></span><br><span class="line">struck LinkNode *next; <span class="comment">//存放下一个结点的地址（指针域）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">head</span>;</span><span class="comment">//*head是为了存放链表的首地址，必须声明表头指针</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200228130330685.png" alt="在这里插入图片描述"><br><strong>同数组一样，链表名称即为首地址，不过链表是个指针类型的结构体变量</strong></p><p>来个例子：用链表存放三个学生的信息<br><img src="https://img-blog.csdnimg.cn/20200228130643702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>【遍历链表】</strong><br>1.将链表h的各个节点的数据域输出<br>2.从第一个结点开始，只要p非空，就输出这个结点，并将p后移<br><img src="https://img-blog.csdnimg.cn/20200228131957587.png" alt="在这里插入图片描述"><br>我们为什么要把<code>struct Link *h</code>（头结点）作为函数的参数，因为我们在遍历链表的时候的顺序是从头到尾的，然后我们再将<strong>游标指针</strong>指向<strong>头结点</strong><code>struct Link *p=h;</code></p><p><strong>【声明链表】</strong><br><img src="https://img-blog.csdnimg.cn/20200228140102480.png" alt="在这里插入图片描述"><br>我们用head&#x3D;NULL;或是用 !head，判断链表为空；用p&#x3D;p-&gt;next；&#x2F;&#x2F;把下一个地址的值赋给本身</p><p><strong>【链表的插入操作】</strong><br><strong>当将一个值为x的结点s插入链表中，我们先用malloc函数动态申请内存，再赋值给s，s是插入点的指针；</strong><br><img src="https://img-blog.csdnimg.cn/20200228141211832.png" alt="在这里插入图片描述"><br><strong>【插入到链表的头部】</strong><br><img src="https://img-blog.csdnimg.cn/20200228141515994.png" alt="在这里插入图片描述"><br>如图：头指针*head为1255，当把链表插入到头部后，我们的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=head;<span class="comment">//将s的下一个结点指向head</span></span><br><span class="line">head=s;<span class="comment">//首结点赋值为s的值</span></span><br><span class="line"><span class="comment">//head总是表示头结点，当插入链表后，s变为头结点，所以我们要将s的值还给head</span></span><br></pre></td></tr></table></figure><p><strong>【插入到链表的中部】</strong><br><img src="https://img-blog.csdnimg.cn/20200228142700304.png" alt="在这里插入图片描述"><br>假如有一个指针p，p原先保存的地址是1356，而p-&gt;next是1475，但我们当将一个值为x的结点s插入链表中，如图：<br><img src="https://img-blog.csdnimg.cn/20200228142939676.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;<span class="comment">//s指针域指向原先p的指针域</span></span><br><span class="line">p-&gt;next=s;<span class="comment">//插入后，p的指针域指向s</span></span><br></pre></td></tr></table></figure><p><strong>【插入到链表的尾部】</strong><br>如何把一个链表插入非空链表尾部？<br><img src="https://img-blog.csdnimg.cn/2020022814325995.png" alt="在这里插入图片描述"><br>我们先要判断尾部！<br>直到p-&gt;next（指针域）为空值时，则到了链表的尾部，这是我们再将链表插入非空链表尾部。<br><img src="https://img-blog.csdnimg.cn/20200228144126133.png" alt="在这里插入图片描述"><br>具体实现：<br><img src="https://img-blog.csdnimg.cn/20200228144437894.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=p-&gt;next;<span class="comment">//如果p不是尾结点就往后移动</span></span><br><span class="line">p-&gt;next=s;<span class="comment">//最后让p的next结点指向p</span></span><br></pre></td></tr></table></figure><p><strong>【删除链表的结点】</strong><br><strong>1.【删除表头结点，直接更改头指针head】</strong><br><img src="https://img-blog.csdnimg.cn/20200228145054519.png" alt="在这里插入图片描述"><br>原head是头结点，地址是1255，指针域是1356，当我们删除第一个链表时，现在的head的地址变成1356，指针域是1475。即<code>head=head-&gt;next;</code></p><p><strong>2.【删除非表头结点】</strong><br><img src="https://img-blog.csdnimg.cn/20200228145538777.png" alt="在这里插入图片描述"><br>删除前，假设指针p的地址是1475，<strong>pre(p的前驱结点)-&gt;next等价于p，也就是地址1475</strong>，而p-&gt;next&#x3D;&#x3D;1008，当我们删除p的时候，于是<strong>pre(p的前驱结点)-&gt;next</strong>，从指向地址1475变为指向地址1008，即<code>（pre-&gt;next=p-&gt;next)</code>，这时指针p变成野指针，应该释放掉。</p><p><strong>【尾插法操作】</strong><br><img src="https://img-blog.csdnimg.cn/20200228150509569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//注意分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="keyword">struct</span> link *<span class="title function_">creat_link</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">h</span>=</span><span class="literal">NULL</span>;<span class="comment">//声明头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">s</span>;</span><span class="comment">//声明插入结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">r</span>;</span><span class="comment">//声明尾结点</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">s=(<span class="keyword">struct</span> link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> link));<span class="comment">//对s进行动态内存分配</span></span><br><span class="line">s-&gt;data=arr[i];<span class="comment">//数据域来自数组</span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾插法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是不是空链表</span></span><br><span class="line"><span class="keyword">if</span>(h==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">h=s;<span class="comment">//将h赋上插入点的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r-&gt;next=s;<span class="comment">//不是空链表，将尾指针赋上空链表的值</span></span><br><span class="line">&#125;</span><br><span class="line">r=s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> link *h)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">p</span>=</span>h;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">head</span>;</span></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=(<span class="type">int</span>)(rand()%<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">head=creat_link(arr,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr values:&quot;</span>\n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);<span class="comment">//输出数组的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输出链表的值:\n&quot;</span>);</span><br><span class="line">output(head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>【头插法操作】</strong><br><img src="https://img-blog.csdnimg.cn/20200228154417407.png" alt="在这里插入图片描述"><br><strong>【共用体】</strong><br>●使用共用体，使多个变量共享一块内存<br>●目地是为了节约内存空间</p><p><strong>【共用体声明】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">成员列表....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//共用体使用字节最长的成员所占的内存空间</span></span><br></pre></td></tr></table></figure><p><strong>注意：初始化共用体只能给一个值的序列</strong><br><img src="https://img-blog.csdnimg.cn/20200228154950621.png" alt="在这里插入图片描述"><br>另外共用体中不要包含指针成员，因为共用体的成员值很容易发生改变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们把数据类型分为&lt;strong&gt;基本数据类型&lt;/strong&gt;与&lt;strong&gt;高级数据类型&lt;/strong&gt;，基本数据类型中有：整数，浮点数，字符，指针，数组（已经定义好的），而高级数据类型：像结构体，共用体，枚举等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表与数组&lt;/str</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</id>
    <published>2023-02-01T08:11:37.347Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如果说可以用循环队列解决队列的虚假满的状态，那么什么是虚假满状态？</strong></p><p>假设当前顺序队列分配的最大空间是6，当队尾指针从5下标指向6下标时(6下标实际不存在)，说明此时队列已满，然而依然可以进行出队的操作，顺序队不能像顺序栈那样进行存储再分配扩大数组空间，所以队列的实际可用空间并未占满。</p><p>循环队列就是将顺序队列构造成为一个环状的队列空间，如图：<br><img src="https://img-blog.csdnimg.cn/20200408231920541.png" alt="在这里插入图片描述"></p><p><strong>注意：</strong></p><blockquote><p>此时当指针front&#x3D;指针rear时，无法判断队列空间是满还是空，有两种解决思路：<br>1.另设一个标志位区分队列空间是满还是空；<br>2.少用一个空间，约定以“队列头指针在队列尾指针的下一位置”作为队列满的状态标志。</p></blockquote><p>来吧！举个栗子吧，如图：<br>【情况1】<br><img src="https://img-blog.csdnimg.cn/20200408232244129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>初始化，队头指针front，队尾指针rear都指向0下标；<br>当存入数据元素1后，队尾指针rear从0下标指向1下标；<br>当存入数据元素2后，队尾指针rear从1下标指向2下标；<br>当存入数据元素3后，队尾指针rear从2下标指向3下标；<br>当存入数据元素4后，队尾指针rear从3下标指向4下标；<br>…<br>当存入数据元素8后，队尾指针rear从7下标指向0下标；(队列已满)<br>如何判断队头指针front与队尾指针rear重合时，队列是空还是满呢？我们假如用flag来标记队头指针front与队尾指针rear的重合状态，于是规定当flag&#x3D;0时：队列为空；当flag&#x3D;1时，队列为满。</p><p>【情况2】<br><img src="https://img-blog.csdnimg.cn/20200408233304879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们把7下标的空间空出不存放数据，当数据元素7进为6下标的空间后，队尾指针rear就指向了为7下标的空间(此时7下标空间是空的)，理论上8个空间只用了7个空间，但在逻辑上我们规定此时队列已满。当rear+1后，队头指针front与队尾指针rear重合，说明此时队列空间逻辑已满，我们先将队头指针所指空间的元素出队，队头指针前移指向1下标，此时再将元素进下标为7的空间，队尾指针rear前移(指向0下标)，当rear+1后，队头指针front与队尾指针rear又重合，说明此时队列空间逻辑又已满，依次循环往复，出队—&gt;队头指针front前移——&gt;后面入队——&gt;队尾指针rear前移(判断条件是rear+1后，队头指针front与队尾指针rear是否重合，不重合则可继续入队)。</p><p>但是，计算机是没有环状的存储空间的，依然是以线性存储的方式，那计算机如何判断什么时候队尾指针再次与队头指针重合呢？</p><p><strong>—————OK！那就是：进行模运算—————</strong></p><p>具体模运算是怎么实现的，文字显得苍白无力，还是那句话，把代码跑起来，慢慢体会！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 8<span class="comment">//定义队列初始化存放8个数据元素</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElmeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出顺序队列的结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElmeType *base;<span class="comment">//指针base指向有效的队列空间</span></span><br><span class="line"><span class="type">int</span>      front;<span class="comment">//队头指针</span></span><br><span class="line"><span class="type">int</span>      rear;<span class="comment">//队尾指针指向下一个有效的空间</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;base=(ElmeType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElmeType)*MAXSIZE);<span class="comment">//开辟队列空间</span></span><br><span class="line">assert(Q-&gt;base!=<span class="literal">NULL</span>);<span class="comment">//断言——是否开辟空间成功</span></span><br><span class="line">Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队头指针和队尾指针都指向队列的0下标,此时队列为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue *Q,ElmeType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//数据入队后,队尾指针从当前空间指向下一个有效的空间,此时称队尾指针是伪指针;</span></span><br><span class="line"><span class="comment">//当伪指针所指下标+1后正好等于队列空间容量时,此时我们希望伪指针可以重新指向队头,而不是出界,于是进行模运算;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(Q-&gt;rear+1)%MAXSIZE——若模为0,则伪指针恰好指向队列的最后一个有效空间,我们需要让此时的伪指针重新指向0下标而不是最后一个有效空间;</span></span><br><span class="line"><span class="comment">//(始终都要将队列最后一个有效空间空出)循环开始:</span></span><br><span class="line"><span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)<span class="comment">//若伪指针所指下标+1与队头指针指向相同的下标,此时判断为队列逻辑已满</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//返回,理论上队列保留了队列最后一个有效空间</span></span><br><span class="line">Q-&gt;base[Q-&gt;rear]=x;<span class="comment">//否则队列逻辑不满,继续在队尾指针所指下标进行入队,入队完成后,队尾指针又从当前空间指向下一个有效的空间</span></span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//当逻辑空间满后,模运算实现队尾指针重新指向0下标而不是最后一个有效空间;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示顺序队列元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队列中存放的元素:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=Q-&gt;front;i!=Q-&gt;rear;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Q-&gt;base[i]);<span class="comment">//依次打印队头指针所指下标中的数据到队尾指针所指下标中的数据</span></span><br><span class="line">i=(i+<span class="number">1</span>)%MAXSIZE;<span class="comment">//循环打印,7下标不能打印,重新回到0下标(循环时,队尾下标-队头下标=-1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//出队一个元素,队头指针指向下一个有效的数据元素</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队头队尾指向相同,队列为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">//队头指针循环,模运算实现队头指针重新指向0下标而不是最后一个有效空间;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取队头元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(Queue *Q,ElmeType *v)</span><span class="comment">//指针v带回队头元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要获取队头,前提是队列不空</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队列为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">*v=Q-&gt;base[Q-&gt;front];<span class="comment">//必须在base所指的空间里取元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序队列的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q-&gt;rear - Q-&gt;front);</span><br><span class="line"><span class="comment">//下标0开始存放数据,进队后,队尾指针指向下一个有效的新空间</span></span><br><span class="line"><span class="comment">//队列中元素的个数正好是队尾队头所指的下标之差</span></span><br><span class="line"><span class="comment">//但是当队列逻辑空间满后,再存储数据需要先出队,再进行入队,此时队尾队头所指的下标之差为-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队列置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(Q-&gt;base);<span class="comment">//释放base所指的队列空间</span></span><br><span class="line">Q-&gt;base=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Queue Q;</span><br><span class="line">ElmeType e;<span class="comment">//定义队头元素</span></span><br><span class="line">InitQueue(&amp;Q);<span class="comment">//&amp;Q是传入队列的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将1,2,3,4,5,6,7,8依次入队\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;Q,i);</span><br><span class="line">&#125;</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;进行出队\n&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将元素10入队\n&quot;</span>);</span><br><span class="line">EnQueue(&amp;Q,<span class="number">10</span>);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;进行出队\n&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将元素20入队\n&quot;</span>);</span><br><span class="line">EnQueue(&amp;Q,<span class="number">20</span>);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ClearQueue(&amp;Q);</span><br><span class="line">DestroyQueue(&amp;Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200409130442630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;如果说可以用循环队列解决队列的虚假满的状态，那么什么是虚假满状态？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设当前顺序队列分配的最大空间是6，当队尾指针从5下标指向6下标时(6下标实际不存在)，说明此时队列已满，然而依然可以进行出队的操作，顺序队不能像顺序栈那样进</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E6%A0%88%E9%93%BE/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E6%A0%88%E9%93%BE/</id>
    <published>2023-02-01T08:11:37.347Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>顺序栈是分配一段连续的内存空间，需要两个指针，即指针top与指针base，指针top指向栈顶，指针base指向栈底，而<strong>链栈</strong>每个结点的地址是不连续的，所以只需要一个栈顶指针即可，相比于单链表，<strong>栈链的操作只能在栈顶进行。</strong></p><p>入栈前，旧的栈顶结点是新入栈结点的后继结点，栈顶指针重新指向新入栈的结点；<br>出栈前，新的栈顶结点是即将出栈结点的后继结点，栈顶指针指向出栈结点的后继(即指向新的栈顶结点，把出栈结点释放)；</p><p>空口无凭，纸上的概念都显得苍白无力，让我们把代码开起来，慢慢细品！！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言——如果条件返回错误，则终止程序执行</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的栈链</span></span><br><span class="line"><span class="comment">/*给出结点结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域(指向下一个结点的地址)</span></span><br><span class="line">&#125;ListNode,*pNode;<span class="comment">//定义结点类型,定义结点的指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出链栈结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">pNode top;<span class="comment">//指针top指向栈顶元素</span></span><br><span class="line"><span class="type">size_t</span> size;<span class="comment">//结点的个数</span></span><br><span class="line">&#125;ListStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s-&gt;top=(StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); <span class="comment">//栈顶指针指向新申请的结点  </span></span><br><span class="line">assert(s-&gt;top!=<span class="literal">NULL</span>);<span class="comment">//判断申请空间是否为空</span></span><br><span class="line">s-&gt;top = <span class="literal">NULL</span>;<span class="comment">//栈顶指针初始化</span></span><br><span class="line">s-&gt;size=<span class="number">0</span>;<span class="comment">//栈中元素初始化为0个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链栈是否为空*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmptyStack</span><span class="params">(ListStack *s)</span><span class="comment">//给出链栈的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(ListStack *s, ElemType x)</span><span class="comment">//给出链栈的位置和即将入栈的元素</span></span><br><span class="line">&#123;</span><br><span class="line">StackNode *p=(StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));<span class="comment">//指针p指向申请的新结点</span></span><br><span class="line">assert(p!=<span class="literal">NULL</span>);</span><br><span class="line">p-&gt;data = x;<span class="comment">//入栈的元素保存新结点的数据域</span></span><br><span class="line">    p-&gt;next = s-&gt;top;<span class="comment">//新结点的指针域保存栈顶指针的地址</span></span><br><span class="line">    s-&gt;top = p;<span class="comment">//栈顶指针重新指向新结点</span></span><br><span class="line">s-&gt;size++;<span class="comment">//栈中元素增加</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PopStack</span><span class="params">(ListStack *s, ElemType *v)</span></span><br><span class="line">&#123;</span><br><span class="line">StackNode *p=s-&gt;top;<span class="comment">//指针p指向栈顶</span></span><br><span class="line">*v=s-&gt;top-&gt;data;<span class="comment">//指针v带回栈顶元素</span></span><br><span class="line">s-&gt;top=s-&gt;top-&gt;next;<span class="comment">//栈顶指针指向栈顶结点的后继结点</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放栈顶结点</span></span><br><span class="line">    s-&gt;size--;<span class="comment">//栈中元素减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">StackNode *p=s-&gt;top;<span class="comment">//指针p指向栈顶</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链栈中的数据元素:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//栈不为空,执行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,p-&gt;data);</span><br><span class="line">p = p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取栈顶指针*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTopStack</span><span class="params">(ListStack *s,ElemType *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;top==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*v=s-&gt;top-&gt;data;<span class="comment">//指针v带回栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈长*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LengthStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清空栈链*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">StackNode *p=s-&gt;top;<span class="comment">//指针p指向栈顶结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">s-&gt;top=p-&gt;next;<span class="comment">//栈顶指针指向栈顶结点的后继结点</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放栈顶结点</span></span><br><span class="line">p=s-&gt;top;<span class="comment">//指针p重新指向栈顶结点</span></span><br><span class="line">&#125;</span><br><span class="line">s-&gt;top = <span class="literal">NULL</span>;<span class="comment">//否则栈顶指针置空</span></span><br><span class="line">s-&gt;size = <span class="number">0</span>;<span class="comment">//栈中长度置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁栈链*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">ClearStack(s);</span><br><span class="line"><span class="built_in">free</span>(s-&gt;top);<span class="comment">//销毁最初创建的结点</span></span><br><span class="line">s-&gt;top=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">ListStack  st;</span><br><span class="line">ElemType e;</span><br><span class="line">InitStack(&amp;st);</span><br><span class="line"><span class="keyword">if</span>(IsEmptyStack(&amp;st))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈为空,初始化成功\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈非空!\n\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;入栈\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">PushStack(&amp;st,i);</span><br><span class="line">&#125;</span><br><span class="line">    ShowStack(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> k=LengthStack(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈的长度为:%d \n\n&quot;</span>,k);</span><br><span class="line">GetTopStack(&amp;st,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈顶元素为:%d \n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;出栈\n&quot;</span>);</span><br><span class="line">PopStack(&amp;st,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">ShowStack(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">PopStack(&amp;st,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">ShowStack(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">PopStack(&amp;st,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">ShowStack(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">PopStack(&amp;st,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">ShowStack(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">PopStack(&amp;st,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">ShowStack(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">PopStack(&amp;st,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">ShowStack(&amp;st);</span><br><span class="line">ClearStack(&amp;st);</span><br><span class="line">DestroyStack(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200407203758677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;顺序栈是分配一段连续的内存空间，需要两个指针，即指针top与指针base，指针top指向栈顶，指针base指向栈底，而&lt;strong&gt;链栈&lt;/strong&gt;每个结点的地址是不连续的，所以只需要一个栈顶指针即可，相比于单链表，&lt;strong&gt;栈链的操作只能在栈顶进行。&lt;/st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88/</id>
    <published>2023-02-01T08:11:37.347Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>栈是限定仅在表面进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶，相应地，表头端称为栈底，不含元素的空表称为空栈。</p><p>顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置，通常的习惯做法是以top&#x3D;0表示空栈。</p><p>话不多说，把代码跑起来！！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的顺序栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 8<span class="comment">//初始化顺序栈可以存放8个数据元素</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序栈的结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType *base;<span class="comment">//指针base指向开辟的栈空间</span></span><br><span class="line"><span class="type">int</span> capacity;<span class="comment">//定义顺序栈的容量(最大容量)</span></span><br><span class="line"><span class="type">int</span> top;<span class="comment">//定义栈顶指针(同时表示当前栈中的元素个数)</span></span><br><span class="line">&#125;SeqStack;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SeqStack *s)</span><span class="comment">//给出顺序栈的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//申请顺序栈的空间(元素类型)</span></span><br><span class="line">s-&gt;base=(ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*STACK_INIT_SIZE);</span><br><span class="line">assert(s-&gt;base!=<span class="literal">NULL</span>);<span class="comment">//不为空时空间申请成功</span></span><br><span class="line">s-&gt;capacity=STACK_INIT_SIZE;<span class="comment">//栈的容量为初始化大小</span></span><br><span class="line">s-&gt;top=<span class="number">0</span>;<span class="comment">//栈顶指针top指向0下标的位置,表示此时栈中一个数据元素都没有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(SeqStack *s)</span><span class="comment">//入栈判断栈是否满</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s-&gt;top &gt;= s-&gt;capacity;<span class="comment">//指针top所指的下标正好与栈的容量相等,此时栈已满</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SeqStack *s)</span><span class="comment">//出栈判断栈是否空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s-&gt;top==<span class="number">0</span>;<span class="comment">//指针top所指的下标正好是0下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(SeqStack *s,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(s))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈空间已满,%d不能入栈\n&quot;</span>,x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;base[s-&gt;top]=x;<span class="comment">//当前指针top所指的位置来存放数据,指针base指向真实的栈空间</span></span><br><span class="line">s-&gt;top++;<span class="comment">//指针top指向下一个可用的栈空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈空间已空,不能出栈\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;top--;<span class="comment">//指针top指向上一个可用的栈空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取栈顶元素*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SeqStack *s,ElemType *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈空间已空,不能取栈顶元素\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">*v=s-&gt;base[s-&gt;top<span class="number">-1</span>];<span class="comment">//把栈顶元素存放在元素v的地址里,传回元素v</span></span><br><span class="line"><span class="comment">//因为入栈一个元素后,指针top就指向下一个空的栈空间,所以取栈顶元素,应该读取上一个栈空间里的元素,即用top-1的结果作为base的下标</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示栈中元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=s-&gt;top<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="comment">//因为入栈一个元素后,指针top就指向下一个空的栈空间,所以显示元素时,应该读取上一个栈空间里的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s-&gt;base[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s-&gt;top;<span class="comment">//返回0则为空栈,返回1则栈的长度为1(此时栈中有1个元素)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">s-&gt;top=<span class="number">0</span>;<span class="comment">//栈顶指针指向0下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(s-&gt;base);<span class="comment">//释放栈空间</span></span><br><span class="line">s-&gt;base=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">s-&gt;capacity=s-&gt;top=<span class="number">0</span>;<span class="comment">//栈容量,栈中的数据元素都置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SeqStack st;<span class="comment">//定义一个名为st的顺序栈</span></span><br><span class="line">InitStack(&amp;st);</span><br><span class="line">ElemType  v;<span class="comment">//定义临时元素v</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入栈\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;st,i);<span class="comment">//把1,2,3,4,5依次入栈</span></span><br><span class="line">&#125;</span><br><span class="line">Show(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈的长度为%d\n&quot;</span>,Length(&amp;st));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">GetTop(&amp;st,&amp;v);<span class="comment">//给出临时元素v的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d 是栈顶元素\n&quot;</span>,v);<span class="comment">//临时元素v就是栈顶元素,实现取栈顶元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出栈\n&quot;</span>);</span><br><span class="line">Pop(&amp;st);</span><br><span class="line">Show(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈的长度为%d\n&quot;</span>,Length(&amp;st));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清除栈\n&quot;</span>);</span><br><span class="line">Clear(&amp;st);</span><br><span class="line">Show(&amp;st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;栈的长度为%d\n&quot;</span>,Length(&amp;st));</span><br><span class="line">Destory(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200406205941803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;栈是限定仅在表面进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶，相应地，表头端称为栈底，不含元素的空表称为空栈。&lt;/p&gt;
&lt;p&gt;顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-02-01T08:11:37.331Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一.树的定义</strong><br>从数据结构角度看，树包含n（n≥0）个结点，当n&#x3D;0时，称为空树；非空树的定义如下： T&#x3D;(D，R)<br>其中，D为树中结点的有限集合，关系R满足以下条件：<br>●有且仅有一个结点d0∈D，它对于关系R来说没有前驱结点，结点d0称作树的根结点<br>●除根结点d0外，D中的每个结点有且仅有一个前驱结点，但可以有多个后继结点<br>●D中可以有多个终端结点</p><p>假如我们有一棵树T&#x3D;(D，R)，其中：D&#x3D;{A，B，C，D，E，F，G，H}，R&#x3D;{r}<br>r&#x3D;{&lt;A,B&gt;，&lt;A,C&gt;，&lt;A,D&gt;，&lt;C,E&gt;，&lt;C,F&gt;，&lt;D,G&gt;，&lt;E,H&gt;}，那我们该如何画出其逻辑结构图呢？</p><blockquote><p>解：A是根结点，其余结点分成三个互不相交的子集：　 T1&#x3D;{B}，T2&#x3D;{C，E，F，H}，T3&#x3D;{D，G}； T1、T2、T3都是根结点A的子树，且各自本身也是一棵树</p></blockquote><p>于是我们得到了逻辑结构图，如下：<br><img src="https://img-blog.csdnimg.cn/20200507202539574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说明：树中结点之间的关系应为有向关系，在上图中，结点之间的连线即分支线都是有向的，默认箭头向下的。</p><p><strong>二.树的逻辑结构表示</strong><br>1.树形表示法：使用一棵倒置的树表示树结构，非常直观和形象<br>2.文氏图表示法：使用集合以及集合的包含关系描述树结构，如图：<br><img src="https://img-blog.csdnimg.cn/20200507202810117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.凹入表示法：使用线段的伸缩关系描述树结构<br><img src="https://img-blog.csdnimg.cn/20200507202906278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.括号表示法：将树的根结点写在括号的左边，除根结点之外的其余结点写在括号中并用逗号分隔<br><img src="https://img-blog.csdnimg.cn/20200507203030299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>三.树的基本术语</strong><br>1.什么是结点的度？</p><blockquote><p>树中每个结点具有的子树数或者后继结点数称为该结点的度</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507203857313.png" alt="在这里插入图片描述"><br>2.什么是树的度？</p><blockquote><p>树中所有结点的度的最大值称之为树的度</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507203945890.png" alt="在这里插入图片描述"><br>3.什么是分支结点？</p><blockquote><p>度大于0的结点称为分支结点或非终端结点。 度为1的结点称为单分支结点，度为2的结点称为双分支结点，依次类推…</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204105919.png" alt="在这里插入图片描述"><br>4.什么是叶子节点？</p><blockquote><p>度为零的结点称为叶子结点或终端结点</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204212515.png" alt="在这里插入图片描述"><br>5.什么是孩子结点？</p><blockquote><p>一个结点的后继称之为该结点的孩子结点</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204308413.png" alt="在这里插入图片描述"><br>6.什么是双亲结点？</p><blockquote><p>一个结点称为其后继结点的双亲结点</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204445323.png" alt="在这里插入图片描述"><br>7.什么是子孙结点？</p><blockquote><p>一个结点的子树中除该结点外的所有结点称之为该结点的子孙结点</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204524721.png" alt="在这里插入图片描述"><br>8.什么是祖先结点？</p><blockquote><p>从树根结点到达某个结点的路径上通过的所有结点称为该结点的祖先结点（不含该结点自身）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204619245.png" alt="在这里插入图片描述"><br>9.什么是兄弟结点？</p><blockquote><p>具有同一双亲的结点互相称之为兄弟结点</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204700667.png" alt="在这里插入图片描述"><br>10.什么是结点层次？</p><blockquote><p>树具有一种层次结构，根结点为第一层，其孩子结点为第二层，如此类推得到每个结点的层次</p></blockquote><p><img src="https://img-blog.csdnimg.cn/202005072047591.png" alt="在这里插入图片描述"><br>11.什么是树的高度？</p><blockquote><p>树中结点的最大层次称为树的高度或深度</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204836660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>12.什么是森林？</p><blockquote><p>零棵或多棵互不相交的树的集合称为森林</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200507204918807.png" alt="在这里插入图片描述"><br><strong>四.树的性质</strong><br>性质1：  树中的结点数等于所有结点的度数加1</p><p>性质2：度为m的树中第i层上至多有m^(i-1)个结点，这里应有i≥1</p><blockquote><p>推广：当一棵m次树的第i层有m^(i-1)个结点（i≥1）时，称该层是满的，若一棵m次树的所有叶子结点在同一层，除该层外其余每一层都是满的，称为满m次树。显然，满m次树是所有相同高度的m次树中结点总数最多的树。也可以说，对于n个结点，构造的m次树为满m次树或者接近满m次树，此时树的高度最小。</p></blockquote><p>让我们来道经典例题巩固一下：<br>若一棵三次树中度为3的结点为2个，度为2的结点为1个，度为1的结点为2个，则该三次树中总的结点个数和度为0的结点个数分别是多少？</p><blockquote><p>解：设该三次树中总结点个数、度为0的结点个数、度为1的结点个数、度为2的结点个数和度为3的结点个数分别为n、n0、n1、n2和n3。<br>显然，每个度为i的结点在所有结点的度数之和中贡献i个度。依题意有：n1&#x3D;2，n2&#x3D;1，n3&#x3D;2。<br>由树的性质1可知：n &#x3D; 所有结点的度数之和+1　<br>                                  &#x3D; 0×n0+1×n1+2×n2+3×n3+1<br>                                  &#x3D; 1×2+2×1+3×2+1<br>                                  &#x3D;11 　　<br>又因为n&#x3D;n0+n1+n2+n3 　　<br>即：n0&#x3D;n-n1-n2-n3&#x3D;11-2-1-2&#x3D;6 　　<br>所以该三次树中总的结点个数和度为0的结点个数分别是11和6。</p></blockquote><p><strong>五.二叉树</strong><br><strong>1.二叉树的递归定义</strong><br>二叉树或者是一棵空树，或者是一棵由一个根结点和两棵互不相交的分别称做根结点的左子树和右子树所组成的非空树，左子树和右子树又同样都是一棵二叉树。</p><blockquote><p>注意：二叉树与度为2的树是不同的！<br>度为2的树至少有3个结点，而二叉树的结点数可以为0；<br>度为2的树不区分子树的次序，而二叉树中的每个结点最多有两个孩子结点，且必须要区分左右子树，即使在结点只有一棵子树的情况下也要明确指出该子树是左子树还是右子树</p></blockquote><p><strong>2.二叉树的5种形态</strong><br><img src="https://img-blog.csdnimg.cn/20200507214311919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3.二叉树的性质</strong><br>性质1：非空二叉树上叶结点数等于双分支结点数加1，即n0&#x3D;n2+1<br>（我们约定：二叉树上叶结点数为n0，单分支结点数为n1，双分支结点数为n2）</p><blockquote><p>例如：一棵二叉树中总结点个数为200，其中单分支结点个数为19，求其叶子结点个数。<br>解：n&#x3D;200，n1&#x3D;19。又n&#x3D;n0+n1+n2，由性质1得，n2&#x3D;n0-1，所以有： n&#x3D;2n0-1+n1<br>即n0&#x3D;(n-n1+1)&#x2F;2&#x3D;91，所以这样的二叉树中叶子结点个数为91。</p></blockquote><p>性质2：非空二叉树上第i层上至多有2^(i-1)个结点，这里应有i≥1</p><p>性质3：高度为h的二叉树至多有2^h-1个结点（h≥1）</p><p>性质4：对完全二叉树中编号为i的结点（1≤i≤n，n≥1，n为结点数）有：<br>（1）若i≤|n&#x2F;2|，即2i≤n，则编号为i的结点为分支结点，否则为叶子结点；<br>（2）若n为奇数，则每个分支结点都既有左孩子结点，也有右孩子结点。若n为偶数，则编号最大的分支结点只有左孩子结点，没有右孩子结点，其余分支结点都有左、右孩子结点。<br>（3）若编号为i的结点有左孩子结点，则左孩子结点的编号为2i；若编号为i的结点有右孩子结点，则右孩子结点的编号为(2i+1)。<br>（4）除树根结点外,若一个结点的编号为i，则它的双亲结点的编号为|i&#x2F;2|，也就是说，当i为偶数时，其双亲结点的编号为i&#x2F;2，它是双亲结点的左孩子结点，当i为奇数时，其双亲结点的编号为(i-1)&#x2F;2，它是双亲结点的右孩子结点。</p><p><strong>4.满二叉树</strong><br>在一棵二叉树中，当第i层的结点数为2^(i-1)个时，则称此层的结点数是满的，当一棵二叉树中的每一层都满时，且叶子结点在同一层上，则称此树为满二叉树。<br><img src="https://img-blog.csdnimg.cn/20200507224023729.png" alt="在这里插入图片描述"></p><blockquote><p>满二叉树特性：除叶子结点以外的其他结点的度皆为2。</p></blockquote><p><strong>5.完全二叉树</strong><br>在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干个结点，则称此树为完全二叉树。<br><img src="https://img-blog.csdnimg.cn/20200507224045349.png" alt="在这里插入图片描述"></p><blockquote><p>完全二叉树特性：二叉树中至多只有最下边两层结点的度数小于2。</p></blockquote><p><strong>6.层序编号</strong><br>从根结点为1开始，按照层次从小到大、同一层从左到右的次序顺序编号。如图：<br><img src="https://img-blog.csdnimg.cn/20200507215323561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>六.二叉树的遍历</strong><br>二叉树的遍历运算是<strong>指按一定的次序访问树中的所有结点，使每个结点恰好被访问一次。其中遍历次序保证了二叉树上每个结点均被访问一次且仅有一次。</strong></p><p> <strong>1.先序遍历</strong><br>① 访问根结点<br>② 先序遍历左子树<br>③ 先序遍历右子树</p><p> <strong>2.中序遍历</strong><br>① 中序遍历左子树<br>② 访问根结点<br>③ 中序遍历右子树</p><p> <strong>3.后序遍历</strong><br>① 后序遍历左子树<br>② 后序遍历右子树<br>③ 访问根结点</p><p> <strong>4.层次遍历</strong><br>层次遍历是从根结点出发，按照从上向下，同一层从左向右的次序访问所有的结点，采用层次遍历得到的访问结点序列称为层次遍历序列。<br>层次遍历序列的特点：其第一个元素值为二叉树中根结点值。</p><p><strong>七.二叉树的存储结构</strong><br>1.顺序存储结构<br><img src="https://img-blog.csdnimg.cn/20200507215730437.png" alt="在这里插入图片描述"><br>用一组连续的存储单元存放二叉树中的结点<br><img src="https://img-blog.csdnimg.cn/20200507215745479.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200507215810488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用“#”补齐为一个完整二叉树<br><img src="https://img-blog.csdnimg.cn/20200507215900468.png" alt="在这里插入图片描述"><br>2.二叉链存储结构<br>链表中的<strong>每个结点包含两个指针，分别指向对应结点的左孩子和右孩子</strong>（注意在树的孩子兄弟链表存储结构中，每个结点的两个指针分别指向对应结点的第一个孩子和下一个兄弟）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span></span></span><br><span class="line"><span class="class">&#123;</span>  ElemType data;<span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><p>●data表示数据域，用于存储放入结点值（默认情况下为单个字母）<br>●lchild 和 rchild 分别表示左指针域和右指针域，分别存储左孩子和右孩子结点（即左、右子树的根结点）的存储地址<br>●当某结点不存在左或右孩子时，其 lchild 或 rchild 指针域取特殊值NULL<br><img src="https://img-blog.csdnimg.cn/20200507220212290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>八.二叉树基本运算实现算法</strong><br>采用括号表示法表示的二叉树字符串str，且每个结点的值是单个字符。<br>用ch扫描str，其中只有4类字符，各类字符的处理方式：<br>1.若ch&#x3D;’(‘：<strong>表示前面刚创建的p结点存在着孩子结点，需将其进栈</strong>，以便建立它和其孩子结点的关系。然后开始处理该结点的左孩子，因此置k&#x3D;1，表示其后创建的结点将作为这个结点（栈顶结点）的左孩子结点；</p><p>2.若ch&#x3D;’)’：<strong>表示以栈顶结点为根结点的子树创建完毕</strong>，将其退栈；</p><p>3.若ch&#x3D;’,’：<strong>表示开始处理栈顶结点的右孩子结点</strong>，置k&#x3D;2；</p><p>4.其他情况：只能是单个字符，表示要创建一个新结点p，根据k值建立p结点与栈顶结点之间的联系，当k&#x3D;1时，表示p结点作为栈顶结点的左孩子结点，当k&#x3D;2时，表示p结点作为栈顶结点的右孩子结点。</p><p><strong>（1）创建二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBTree</span><span class="params">(BTNode * &amp;bt,<span class="type">char</span> *str)</span></span><br><span class="line">&#123;  BTNode *St[MaxSize],*p=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="type">int</span> top=<span class="number">-1</span>,k,j=<span class="number">0</span>;</span><br><span class="line">   <span class="type">char</span> ch;</span><br><span class="line">   bt=<span class="literal">NULL</span>;<span class="comment">//建立的二叉树初始时为空</span></span><br><span class="line">   ch=str[j];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span> (ch!=<span class="string">&#x27;\0&#x27;</span>)    <span class="comment">//str未扫描完时循环</span></span><br><span class="line">   &#123;<span class="keyword">switch</span>(ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:top++;St[top]=p;k=<span class="number">1</span>; <span class="keyword">break</span>;    <span class="comment">//为左孩子结点</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:top--;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:k=<span class="number">2</span>; <span class="keyword">break</span>;     <span class="comment">//为右孩子结点</span></span><br><span class="line"><span class="keyword">default</span>:p=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">p-&gt;data=ch;p-&gt;lchild=p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>)     <span class="comment">//p为二叉树的根结点</span></span><br><span class="line">　　bt=p;</span><br><span class="line"><span class="keyword">else</span>     <span class="comment">//已建立二叉树根结点</span></span><br><span class="line">&#123;   <span class="keyword">switch</span>(k) </span><br><span class="line">　　&#123;</span><br><span class="line">　　<span class="keyword">case</span> <span class="number">1</span>:St[top]-&gt;lchild=p;<span class="keyword">break</span>;</span><br><span class="line">　　<span class="keyword">case</span> <span class="number">2</span>:St[top]-&gt;rchild=p;<span class="keyword">break</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      j++;　ch=str[j];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）销毁二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyBTree</span><span class="params">(BTNode *&amp;bt)</span></span><br><span class="line">&#123;   <span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">　　DestroyBTree(bt-&gt;lchild);</span><br><span class="line">DestroyBTree(bt-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(bt);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）求二叉树高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BTHeight</span><span class="params">(BTNode *bt)</span> </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> lchilddep,rchilddep;</span><br><span class="line">    <span class="keyword">if</span> (bt==<span class="literal">NULL</span>) <span class="keyword">return</span>(<span class="number">0</span>);    <span class="comment">//空树的高度为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;  </span><br><span class="line">lchilddep=BTHeight(bt-&gt;lchild);  <span class="comment">//求左子树的高度</span></span><br><span class="line">rchilddep=BTHeight(bt-&gt;rchild);  <span class="comment">//求右子树的高度</span></span><br><span class="line"><span class="keyword">return</span> (lchilddep&gt;rchilddep)? (lchilddep+<span class="number">1</span>):(rchilddep+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）求二叉树结点个数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BTNode *bt)</span><span class="comment">//求二叉树bt的结点个数</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> num1,num2;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>)<span class="comment">//为空树时返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   &#123;   </span><br><span class="line">num1=NodeCount(bt-&gt;lchild);<span class="comment">//求左子树结点个数</span></span><br><span class="line">num2=NodeCount(bt-&gt;rchild);<span class="comment">//求右子树结点个数</span></span><br><span class="line"><span class="keyword">return</span> (num1+num2+<span class="number">1</span>);<span class="comment">//返回和加上1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）求二叉树叶子结点个数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BTNode *bt)</span><span class="comment">//求二叉树bt的叶子结点个数</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> num1,num2;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>)<span class="comment">//空树返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//为叶子结点时返回1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">num1=LeafCount(bt-&gt;lchild);<span class="comment">//求左子树叶子结点个数</span></span><br><span class="line">num2=LeafCount(bt-&gt;rchild); <span class="comment">//求右子树叶子结点个数</span></span><br><span class="line"><span class="keyword">return</span> (num1+num2);<span class="comment">//返回和</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（6）以括号表示法输出二叉树</strong><br>1.对于非空二叉树bt，先输出其元素值；<br>2.当存在左孩子结点或右孩子结点时，输出一个“(”符号；<br>3.递归处理左子树；<br>4.有右子树时输出一个“,”符号；<br>5.递归处理右子树；<br>6.最后输出一个“)”符号；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DispBTree</span><span class="params">(BTNode *bt)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,bt-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (bt-&gt;lchild!=<span class="literal">NULL</span> || bt-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">         &#123; </span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);<span class="comment">//有子树时输出&#x27;(&#x27;</span></span><br><span class="line">　    DispBTree(bt-&gt;lchild);<span class="comment">//递归处理左子树</span></span><br><span class="line">  <span class="keyword">if</span> (bt-&gt;rchild!=<span class="literal">NULL</span>)<span class="comment">//有右子树时输出&#x27;,&#x27;</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">　DispBTree(bt-&gt;rchild);<span class="comment">//递归处理右子树</span></span><br><span class="line">　<span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);<span class="comment">//输出一个&#x27;)&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（7）先序遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">　<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,bt-&gt;data);</span><br><span class="line">PreOrder(bt-&gt;lchild);</span><br><span class="line">PreOrder(bt-&gt;rchild);</span><br><span class="line">　　  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先序遍历序列的特点：其第一个元素值为二叉树中根结点值。</p><p><strong>（8）中序遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">　　InOrder(bt-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,bt-&gt;data);</span><br><span class="line">InOrder(bt-&gt;rchild);</span><br><span class="line">　　  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历序列的特点：若已知二叉树的根结点值，以该值为界，将中序遍历序列分为两部分，前半部分为左子树的中序遍历序列，后半部分为右子树的中序遍历序列。</p><p><strong>（9）后序遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;  </span><br><span class="line"> <span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">　　PostOrder(bt-&gt;lchild);</span><br><span class="line">PostOrder(bt-&gt;rchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,bt-&gt;data);</span><br><span class="line">　    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历序列的特点：最后一个元素值为二叉树中根结点值</p><p><strong>（10）层次遍历</strong><br>层次遍历算法的实现过程：<br>1.先将根结点进队；<br>2.在队不空时循环：从队列中出队一个结点p，访问它；若它有左孩子结点，将左孩子结点进队；若它有右孩子结点，将右孩子结点进队。<br>3.如此操作直到队空为止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;   </span><br><span class="line">BTNode *p;</span><br><span class="line">　　BTNode *qu[MaxSize];<span class="comment">//定义循环队列,存放二叉链结点指针</span></span><br><span class="line">　　<span class="type">int</span> front,rear;<span class="comment">//定义队头和队尾指针</span></span><br><span class="line">　　front=rear=<span class="number">0</span>;<span class="comment">//置队列为空队列</span></span><br><span class="line">　　rear++; </span><br><span class="line">　　qu[rear]=bt;<span class="comment">//根结点指针进入队列</span></span><br><span class="line">　　<span class="keyword">while</span> (front!=rear)<span class="comment">//队列不为空循环</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　front=(front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">p=qu[front];<span class="comment">//出队结点p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,p-&gt;data);<span class="comment">//访问该结点</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>)<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">&#123;   </span><br><span class="line">rear=(rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">　qu[rear]=p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>)<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">&#123;   </span><br><span class="line">rear=(rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">　　qu[rear]=p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（11）二叉树的拷贝</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CopyBTree</span><span class="params">(BTNode *bt,BTNode *&amp;nt)</span></span><br><span class="line"><span class="comment">//由二叉树bt复制产生二叉树nt</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　　&#123;</span><br><span class="line">　　nt=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));<span class="comment">//复制根结点</span></span><br><span class="line">nt-&gt;data=bt-&gt;data;</span><br><span class="line">CopyBTree(bt-&gt;lchild,nt-&gt;lchild);<span class="comment">//递归复制左子树</span></span><br><span class="line">CopyBTree(bt-&gt;rchild,nt-&gt;rchild);<span class="comment">//递归复制左子树</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">else</span> nt=<span class="literal">NULL</span>;<span class="comment">//bt为空树时nt也为空树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一.树的定义&lt;/strong&gt;&lt;br&gt;从数据结构角度看，树包含n（n≥0）个结点，当n&amp;#x3D;0时，称为空树；非空树的定义如下： T&amp;#x3D;(D，R)&lt;br&gt;其中，D为树中结点的有限集合，关系R满足以下条件：&lt;br&gt;●有且仅有一个结点d0∈D，它对于</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-01T08:11:37.331Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p> 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储，即通过数据元素物理存储的连续性来反应元素之间逻辑上的相邻关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言————如果条件返回错误，则终止程序执行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQLIST_INT_SIZE 8<span class="comment">//初始化顺序表大小为存放8个元素</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出顺序表结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType *base;<span class="comment">//指针base指向一个真实开辟的顺序表空间</span></span><br><span class="line"><span class="type">int</span> capacity;<span class="comment">//顺序表的空间容量大小</span></span><br><span class="line"><span class="type">int</span> size;<span class="comment">//顺序表中的实际存放元素的个数(顺序表的长度)</span></span><br><span class="line">&#125;SeqList;<span class="comment">//SeqList为结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeqList</span><span class="params">(SeqList *<span class="built_in">list</span>)</span><span class="comment">//给出顺序表的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;base=(ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*SEQLIST_INT_SIZE);<span class="comment">//为顺序表开辟空间，指针base指向开辟的空间</span></span><br><span class="line">assert(<span class="built_in">list</span>-&gt;base !=<span class="literal">NULL</span>);<span class="comment">//判断空间是否开辟成功</span></span><br><span class="line"><span class="built_in">list</span>-&gt;capacity=SEQLIST_INT_SIZE;<span class="comment">//初始化顺序表的容量大小(可以存放8个元素)</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//定义顺序表的实际存放元素的个数为0(此时size是当前数组下标为0的地址)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾部插入*/</span></span><br><span class="line"><span class="comment">//先判断空间是否已满</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span><span class="comment">//给出顺序表的位置和要插入的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size  &gt;=  <span class="built_in">list</span>-&gt;capacity)<span class="comment">//顺序表的实际存放元素的个数大于等于顺序表的开辟容量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表空间已满\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;base[<span class="built_in">list</span>-&gt;size]=x;<span class="comment">//插入元素的位置是当前size指向的位置(即当前下标的位置)</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size++;<span class="comment">//插入元素后，顺序表的实际存放元素的个数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示顺序表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_list</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size;++i)<span class="comment">//循环顺序表的长度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">list</span>-&gt;base[i]);<span class="comment">//指针base取出下标为i的元素</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头部插入*/</span></span><br><span class="line"><span class="comment">//先判断空间是否已满</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size  &gt;=  <span class="built_in">list</span>-&gt;capacity)<span class="comment">//顺序表的实际存放元素的个数大于等于顺序表的开辟容量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表空间已满，不能头部插入数据\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">list</span>-&gt;size;i&gt;<span class="number">0</span>;--i)<span class="comment">//循环实现插入新元素前，包括0下标以后的所有元素均后移</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i<span class="number">-1</span>];<span class="comment">//把下标为i-1的元素放在下标为i的位置上(后移)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;base[<span class="number">0</span>]=x;<span class="comment">//此时0下标空出，把新插入的元素放在顺序表的0下标位置上</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size++;<span class="comment">//插入元素后，顺序表的长度加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾删*/</span></span><br><span class="line"><span class="comment">//先判断空间是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_back</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表已空，不能尾部删除数据&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;<span class="comment">//顺序表的实际元素的个数减一，即有效数据减少一个，实现尾删</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头删*/</span></span><br><span class="line"><span class="comment">//先判断空间是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表已空，不能头部删除数据&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size<span class="number">-1</span>;++i)<span class="comment">//除0下标存放的元素不动，其他所有元素依次向前移动，共移动size-1次</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i+<span class="number">1</span>];<span class="comment">//把下标为i+1的元素放在下标为i的位置上</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;<span class="comment">//删除元素后，顺序表的长度减一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按位置插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_pos</span><span class="params">(SeqList *<span class="built_in">list</span>,<span class="type">int</span> pos,ElemType x)</span><span class="comment">//给出顺序表的位置，插入元素的位置，插入元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;<span class="built_in">list</span>-&gt;size)<span class="comment">//插入位置小于0或大于当前位置</span></span><br><span class="line"><span class="comment">//(假如顺序表中此时有4个元素，size=4，如果在下标为4的位置插入，实际上此时顺序表下标才为3，可以插入也就是尾插)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入的位置非法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">list</span>-&gt;size;i&gt;pos;--i)<span class="comment">//i是当前在顺序表的位置，i如果大于要插入的位置，i就减一</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i<span class="number">-1</span>];<span class="comment">//把下标为i-1的元素放在下标为i的位置上(后移)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;base[pos]=x;<span class="comment">//包括pos位置在内，pos及之后的元素都向后移动，直到i=pos时(此时循环结束)，插入新元素</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size++;<span class="comment">//插入元素后，顺序表的实际元素的个数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按位置查找*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span><span class="comment">//给出顺序表的位置，查找的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size;++i)<span class="comment">//遍历顺序表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;base[i]==x)<span class="comment">//查找的元素等于表中下标为i的元素</span></span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//返回下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//否则返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序表长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;<span class="comment">//返回顺序表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按位置删除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_pos</span><span class="params">(SeqList *<span class="built_in">list</span>,<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;=<span class="built_in">list</span>-&gt;size)<span class="comment">//插入位置小于0或大于等于当前位置</span></span><br><span class="line"><span class="comment">//(假如顺序表中此时有4个元素，size=4，如果在下标为4的位置删除，实际上此时顺序表下标才为3，所以删不到)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入的位置非法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;<span class="built_in">list</span>-&gt;size<span class="number">-1</span>;++i)<span class="comment">//pos下标之前(包括pos)存放的元素不动，pos之后的元素依次向前移动，共移动size-pos-1次</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i+<span class="number">1</span>];<span class="comment">//把下标为i+1的元素放在下标为i的位置上(前移)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值删除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dele_val</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span><span class="comment">//给出顺序表的位置，删除的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos=find(<span class="built_in">list</span>,x);</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">delete_pos(<span class="built_in">list</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size<span class="number">-1</span>;++i)<span class="comment">//size-1相当于下标</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">list</span>-&gt;size-i<span class="number">-1</span>;++j)</span><br><span class="line"><span class="comment">//第0趟比较,j保证了循环到下标为size-1的元素,即最后一个元素</span></span><br><span class="line"><span class="comment">//第1趟比较,j保证了循环到下标为size-2的元素(最后一个元素沉底，不再进行比较)</span></span><br><span class="line"><span class="comment">//第2趟比较,j保证了循环到下标为size-3的元素</span></span><br><span class="line"><span class="comment">//第3趟比较,j保证了循环到下标为size-4的元素</span></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"><span class="comment">//第i趟比较,j保证了循环到下标为size-i-1的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;base[j]&gt;<span class="built_in">list</span>-&gt;base[j+<span class="number">1</span>])<span class="comment">//相邻元素交换</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType t=<span class="built_in">list</span>-&gt;base[j];</span><br><span class="line"><span class="built_in">list</span>-&gt;base[j]=<span class="built_in">list</span>-&gt;base[j+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">list</span>-&gt;base[j+<span class="number">1</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除顺序表中的数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//顺序表的长度置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*摧毁顺序表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">list</span>-&gt;base);<span class="comment">//把指针base所指的顺序表空间释放掉</span></span><br><span class="line"><span class="built_in">list</span>-&gt;base=<span class="literal">NULL</span>;<span class="comment">//把指针base初始化,预防野指针</span></span><br><span class="line"><span class="built_in">list</span>-&gt;capacity=<span class="number">0</span>;<span class="comment">//顺序表的容量大小为0</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//顺序表的实际存放元素的个数为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SeqList mylist;<span class="comment">//定义一个名为mylist的顺序表</span></span><br><span class="line">InitSeqList(&amp;mylist);<span class="comment">//初始化mylist顺序表，&amp;为地址传递</span></span><br><span class="line">ElemType item;<span class="comment">//定义插入的元素</span></span><br><span class="line"><span class="type">int</span> pos;<span class="comment">//定义插入的位置</span></span><br><span class="line"><span class="type">int</span> select=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [1]push_back(尾插)         [2]push_front(头插)  *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [3]show_list(显示)         [4]pop_back(尾删)    *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [5]pop_front(头删)         [6]insert_pos(随插)  *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [7]find(查找)              [8]length(求长度)    *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [9]delete_pos(按位置删)    [10]dele_val(按值删) *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [11]sort(排序)             [12]clear(清除)      *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [13]destory(销毁)          [0]quit(退出系统)    *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;select);</span><br><span class="line"><span class="keyword">if</span>(select==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//退出系统</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)<span class="comment">//逗号表达式</span></span><br><span class="line">&#123;</span><br><span class="line">push_back(&amp;mylist,item);</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">push_front(&amp;mylist,item);</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">show_list(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">pop_back(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">pop_front(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的位置:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pos);</span><br><span class="line">    insert_pos(&amp;mylist,pos,item);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的数据:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">pos=find(&amp;mylist,item);</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找的数据%d不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找的数据%d在顺序表中的%d下标位置\n&quot;</span>,item,pos);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表的长度为:%d\n&quot;</span>,length(&amp;mylist));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的位置:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pos);</span><br><span class="line">delete_pos(&amp;mylist,pos);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的数据:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">dele_val(&amp;mylist,item);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">sort(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">clear(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">destory(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入的选择错误，请重新输入:\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：<br><img src="https://img-blog.csdnimg.cn/20200404212304970.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储，即通过数据元素物理存储的连续性来反应元素之间逻辑上的相邻关系。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/</id>
    <published>2023-02-01T08:11:37.331Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>和顺序栈类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素外，尚需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。</p><p>为了在C语言中描述方便起见，<strong>初始化</strong>建空队列的时候，令<strong>front&#x3D;rear&#x3D;0，每次插入新的队列尾元素时，“队尾针增1”；每当删除队列头元素时，“头指针增1”；</strong></p><p>因此，在非空队列中，头指针始终指向队列头元素，而队尾指针始终指向队列尾元素的下一个位置，即队尾指针指向的空间是下一个能正常入队的空间，如图：<br><img src="https://img-blog.csdnimg.cn/20200408211853334.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 8<span class="comment">//定义队列初始化存放8个数据元素</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElmeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出顺序队列的结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElmeType *base;<span class="comment">//指针base指向有效的队列空间</span></span><br><span class="line"><span class="type">int</span>      front;<span class="comment">//队头指针记录队头元素的下标</span></span><br><span class="line"><span class="type">int</span>      rear;<span class="comment">//队尾指针记录队尾元素的下一个元素的下标</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;base=(ElmeType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElmeType)*MAXSIZE);<span class="comment">//开辟队空间</span></span><br><span class="line">assert(Q-&gt;base!=<span class="literal">NULL</span>);</span><br><span class="line">Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队头指针和队尾指针都指向队列的0下标,此时队列为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue *Q,ElmeType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//入队时,新入队元素是在队尾指针指向当前下标地址进行入队,入队完成后,队尾指针指向下一个下标地址</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;rear &gt;= MAXSIZE)<span class="comment">//当队尾指针指向的下标与队空间大小相同时,队已满</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Q-&gt;base[Q-&gt;rear]=x;</span><br><span class="line">Q-&gt;rear++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示顺序队列元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队列中存放的元素:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=Q-&gt;front;i&lt;Q-&gt;rear;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Q-&gt;base[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//进队一个元素,队尾指针指向下一个有效的空间(新空间)</span></span><br><span class="line"><span class="comment">//出队一个元素,队头指针指向下一个有效的数据元素</span></span><br><span class="line"><span class="comment">//当某一时刻,出队了一个元素后,队头指针指向下一个(新空间)时,此时说明队头指针和队尾指针都指向队列的同一个下标地址</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队列为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Q-&gt;front++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取队头元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(Queue *Q,ElmeType *v)</span><span class="comment">//指针v带回队头元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要获取队头,前提是队列不空</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队列为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">*v=Q-&gt;base[Q-&gt;front];<span class="comment">//必须在base所指的空间里取元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序队列的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q-&gt;rear - Q-&gt;front);<span class="comment">//下标0开始存放数据,进队后,队尾指针指向下一个有效的新空间</span></span><br><span class="line"><span class="comment">//队列中元素的个数正好是队尾队头所指的下标之差</span></span><br><span class="line"><span class="comment">//例如队头指针指向0下标,队尾指针指向3下标,此时队中有3(3-0)个元素,即已存放数据在0,1,2下标中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队列置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(Q-&gt;base);<span class="comment">//释放base所指的队列空间</span></span><br><span class="line">Q-&gt;base=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Queue Q;</span><br><span class="line">ElmeType e;<span class="comment">//定义队头元素</span></span><br><span class="line">InitQueue(&amp;Q);<span class="comment">//&amp;Q是传入队列的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入队\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;Q,i);</span><br><span class="line">&#125;</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队列&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队列&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队列&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队列&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队列&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队列&quot;</span>);</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ClearQueue(&amp;Q);</span><br><span class="line">DestroyQueue(&amp;Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200408225413181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和顺序栈类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素外，尚需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。&lt;/p&gt;
&lt;p&gt;为了在C语言中描述方便起见，&lt;strong&gt;初始化&lt;/strong&gt;建空队列的时候，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-01T08:11:37.300Z</published>
    <updated>2023-02-01T00:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>链表中的数据是以结点来表示的，每个结点的构成：**元素(数据元素的映象) + 指针(指示后继元素存储位置)**，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><p>●头结点是在链表的开始结点之前附加的一个结点(结点没有有效的数据元素)<br>●第一个结点（或称首元结点）是链表中存储第一个有效数据元素的结点</p><p>在链表这里，小萌新想说一定要把’’<strong>指针的指向，谁是谁的前驱结点，谁是谁的后继结点</strong>‘’搞清楚，多画图，慢慢领会！</p><p>话不多说，把代码敲起来!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言——如果条件返回错误，则终止程序执行</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的单链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出结点结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域(指向下一个结点的地址)</span></span><br><span class="line">&#125;ListNode,*pNode;<span class="comment">//定义结点类型,定义结点的指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出单链表结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">pNode first;<span class="comment">//first指向头结点(单链表中有效结点的前一个结点,即头结点)</span></span><br><span class="line">pNode last;<span class="comment">//last指向最后一个结点(尾结点)</span></span><br><span class="line"><span class="type">size_t</span> size;<span class="comment">//结点的个数</span></span><br><span class="line">&#125;List;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化单链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;first=<span class="built_in">list</span>-&gt;last=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));<span class="comment">//申请一个结点,同时用指针first和指针last指向这个结点</span></span><br><span class="line">assert(<span class="built_in">list</span>-&gt;first!=<span class="literal">NULL</span>);<span class="comment">//判断申请空间是否为空</span></span><br><span class="line"><span class="built_in">list</span>-&gt;first-&gt;next=<span class="literal">NULL</span>;<span class="comment">//头结点的指针域初始化为空(头结点的指针域存放第一个有效结点的地址)</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//初始化有效结点个数为0个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾部插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">ListNode *s=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));<span class="comment">//申请一个结点,用指针s指向这个结点(用指针s保存这个结点的地址)</span></span><br><span class="line">assert(s!=<span class="literal">NULL</span>);<span class="comment">//判断是否申请空间成功</span></span><br><span class="line">s-&gt;data=x;<span class="comment">//x存放在新结点的数据域</span></span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//新结点的指针域为空</span></span><br><span class="line"><span class="comment">//链接</span></span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next=s;</span><br><span class="line"><span class="comment">//list-&gt;last代表最后一个结点,list-&gt;last-&gt;next代表最后一个结点的指针域,该指针域保存指针s(即保存新结点地址)</span></span><br><span class="line"><span class="built_in">list</span>-&gt;last=s;<span class="comment">//last指针后移,用last指针代替s指针指向最后一个结点(即新插入的结点)</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size++;<span class="comment">//插入后,结点数增加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示单链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_list</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义指针p指向单链表中的第一个有效结点(注意不是头结点)</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//如果结点不为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>,p-&gt;data);<span class="comment">//打印该结点的数据域</span></span><br><span class="line">    p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该结点已空\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头部插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">ListNode *s=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">s-&gt;data=x;<span class="comment">//x存放在新结点的数据域</span></span><br><span class="line">s-&gt;next=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//新结点指针域保存第一个有效结点的地址(本来第一个有效结点的地址是让头结点的next保存的)</span></span><br><span class="line"><span class="built_in">list</span>-&gt;first-&gt;next=s;<span class="comment">//用头结点的指针域保存指针s(即新结点的地址)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//如果此时只有头结点，当插入第一个有效结点时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;last=s;<span class="comment">//则更改last指针，让其指向第一个有效结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;size++;<span class="comment">//插入后,结点数增加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾删*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_back</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//除头结点外，一个有效结点都没有，无法进行删除操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">ListNode *p=<span class="built_in">list</span>-&gt;first;<span class="comment">//定义一个指针p指向头结点</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="built_in">list</span>-&gt;last)<span class="comment">//当头结点后(即list-&gt;first-&gt;next)不是尾结点时</span></span><br><span class="line">p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">list</span>-&gt;last);<span class="comment">//当头结点后是尾结点时,释放尾结点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;last=p;<span class="comment">//此时指针last指向p指针所指的结点</span></span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next=<span class="literal">NULL</span>;<span class="comment">//last结点的指针域置为空</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size--;<span class="comment">//删除后，结点数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头删*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//除头结点外，一个有效结点都没有</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义一个指针p指向头结点后第一个有效结点</span></span><br><span class="line"><span class="built_in">list</span>-&gt;first-&gt;next=p-&gt;next;<span class="comment">//头结点的后继结点是第二个有效结点(即p-&gt;next),头结点的指针域保存第二个有效结点的地址</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放p指针所指的结点,实现头删</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">1</span>)<span class="comment">//如果此时只有头结点和最后一个结点,删除last结点时,需要把last指针指向头结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;last=<span class="built_in">list</span>-&gt;first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;size--;<span class="comment">//删除后，结点数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值插入(从小到大)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_val</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//申请要插入的数据</span></span><br><span class="line">ListNode *s=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));<span class="comment">//申请一个结点,用指针s指向这个结点(指针s保存了这个结点的地址)</span></span><br><span class="line">assert(s!=<span class="literal">NULL</span>);<span class="comment">//判断是否申请空间成功</span></span><br><span class="line">s-&gt;data=x;<span class="comment">//x存放在新结点的数据域</span></span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//新结点的指针域为空</span></span><br><span class="line"></span><br><span class="line">ListNode *p=<span class="built_in">list</span>-&gt;first;<span class="comment">//定义一个p指针指向头结点</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;data &lt; x)<span class="comment">//当头结点有后继结点并且后继结点的数据域小于要插入的数值</span></span><br><span class="line">p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)<span class="comment">//如果头结点后无其他结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;last=s;<span class="comment">//把last指针指向新的结点</span></span><br><span class="line">&#125;</span><br><span class="line">s-&gt;next=p-&gt;next;<span class="comment">//否则新结点的指针域保存第一个有效结点的地址(本来第一个有效结点的地址是让头结点的next保存的)</span></span><br><span class="line">    p-&gt;next=s;<span class="comment">//头结点的指针域保存新结点的地址,实现插入</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值查找*/</span></span><br><span class="line">ListNode* <span class="title function_">find</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义一个指针p指向头结点后第一个有效结点(即头结点的后继)</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=x)<span class="comment">//如果后继结点不为空并且结点的数据域不为要查找的数值</span></span><br><span class="line">p=p-&gt;next;<span class="comment">//则p指向下一个结点</span></span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">//返回当前结点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单链表长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值删除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dele_val</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//除头结点外，一个有效结点都没有</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">ListNode *p=find(<span class="built_in">list</span>,x);<span class="comment">//定义指针p保存find函数返回的当前结点的地址</span></span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//如果结点的地址为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="built_in">list</span>-&gt;last)<span class="comment">//如果结点地址正好是尾结点</span></span><br><span class="line">&#123;</span><br><span class="line">pop_back(<span class="built_in">list</span>);<span class="comment">//通过pop函数进行尾部删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则</span></span><br><span class="line">&#123;</span><br><span class="line">ListNode *q=p-&gt;next;<span class="comment">//定义指针q指向当前结点(要删除数据的结点)的后继结点</span></span><br><span class="line">p-&gt;data=q-&gt;data;<span class="comment">//用下一个结点的数据域覆盖当前要删除结点的数据域</span></span><br><span class="line">p-&gt;next=q-&gt;next;<span class="comment">//删除当前要删除结点的下一个结点(p-&gt;next=p-&gt;next-&gt;next)</span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">//释放要删除数据结点的后继结点</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*排序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span> || <span class="built_in">list</span>-&gt;size==<span class="number">1</span>)<span class="comment">//只有头结点或只有头尾两个结点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">ListNode *s=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义一个指针s指向头结点的后继结点</span></span><br><span class="line">ListNode *q=s-&gt;next;<span class="comment">//定义指针q指向s指针指向结点的后继结点</span></span><br><span class="line"><span class="comment">//断开链表</span></span><br><span class="line"><span class="built_in">list</span>-&gt;last=s;<span class="comment">//last指针指向s</span></span><br><span class="line"><span class="built_in">list</span>-&gt;last-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾结点的指针域为空</span></span><br><span class="line"><span class="comment">//按值插入</span></span><br><span class="line"><span class="keyword">while</span>(q!=<span class="literal">NULL</span>)<span class="comment">//判断指针q指向s指针指向结点的后继结点是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">s=q;<span class="comment">//若不为空,指针s下移结点(指针s指向断开链表后的第一个结点)</span></span><br><span class="line">q=q-&gt;next;<span class="comment">//q指针下移(指针q指向s指向断开链表后的第一个结点的后继)</span></span><br><span class="line">ListNode *p=<span class="built_in">list</span>-&gt;first;<span class="comment">//定义一个p指针指向头结点</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;data &lt; s-&gt;data)<span class="comment">//当头结点有后继结点并且后继结点的数据域小于断开链表后的第一个结点</span></span><br><span class="line">p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)<span class="comment">//如果p所指结点的next为空,则此时p指向尾结点,相当于尾插(更改last指针的指向)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;last=s;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;next=p-&gt;next;<span class="comment">//否则断开的结点在头结点与第一个有效结点之间比较,若不满足while,则进行插入</span></span><br><span class="line"><span class="comment">//指针s指向那个断开的结点,断开的结点的指针域保存第一个有效结点的地址</span></span><br><span class="line">    p-&gt;next=s;<span class="comment">//头结点的指针域保存断开结点的地址</span></span><br><span class="line"><span class="comment">//此时断开的结点成为第一个有效结点,实现数据域从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除单链表中的数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//只有头结点不需要清除</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义指针p指向第一个有效结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;first-&gt;next=p-&gt;next;<span class="comment">//头结点后为第二个有效结点</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放第一个有效结点</span></span><br><span class="line">p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//p重新指向第一个有效结点(是刚才的第二个有效结点)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;last=<span class="built_in">list</span>-&gt;first;<span class="comment">//while完毕后,链表中只剩头结点,将尾指针指向头结点</span></span><br><span class="line"><span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//结点个数置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*摧毁单链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">clear(<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">list</span>-&gt;first);<span class="comment">//释放头结点</span></span><br><span class="line"><span class="built_in">list</span>-&gt;first=<span class="built_in">list</span>-&gt;last=<span class="literal">NULL</span>;<span class="comment">//预防野指针,都置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">List mylist;<span class="comment">//定义一个名为mylist的单链表,内部有三个成员,均为随机值</span></span><br><span class="line">InitList(&amp;mylist);<span class="comment">//初始化mylist单链表，&amp;为地址传递</span></span><br><span class="line">ElemType item;<span class="comment">//定义插入的元素</span></span><br><span class="line">ListNode *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> select=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [1]push_back(尾插)         [2]push_front(头插)  *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [3]show_list(显示)         [4]pop_back(尾删)    *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [5]pop_front(头删)         [6]insert_val(按值插)*\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [7]find(查找)              [8]length(求长度)    *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [9]dele_val(按值删除)      [10]sort(排序)       *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [11]clear(清除)            [12]destory(销毁)    *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* [0]quit(退出系统)                               *\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;select);</span><br><span class="line"><span class="keyword">if</span>(select==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//退出系统</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)<span class="comment">//逗号表达式,item!=-1时插入</span></span><br><span class="line">&#123;</span><br><span class="line">push_back(&amp;mylist,item);</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">push_front(&amp;mylist,item);</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">show_list(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">pop_back(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">pop_front(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    insert_val(&amp;mylist,item);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的数据:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    p=find(&amp;mylist,item);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要查找的数据在链表中不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表的长度为:%d\n&quot;</span>,length(&amp;mylist));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的数据:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    dele_val(&amp;mylist,item);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">sort(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">clear(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">destory(&amp;mylist);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入的选择错误，请重新输入:\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200406104358973.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表中的数据是以结点来表示的，每个结点的构成：**元素(数据元素的映象) + 指针(指示后继元素存储位置)**，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。&lt;/p&gt;
&lt;p&gt;●头结点是在链表的开始结点之前附加的一个结点(结点没有有效的数据元素)&lt;br&gt;●第一个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%93%BE%E9%98%9F%E5%88%97/"/>
    <id>https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%93%BE%E9%98%9F%E5%88%97/</id>
    <published>2023-02-01T08:11:37.300Z</published>
    <updated>2023-02-01T00:10:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>队列：只允许在一端进行插入，在另一端进行删除的线性表</p><p><strong>链队列：使用链表实现的队列，具有队头指针和队尾指针，指示队列元素所在的位置</strong></p><p><strong>链队列特性：</strong><br>●只能队尾插入元素，在队头删除元素<br>●先进先出（First In First Out）的线性表，先进入的元素出队，后进入的元素才能出队</p><p>队列示意图：<br><img src="https://img-blog.csdnimg.cn/20200407235045226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>空链队列：<br><img src="https://img-blog.csdnimg.cn/20200407235120552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>链队的入栈操作：<br><img src="https://img-blog.csdnimg.cn/2020040723514797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>链队的出栈操作：<br><img src="https://img-blog.csdnimg.cn/20200407235207967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>————————纸上得来终觉浅，绝知此事要躬行————————</strong></p><p>话不多说，把代码开起来，这样晦涩的概念才不会显得苍白无力！！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span><span class="comment">//断言</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*链队的结点类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode,*PNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义链队结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PNode front;<span class="comment">//队头指针指向头结点</span></span><br><span class="line">PNode tail;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化链队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建头结点</span></span><br><span class="line">QueueNode *s=(QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">Q-&gt;front=Q-&gt;tail=s;<span class="comment">//队头指针和队尾指针都指向新结点</span></span><br><span class="line">Q-&gt;tail-&gt;next=<span class="literal">NULL</span>;<span class="comment">//队尾结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队尾指针的next指向新创建的结点(新结点进行尾插)</span></span><br><span class="line"><span class="comment">//更改尾指针tail的指向</span></span><br><span class="line">    QueueNode *s=(QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//新结点的指针域为空</span></span><br><span class="line">Q-&gt;tail-&gt;next=s;<span class="comment">//尾结点的指针域保存新结点的地址</span></span><br><span class="line">Q-&gt;tail=s;<span class="comment">//尾指针指向新结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示链队元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"> QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Front:&gt;&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">p=p-&gt;next;<span class="comment">//指针p指向下一个有效结点</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;&lt;:Tail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DenQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//出队相当于头部删除结点的过程:头结点的next指向第一个有效结点的后继,然后释放第一个有效结点</span></span><br><span class="line"><span class="comment">//注意:如果删除队尾结点,需要将队尾指针tail再次指向头结点</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;tail)<span class="comment">//空队列</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">//头结点的指针域保存第二个有效结点的地址</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放第一个有效结点</span></span><br><span class="line"><span class="keyword">if</span>(p==Q-&gt;tail)<span class="comment">//此时删除最后一个结点(尾结点)</span></span><br><span class="line">Q-&gt;tail=Q-&gt;front;<span class="comment">//队尾指针指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取链队头元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(LinkQueue *Q,ElemType *v)</span><span class="comment">//用指针v带回链队头元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;tail)<span class="comment">//空队列</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line">*v=p-&gt;data;<span class="comment">//p-&gt;data等价于Q-&gt;front-&gt;next-&gt;data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求链队长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;<span class="comment">//初始化长度为0</span></span><br><span class="line">QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//只有结点不为空,len增加</span></span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除链队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue</span><span class="params">(LinkQueue *Q)</span><span class="comment">//除头结点外,对所有结点进行清除</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;tail)<span class="comment">//如果头指针与尾指针指向相同,则链队为空</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//无需清除</span></span><br><span class="line">QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">//头结点的指针域保存第二个有效结点的地址</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放第一个有效结点</span></span><br><span class="line">p=Q-&gt;front-&gt;next;<span class="comment">//指针p重新指向头结点后第一个有效结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放完成后,对尾部指针进行修改</span></span><br><span class="line">Q-&gt;tail=Q-&gt;front;<span class="comment">//队尾指针指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁链队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(LinkQueue *Q)</span><span class="comment">//清除的前提下释放头结点实现销毁</span></span><br><span class="line">&#123;</span><br><span class="line">ClearQueue(Q);</span><br><span class="line"><span class="built_in">free</span>(Q-&gt;front);<span class="comment">//释放头结点</span></span><br><span class="line">Q-&gt;front=Q-&gt;tail=<span class="literal">NULL</span>;<span class="comment">//队头和队尾指针都赋空,预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LinkQueue Q;</span><br><span class="line">ElemType e;<span class="comment">//链队头元素</span></span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">EnQueue(&amp;Q,i);</span><br><span class="line">&#125;</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">DenQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">DenQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">DenQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">DenQueue(&amp;Q);</span><br><span class="line">GetHead(&amp;Q,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">ShowQueue(&amp;Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">ClearQueue(&amp;Q);</span><br><span class="line">DestroyQueue(&amp;Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200407234546380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;队列：只允许在一端进行插入，在另一端进行删除的线性表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链队列：使用链表实现的队列，具有队头指针和队尾指针，指示队列元素所在的位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链队列特性：&lt;/strong&gt;&lt;br&gt;●只能队尾插入元素，在队头删</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://suenning.com.cn/2023/02/01/hello-world/"/>
    <id>https://suenning.com.cn/2023/02/01/hello-world/</id>
    <published>2023-02-01T01:01:51.823Z</published>
    <updated>2023-02-01T01:01:51.823Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
