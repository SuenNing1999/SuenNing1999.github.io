<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"suenning.com.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 操作系统的概念及功能操作系统（OS）是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。操作系统的功能：  操作系统是系统资源的管理者 向上层提供方便易用的服务 是最接近硬件的一层软件  我们通过使用QQ软件的例子来体会操作系统的功能：1.操作系统作为管理者需要做的事情2.理解向上层">
<meta property="og:type" content="article">
<meta property="og:title" content="抽时间整理了一下大学操作系统的学习笔记（更新中）">
<meta property="og:url" content="https://suenning.com.cn/2023/02/01/%E6%8A%BD%E6%97%B6%E9%97%B4%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/index.html">
<meta property="og:site_name" content="橘生淮南">
<meta property="og:description" content="1. 操作系统的概念及功能操作系统（OS）是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。操作系统的功能：  操作系统是系统资源的管理者 向上层提供方便易用的服务 是最接近硬件的一层软件  我们通过使用QQ软件的例子来体会操作系统的功能：1.操作系统作为管理者需要做的事情2.理解向上层">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129164412796.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129165239495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129165440188.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129165553989.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129165717646.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202011291658229.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129165915944.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129170302735.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129171121702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129171408659.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129171502469.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020112917162170.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129175118783.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129175638794.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020112917590134.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129175926589.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201129180027737.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130173142375.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130173500721.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130173817644.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130174132106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113017423316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130174706781.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130174908825.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130175035923.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130193018688.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130193201923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113019361064.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130193747283.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130193835815.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130193951744.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130194057456.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130194218498.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113019432257.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130194630981.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130194710961.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130194757461.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130194845294.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130195149110.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130195253889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113019532145.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130195352126.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130195509421.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130195631854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130195730788.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130195902903.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130200004558.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130200238278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130200312609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130200543676.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130200621590.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130200704575.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113020074790.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113020093581.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130201102948.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130201206621.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130201242870.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130201557296.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113020163869.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130201717759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130201811431.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130202217866.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130202425320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130202458186.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130202545249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130202806858.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130202916595.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130203017174.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130203455354.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130203603869.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113020371124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130203735243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130203813793.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130203852552.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130204022410.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130204127288.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130204416676.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130204441942.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130204522128.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130204820966.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130204919507.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205043610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205145579.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205232301.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205326598.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205348799.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205710800.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205808761.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130205929946.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130210054872.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130210304160.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130210458236.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130210703184.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130210935307.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130211155717.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130211246631.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130211314119.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130211352171.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130211613567.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130211754256.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212008856.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212058968.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212130899.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212331519.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212553334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212649602.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212749185.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212856809.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130212939750.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113021310935.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213317568.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213344547.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213417756.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213614701.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213647557.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213738863.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213856668.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130213937102.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130214104149.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130214341266.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130214558494.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130214717696.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130214754398.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215058140.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215223162.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215336495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215509458.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215623641.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215737664.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215814431.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130215918585.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130220006653.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130220054407.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130220153459.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113022041482.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130220524804.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130220617786.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113022072152.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130221720966.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130221927735.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113022201948.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130222150915.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113022232081.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130222532258.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130222622674.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130222819351.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130223110264.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130223156758.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020113022323250.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201130223317453.png">
<meta property="article:published_time" content="2023-02-01T08:11:37.394Z">
<meta property="article:modified_time" content="2023-02-01T08:51:58.318Z">
<meta property="article:author" content="sunning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201129164412796.jpg">

<link rel="canonical" href="https://suenning.com.cn/2023/02/01/%E6%8A%BD%E6%97%B6%E9%97%B4%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>抽时间整理了一下大学操作系统的学习笔记（更新中） | 橘生淮南</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="橘生淮南" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">橘生淮南</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E6%8A%BD%E6%97%B6%E9%97%B4%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          抽时间整理了一下大学操作系统的学习笔记（更新中）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:51:58" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://img-blog.csdnimg.cn/20201129164412796.jpg" alt="在这里插入图片描述"></p>
<h4 id="1-操作系统的概念及功能"><a href="#1-操作系统的概念及功能" class="headerlink" title="1. 操作系统的概念及功能"></a>1. 操作系统的概念及功能</h4><p>操作系统（OS）是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。<br><img src="https://img-blog.csdnimg.cn/20201129165239495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>操作系统的功能：</strong></p>
<ol>
<li>操作系统是系统资源的管理者</li>
<li>向上层提供方便易用的服务</li>
<li>是最接近硬件的一层软件</li>
</ol>
<p>我们通过使用QQ软件的例子来体会操作系统的功能：<br><img src="https://img-blog.csdnimg.cn/20201129165440188.png" alt="在这里插入图片描述"><br>1.操作系统作为管理者需要做的事情<br><img src="https://img-blog.csdnimg.cn/20201129165553989.png" alt="在这里插入图片描述"><br>2.理解向上层提供方便易用的服务<br>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p>
<p>那么具体提供方便易用的服务有哪些呢？<br>（1）GUI：图形化用户接口<br>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令，参数。<br>（2）命令接口<br><img src="https://img-blog.csdnimg.cn/20201129165717646.png" alt="在这里插入图片描述"><br>3.操作系统作为最接近硬件的层次<br><img src="https://img-blog.csdnimg.cn/202011291658229.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201129165915944.png" alt="在这里插入图片描述"></p>
<h4 id="2-操作系统的四个特征"><a href="#2-操作系统的四个特征" class="headerlink" title="2. 操作系统的四个特征"></a>2. 操作系统的四个特征</h4><p>操作系统有 <strong>并发，共享，虚拟，异步</strong> 这四个基本特征，其中并发和共享是两个最基本的特征，二者互为存在条件。</p>
<p>（1）并发：指两个或多个事件在同一时间间隔内发生。在这些事件宏观上是同时发生的。<br>注意：这里通常与并行混淆，并行是指两个或多个事件在同一时刻同时发生。</p>
<p>为了方便理解，我们来个例子！老渣和小渣<br><img src="https://img-blog.csdnimg.cn/20201129170302735.png" alt="在这里插入图片描述"></p>
<ol>
<li>操作系统的并发性：指计算机系统中同时运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着多道程序技术而出现的。因此，操作系统和程序并发是一起诞生的。</li>
<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行。多核CPU同一时刻可以同时执行多个程序，多个程序可以并行的执行。</li>
</ol>
<p>（2）共享：即资源共享，是指系统中地资源可供内存中多个并发执行地进程共同使用。</p>
<ul>
<li><p>两种资源共享方式：互斥共享方式与同时共享方式</p>
</li>
<li><p>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p>
</li>
<li><p>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程同时对它们进行访问。所谓的同时往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）。</p>
</li>
</ul>
<blockquote>
<p>举个例子：<br>互斥共享方式：比如在使用QQ和微信视频，同一时间段内摄像头只能分配给其中一个进程。<br>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
</blockquote>
<ul>
<li>并发和共享的关系<br><img src="https://img-blog.csdnimg.cn/20201129171121702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发和共享是两个最基本的特征，二者互为存在条件</span><br></pre></td></tr></table></figure>
<p>（3）虚拟：是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。<br>（4）异步：指多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。<br><img src="https://img-blog.csdnimg.cn/20201129171408659.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201129171502469.png" alt="在这里插入图片描述"></p>
<h4 id="3-操作系统的运行机制"><a href="#3-操作系统的运行机制" class="headerlink" title="3. 操作系统的运行机制"></a>3. 操作系统的运行机制</h4><p><img src="https://img-blog.csdnimg.cn/2020112917162170.png" alt="在这里插入图片描述"><br>程序是如何运行的:<br><img src="https://img-blog.csdnimg.cn/20201129175118783.png" alt="在这里插入图片描述"><br>注意：指令就是处理器（CPU）能识别，执行的最基本命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序运行的过程其实就是CPU执行一条一条的机器指令的过程</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内核是操作系统最重要最核心的部分，也是最接近硬件的部分</span><br></pre></td></tr></table></figure>
<ul>
<li>特权指令与非特权指令</li>
<li>应用程序只能使用非特权指令，如：加法指令，减法指令等。<br>操作系统内核作为管理者，有时会让CPU执行一些特权指令，如：内存清零指令。</li>
</ul>
<p>在CPU设计和生产的时候划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。</p>
<p><strong>内核态与用户态</strong><br>CPU既然能判断出指令类型，但是它怎么区分此时正在运行的是内核程序或者是应用程序呢？</p>
<blockquote>
<p>其实，CPU有两种状态，即内核态和用户态</p>
</blockquote>
<ul>
<li>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</li>
<li>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</li>
</ul>
<p>CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示内核态，0表示用户态。<br><img src="https://img-blog.csdnimg.cn/20201129175638794.png" alt="在这里插入图片描述"><br>&amp;emsp;&amp;emsp;内核程序在合适的时候主动让出CPU，从核心态切换到用户态，即将让应用程序在CPU上运行。一旦CPU处于用户态时，我们的应用程序将会在此用户态下运行，此时CPU会执行应用程序中一条又一条的指令。但是如果此时在应用程序中恶意植入了一条特权指令，那么此时CPU当执行这条特权指令时，会检查自己的PSW，发现自己依然处于用户态却要执行这条特权指令，那么这个非法事件会引发一个中断信号发送给CPU，使得CPU强行从用户态转成核心态，并且CPU会拒绝执行该特权指令以及暂停执行后面的其他指令。转而CPU会执行一个处理中断信号的内核程序。<br>&amp;emsp;&amp;emsp;换句话说，在发生中断信号之后，中断使操作系统内核再次夺回CPU的控制权，从用户态再次切换到核心态，操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序。</p>
<ol>
<li>当操作系统从内核态切换到用户态时：<br><img src="https://img-blog.csdnimg.cn/2020112917590134.png" alt="在这里插入图片描述"></li>
<li>当操作系统从用户态切换到内核态时：<br><img src="https://img-blog.csdnimg.cn/20201129175926589.png" alt="在这里插入图片描述"><br>从用户态切换到内核态的前提是由中断引发的，除了非法使用特权指令之外，还有许多事件会触发中断信号。一个共性是，但凡需要操作系统介入的工作地方，都会触发中断信号。</li>
</ol>
<p>小结：<br><img src="https://img-blog.csdnimg.cn/20201129180027737.png" alt="在这里插入图片描述"></p>
<h4 id="4-操作系统的中断与异常"><a href="#4-操作系统的中断与异常" class="headerlink" title="4. 操作系统的中断与异常"></a>4. 操作系统的中断与异常</h4><p><img src="https://img-blog.csdnimg.cn/20201130173142375.png" alt="在这里插入图片描述"><br>我们知道在CPU上会运行两种程序，一种是操作系统的内核程序，一种是应用程序。内核程序是整个系统的管理者，在计算机启动时，CPU处于内核态，只是在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。一个应用程序在上CPU运行之后，它就会一直运行下去，除非发送中断。</p>
<p>（1）中断的作用</p>
<blockquote>
<p>中断是让操作系统内核夺回CPU使用权的唯一途径，使CPU由用户态变为内核态。</p>
</blockquote>
<ul>
<li>那么问题来了，如果没有中断机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。如果CPU一直运行同一个应用程序，将如何实现多道程序并发这个事情呢？<br><img src="https://img-blog.csdnimg.cn/20201130173500721.png" alt="在这里插入图片描述"></li>
</ul>
<p>（2）中断的类型</p>
<blockquote>
<p>中断分为内中断与外中断</p>
</blockquote>
<ul>
<li>内中断：与当前执行的指令有关，中断信号来源于	CPU内部</li>
<li>外中断：与当前执行的指令无关，中断信号来源于	CPU外部</li>
</ul>
<p>我们来看内中断的例子：</p>
<ol>
<li>试图在用户态下执行特权指令<br><img src="https://img-blog.csdnimg.cn/20201130173817644.png" alt="在这里插入图片描述"></li>
<li>执行除法指令时发现除数为0<br>总之，若当前执行的指令是非法的，或执行指令的参数是非法的，那么就会引发一个中断信号。</li>
<li>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号。</li>
</ol>
<blockquote>
<p>执行陷入指令，意味着应用程序主动地将CPU控制权还给操作系统内核，系统调用就是通过陷入指令完成的</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">陷入指令是一种特殊的指令不是特权指令</span><br></pre></td></tr></table></figure>
<p>我们再来看外中断的例子：</p>
<ol>
<li>时钟中断——由时钟部件发来的中断信号<br><img src="https://img-blog.csdnimg.cn/20201130174132106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">系统中想要并发的运行两个应用程序，首先应用程序1运行在用户态，CPU执行其指令，假如当CPU执行两条指令后，时钟部件检测已经执行过了50ms，于是时钟部件会给CPU发送一个中断信号，此时CPU会暂停执行应用程序1，转而去执行处理时钟中断的内核程序，去处理这个中断信号。<br><img src="https://img-blog.csdnimg.cn/2020113017423316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时CPU由用户态转为内核态，在处理中断信号的内核程序中，操作系统内核发现应用程序1已经用了50ms，为了公平起见，操作系统内核决定接下来让另一个应用程序2上CPU运行。<br>CPU又从内核态转为用户态，CPU执行应用程序2的指令，同样的，时钟部件检测已经过了50ms，于是时钟部件再次会给CPU发送一个中断信号，此时CPU又会暂停执行应用程序2，转而去执行处理时钟中断的内核程序。<br>在处理中断信号的内核程序中，操作系统内核发现应用程序2已经用了50ms，为了公平起见，操作系统内核决定接下来又让应用程序1上CPU运行，于是将CPU的使用权让给应用程序1，然后应用程序1就会执行它之后的未执行的指令，依次往复。</li>
<li>I&#x2F;O中断——由输入&#x2F;输出设备发来的中断信号<br>每一条指令执行结束时，CPU都会例行检查是否有外部中断信号<br><img src="https://img-blog.csdnimg.cn/20201130174706781.png" alt="在这里插入图片描述"></li>
</ol>
<p>（3）中断机制的基本原理</p>
<blockquote>
<p>不同的中断信号，需要用不同的中断处理程序来处理</p>
</blockquote>
<p>当CPU检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内存中的存放位置。<br><img src="https://img-blog.csdnimg.cn/20201130174908825.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130175035923.png" alt="在这里插入图片描述"></p>
<h4 id="5-进程的自述"><a href="#5-进程的自述" class="headerlink" title="5. 进程的自述"></a>5. 进程的自述</h4><p>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。比如在Windows中就是以后缀为.exe的可执行文件</p>
<p>进程：是动态的，是程序的一次执行过程</p>
<blockquote>
<p>同一个程序多次执行会对应多个进程</p>
</blockquote>
<p><strong>进程的组成部分——（PCB）</strong><br>那么既然操作系统是这些进程的管理者，它要怎么区分各个进程呢？</p>
<ul>
<li>当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的身份证号（PID）</li>
<li>操作系统要记录PID，进程所属用户ID（UID），操作系统可以根据PID，UID这些基本的进程描述信息，让操作系统区分各个进程。</li>
<li>操作系统要记录给进程分配了哪些资源（如：分配了多少内存，正在使用哪些I&#x2F;O设备，正在使用哪些文件），这些信息可以用于实现操作系统对资源的管理。</li>
<li>操作系统要记录进程的运行情况（如：CPU使用时间，磁盘使用情况，网络流量使用情况等），这些信息可以实现操作系统对进程的控制，调度。</li>
</ul>
<p>那么既然操作系统要记录这么多信息，那该如何整理呢?</p>
<ul>
<li>其实这些信息都被保存在一个数据结构PCB中，即进程控制块。总之，操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。<br><img src="https://img-blog.csdnimg.cn/20201130193018688.png" alt="在这里插入图片描述"><br> PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会收回其PCB。</li>
</ul>
<p><strong>进程的组成部分：PCB，程序段，数据段</strong><br><img src="https://img-blog.csdnimg.cn/20201130193201923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>这里需要明确的是PCB是给操作系统用的，而程序段，数据段是给进程自己用的。</p>
</blockquote>
<p><strong>什么是程序的运行？</strong></p>
<ol>
<li>我们知道程序在运行之前，都需要通过编译器将代码“翻译”成二进制的机器指令，一条高级语言的代码翻译过来可能会对应多条机器指令。那么程序运行的过程其实就是CPU执行一条一条的机器指令的过程。</li>
<li>当我们写完一个程序之后，经过编译链接等一系列的步骤，最终会形成一个后缀为.exe的可执行文件，这个可执行文件一直是存放在硬盘当中的，在系统运行这个可执行文件前需要把程序放入内存中，同时操作系统会为其创建相应的PCB，以及一些程序段也会调入内存中，我们知道程序段中包含了一条一条的指令，我们的CPU就是从内存中取出这些指令。此外，程序是基于代码的，那代码的一些运算结果同样需要被调用。换句话说，数据段也要被调入到内存之中，数据段包含了运行过程中产生的，需要使用的各种数据，比如我们定义了某些变量，就是包含在数据段里的。<br><img src="https://img-blog.csdnimg.cn/2020113019361064.png" alt="在这里插入图片描述"><br><strong>总结：一个进程的实体（进程映像）是由PCB，程序段，数据段组成的</strong></li>
</ol>
<p>进程的深度解读：<br><img src="https://img-blog.csdnimg.cn/20201130193747283.png" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PCB是进程存在的唯一标志！</span><br></pre></td></tr></table></figure>
<p>进程的特征：<br><img src="https://img-blog.csdnimg.cn/20201130193835815.png" alt="在这里插入图片描述"><br>注意：<br>（1）进程是动态的，动态性是进程最基本的特征<br>（2）异步性会导致并发程序执行结果的不确定性</p>
<p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130193951744.png" alt="在这里插入图片描述"></p>
<h4 id="6-进程的状态与转换"><a href="#6-进程的状态与转换" class="headerlink" title="6. 进程的状态与转换"></a>6. 进程的状态与转换</h4><p><img src="https://img-blog.csdnimg.cn/20201130194057456.png" alt="在这里插入图片描述"><br><strong>进程的状态——创建态，就绪态</strong><br>（1）进程正在被创建时，它的状态是创建态，在这个阶段操作系统会为进程分配资源，初始化PCB。<br>（2）当进程创建完成后，便进入就绪态，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行。<br><img src="https://img-blog.csdnimg.cn/20201130194218498.png" alt="在这里插入图片描述"><br><strong>进程的状态——运行态</strong><br>在一个进程中可能会有很多个进程都处于就绪态，当CPU空闲时，操作系统就会选择一个就绪进程，让它上处理机运行。<br><img src="https://img-blog.csdnimg.cn/2020113019432257.png" alt="在这里插入图片描述"><br>如果一个进程此时在CPU上运行，那么这个进程处于运行态。换句话说，此时CPU会执行该进程对应的程序（执行指令序列）。</p>
<p><strong>进程的状态——阻塞态</strong><br>在进程运行的过程中，可能会请求等待某个事件的发生，如等待某种系统资源的分配，或者等待其他进程的响应。<br>在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入阻塞态。当CPU空闲时，又会选择另一个就绪态进程上CPU运行。</p>
<p><strong>进程的状态——终止态</strong><br>假设此时运行在CPU上的进程1已经运行结束了，在运行结束时会发出一个（exit）的系统调用，请求操作系统终止该进程。<br><img src="https://img-blog.csdnimg.cn/20201130194630981.png" alt="在这里插入图片描述"><br>此时该进程会进入终止态，操作系统会让该进程下CPU，并回收内存空间等资源，最后还是要回收该进程的CPU。当终止进程的工作完成之后，这个进程就彻底消失了。<br><img src="https://img-blog.csdnimg.cn/20201130194710961.png" alt="在这里插入图片描述"><br>进程状态的转换（图解）：<br><img src="https://img-blog.csdnimg.cn/20201130194757461.png" alt="在这里插入图片描述"><br>进程的状态：<br><img src="https://img-blog.csdnimg.cn/20201130194845294.png" alt="在这里插入图片描述"><br>进程PCB中，会有一个变量state来表示进程的当前状态。如：1表示创建态，2表示就绪态，3表示运行态。为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p>
<ul>
<li>那么如何将各个进程的PCB组织起来？</li>
</ul>
<p><strong>链接方式与索引方式</strong></p>
<ol>
<li>链接方式<br>（1）执行指针——指向当前处于运行状态（执行态）的进程<br>（2）就绪队列指针——指向当前处于就绪状态的进程<br>（3）阻塞队列指针——指向当前处于阻塞态的进程</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201130195149110.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li>索引方式<br><img src="https://img-blog.csdnimg.cn/20201130195253889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020113019532145.png" alt="在这里插入图片描述"></li>
</ol>
<p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130195352126.png" alt="在这里插入图片描述"></p>
<h4 id="7-进程控制及原语"><a href="#7-进程控制及原语" class="headerlink" title="7. 进程控制及原语"></a>7. 进程控制及原语</h4><p><img src="https://img-blog.csdnimg.cn/20201130195509421.png" alt="在这里插入图片描述"><br><strong>（1）什么是进程控制？</strong><br>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能。</p>
<blockquote>
<p>简单的说：<strong>进程控制就是要实现进程状态转换</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201130195631854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>（2）如何实现进程控制？</strong><br><strong>进程实现进程不同状态的转换是需要用“原语”来实现的</strong><br><img src="https://img-blog.csdnimg.cn/20201130195730788.png" alt="在这里插入图片描述"></p>
<ul>
<li>原语是一种特殊的程序，它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断。</li>
</ul>
<p><strong>那么思考一个问题，为什么进程控制（状态转换）的过程要一气呵成?</strong><br><img src="https://img-blog.csdnimg.cn/20201130195902903.png" alt="在这里插入图片描述"><br>我们假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少做这样两件事：<br>（1）将PCB2的（state）设为1<br>（2）将PCB2从阻塞队列放到就绪队列</p>
<p>如果此时我们已经将PCB2的（state）设为1，如图：<br><img src="https://img-blog.csdnimg.cn/20201130200004558.png" alt="在这里插入图片描述"><br>但是恰好此时收到了中断信号，那么PCB2的（state）&#x3D;1本来表示就绪状态却被放在阻塞队列里，这时如果不能一气呵成，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。所以这就是为什么进程状态的转换必须一气呵成！</p>
<p><strong>（3）如何实现原语的原子性?</strong><br>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用关中断指令和开中断指令这两个特权指令实现原子性。</p>
<p>CPU正常情况下运行：<br><img src="https://img-blog.csdnimg.cn/20201130200238278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>CPU执行了关中断与开中断指令：<br><img src="https://img-blog.csdnimg.cn/20201130200312609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况?</p>
<ul>
<li>这样就意味着我们可以在程序的开头植入一个关中断指令，然后在程序的末尾植入一个开中断指令，如此只要该程序上CPU运行，那程序就可以一直霸占CPU，显然这是不应该发生的。</li>
</ul>
<blockquote>
<p>所以开中断与关中断是两条特权指令</p>
</blockquote>
<p>（4）进程控制相关的原语</p>
<ol>
<li>进程的创建<br><img src="https://img-blog.csdnimg.cn/20201130200543676.png" alt="在这里插入图片描述"></li>
<li>进程的终止<br><img src="https://img-blog.csdnimg.cn/20201130200621590.png" alt="在这里插入图片描述"></li>
<li>进程的阻塞和唤醒<br><img src="https://img-blog.csdnimg.cn/20201130200704575.png" alt="在这里插入图片描述"></li>
<li>进程的切换<br><img src="https://img-blog.csdnimg.cn/2020113020074790.png" alt="在这里插入图片描述"><br>总结：无论哪个进程控制原语，要做的无非是三件事情：<br>1.更新PCB中的信息，修改进程状态（state）保存和恢复运行环境<br>2.将PCB插入合适的队列<br>3.分配和回收资源</li>
</ol>
<p>小结：<br><img src="https://img-blog.csdnimg.cn/2020113020093581.png" alt="在这里插入图片描述"></p>
<h4 id="8-线程与多线程模型"><a href="#8-线程与多线程模型" class="headerlink" title="8. 线程与多线程模型"></a>8. 线程与多线程模型</h4><p><img src="https://img-blog.csdnimg.cn/20201130201102948.png" alt="在这里插入图片描述"><br>在没有引入进程之前，系统中的各个程序只能串行执行，换句话说我们如果想要一边听音乐，一边玩QQ是不可以的。在引入进程之后，我们可以一边听音乐，一边玩QQ。但是问题来了，QQ中许多的功能，比如视频，文字聊天，传送文件等，可我们知道进程是程序的一次执行，那么这些功能显然不可能是由一个程序顺序处理就能实现的。<br><img src="https://img-blog.csdnimg.cn/20201130201206621.png" alt="在这里插入图片描述"><br>因此我们引入了线程的概念：<br><img src="https://img-blog.csdnimg.cn/20201130201242870.png" alt="在这里插入图片描述"><br><strong>传统的进程是程序执行流的最小单位，但在引入线程后，线程成为了程序执行流的最小单位。</strong></p>
<blockquote>
<p>同样，我们可以把线程理解为轻量级的进程</p>
</blockquote>
<p>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务，这时进程只作为除CPU之外的系统资源的分配单元</p>
<p>引入线程机制后，有什么变化?<br><img src="https://img-blog.csdnimg.cn/20201130201557296.png" alt="在这里插入图片描述"><br>线程的属性：<br><img src="https://img-blog.csdnimg.cn/2020113020163869.png" alt="在这里插入图片描述"><br>线程的实现方式与多线程模型<br><img src="https://img-blog.csdnimg.cn/20201130201717759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）用户级线程<br><img src="https://img-blog.csdnimg.cn/20201130201811431.png" alt="在这里插入图片描述"><br>很多编程语言提供了强大的线程库，可以实现线程的创建，销毁，调度等功能。</p>
<ul>
<li>那么线程的管理工作由谁来完成的?</li>
</ul>
<blockquote>
<p>线程的管理工作由应用程序提供的线程库来完成的，并不是由操作系统来完成的。</p>
</blockquote>
<ul>
<li><p>线程切换是否需要CPU从用户态转换为内核态?</p>
<blockquote>
<p>其实线程切换是由应用程序的线程库自己完成的，在用户态下就可以完成线程切换，不需要操作系统的切换。</p>
</blockquote>
</li>
<li><p>操作系统是否能意识到用户级线程的存在?</p>
</li>
</ul>
<blockquote>
<p>不能，只有用户才能感知到用户级线程的存在。</p>
</blockquote>
<p>用户级线程的优缺点：</p>
<ul>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li>
</ul>
<p>（2）内核级线程<br>内核级线程，由操作系统支持的线程<br><img src="https://img-blog.csdnimg.cn/20201130202217866.png" alt="在这里插入图片描述"><br>注意：内核级线程与用户级线程不同</p>
<ol>
<li>内核级线程的管理工具由操作系统内核完成</li>
<li>线程调度，切换等工作都由内核负责，因此内核级线程的切换必须需要在核心态下才能完成</li>
<li>操作系统会为每个内核级线程建立相应的TCB(线程控制块)，通过TCB对线程进行管理。内核级线程就是从操作系统内核视角看能看到的线程。</li>
</ol>
<p>内核级线程的优缺点：</p>
<ul>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
<p><strong>多线程模型</strong><br>之前我们讨论了用户级线程与内核级线程的优缺点，那么我们是否可以将这两种线程方式结合起来呢？<br>（1）一对一模型<br><img src="https://img-blog.csdnimg.cn/20201130202425320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（2）多对一模型<br><img src="https://img-blog.csdnimg.cn/20201130202458186.png" alt="在这里插入图片描述"><br>（3）多对多模型<br><img src="https://img-blog.csdnimg.cn/20201130202545249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总结：内核级线程与用户级线程</span><br><span class="line">（1）用户级线程是代码逻辑的载体</span><br><span class="line">（2）内核级线程是运行机会的载体</span><br><span class="line">（3）内核级线程才是处理机分配的单位</span><br><span class="line">（4）一段代码逻辑只有获得了运行机会才能被CPU执行</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。</p>
</blockquote>
<p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130202806858.png" alt="在这里插入图片描述"></p>
<h4 id="9-处理机调度"><a href="#9-处理机调度" class="headerlink" title="9. 处理机调度"></a>9. 处理机调度</h4><p><img src="https://img-blog.csdnimg.cn/20201130202916595.png" alt="在这里插入图片描述"><br>调度的基本原理：<br>当我们去银行取钱时，我们或许需要排队等待，作为普通客户，一般银行遵循着先到先服务的顺序。但是如果有VIP客户的话，他们未必需要排队就可以优先被服务。<br><img src="https://img-blog.csdnimg.cn/20201130203017174.png" alt="在这里插入图片描述"><br>当有一堆任务要处理，但由于资源有限，任务没法同时处理这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。</p>
<p><strong>高级调度</strong></p>
<p>作业：一个具体的任务</p>
<blockquote>
<p>用户向系统提交一个作业 &#x3D; 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
</blockquote>
<p>但是问题来了，我们的内存空间有限，有时无法将用户提交的作业全部放入内存，那该这么办呢？</p>
<ul>
<li>所谓高级调度（作业调度），是按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</li>
</ul>
<p><strong>低级调度</strong></p>
<ul>
<li>指按照某种策略从就绪队列中选择一个进程，将处理机分配给它。</li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201130203455354.png" alt="在这里插入图片描述"><br><strong>中级调度</strong><br>内存不够时，可将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存。暂时调到外存等待的进程状态为挂起状态，被挂起的进程PCB会被组织成挂起队列。<br><img src="https://img-blog.csdnimg.cn/20201130203603869.png" alt="在这里插入图片描述"></p>
<ul>
<li>所谓中级调度（内存调度）是指按照某种策略决定将哪个处于挂起状态的进程重新调入内存。</li>
<li>一个进程可能会被多次调出，调入内存，因此中级调度发生的频率要比高级调度更高。</li>
</ul>
<p><strong>挂起状态</strong><br><img src="https://img-blog.csdnimg.cn/2020113020371124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130203735243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>三层调度的联系与对比：<br><img src="https://img-blog.csdnimg.cn/20201130203813793.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130203852552.png" alt="在这里插入图片描述"></p>
<h4 id="10-进程调度的时机"><a href="#10-进程调度的时机" class="headerlink" title="10. 进程调度的时机"></a>10. 进程调度的时机</h4><p><img src="https://img-blog.csdnimg.cn/20201130204022410.png" alt="在这里插入图片描述"><br><strong>进程调度的时机</strong><br>我们知道进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。那什么时候进行进程调度与切换的情况?<br>（1）当前运行的进程主动放弃处理机<br>（2）当前运行的进程被动放弃处理机</p>
<p><img src="https://img-blog.csdnimg.cn/20201130204127288.png" alt="在这里插入图片描述"></p>
<ul>
<li>进程在操作系统内核程序临界区中不能进行调度与切换</li>
<li>进程处于临界区时不能进行处理机调度</li>
</ul>
<p><strong>临界资源：是指一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源。</strong></p>
<p><strong>临界区：指访问临界资源的这段代码。</strong></p>
<ul>
<li>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</li>
</ul>
<p>举两个例子：<br>（1）内核程序临界区访问的临界资源需要尽快的释放，不可以进行进程调度和切换<br><img src="https://img-blog.csdnimg.cn/20201130204416676.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130204441942.png" alt="在这里插入图片描述"><br>（2）普通临界区访问的临界资源时可以进行进程调度和切换<br><img src="https://img-blog.csdnimg.cn/20201130204522128.png" alt="在这里插入图片描述"><br><strong>进程调度的方式</strong></p>
<ol>
<li><strong>非剥夺调度方式</strong>，又称非抢占式。即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终于或主动要求进入阻塞状态。</li>
<li><strong>剥夺调度方式</strong>，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
</ol>
<ul>
<li><p>非剥夺调度方式实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p>
</li>
<li><p>剥夺调度方式可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能，适合于分时操作系统，实时操作系统。</p>
</li>
</ul>
<p><strong>进程的切换与过程</strong></p>
<ul>
<li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程</li>
<li>广义的进程调度包含了选择一个进程和进程切换两个步骤</li>
</ul>
<p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。<br><img src="https://img-blog.csdnimg.cn/20201130204820966.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130204919507.png" alt="在这里插入图片描述"></p>
<h4 id="11-调度算法的评价指标"><a href="#11-调度算法的评价指标" class="headerlink" title="11. 调度算法的评价指标"></a>11. 调度算法的评价指标</h4><p><img src="https://img-blog.csdnimg.cn/20201130205043610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>CPU的利用率</strong></p>
<p>CPU利用率：是指CPU忙碌的时间占总时间的比例<br><img src="https://img-blog.csdnimg.cn/20201130205145579.png" alt="在这里插入图片描述"><br>来道例题：<br><img src="https://img-blog.csdnimg.cn/20201130205232301.png" alt="在这里插入图片描述"><br><strong>系统吞吐量</strong></p>
<p>系统吞吐量是指：单位时间内完成作业的数量<br><img src="https://img-blog.csdnimg.cn/20201130205326598.png" alt="在这里插入图片描述"><br>来道例题：<br><img src="https://img-blog.csdnimg.cn/20201130205348799.png" alt="在这里插入图片描述"><br><strong>周转时间</strong></p>
<p>周转时间是指：从作业被提交给系统开始，到作业完成为止的这段时间间隔</p>
<ul>
<li>周转时间包括四个部分：</li>
</ul>
<ol>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间</li>
<li>进程在就绪队列等待进程调度（低级调度）的时间</li>
<li>进程在CPU上执行的时间</li>
<li>进程等待I&#x2F;O操作完成的时间</li>
</ol>
<p><strong>周转时间与平均周转时间</strong><br><img src="https://img-blog.csdnimg.cn/20201130205710800.png" alt="在这里插入图片描述"><br><strong>带权周转时间</strong></p>
<p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。<br><img src="https://img-blog.csdnimg.cn/20201130205808761.png" alt="在这里插入图片描述"><br>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">带权周转时间必然大于（等于）1</span><br><span class="line">带权周转时间与周转时间都是越小越好</span><br></pre></td></tr></table></figure>
<p><strong>平均带权周转时间</strong><br><img src="https://img-blog.csdnimg.cn/20201130205929946.png" alt="在这里插入图片描述"><br><strong>等待时间</strong></p>
<p>等待时间：指进程（作业）处于等待处理机状态时间之和，等待时间越长，用户满意度越低。<br><img src="https://img-blog.csdnimg.cn/20201130210054872.png" alt="在这里插入图片描述"><br>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。</p>
<p><strong>响应时间</strong></p>
<p>响应时间：指从用户提交请求到首次产生响应所用的时间。</p>
<p>小结：<br><img src="https://img-blog.csdnimg.cn/20201130210304160.png" alt="在这里插入图片描述"></p>
<h4 id="12-调度算法思想及规则（上）"><a href="#12-调度算法思想及规则（上）" class="headerlink" title="12. 调度算法思想及规则（上）"></a>12. 调度算法思想及规则（上）</h4><p><img src="https://img-blog.csdnimg.cn/20201130210458236.png" alt="在这里插入图片描述"><br><strong>一. 先来先服务调度算法（FCFS）</strong></p>
<p>（1）算法思想：</p>
<ul>
<li>主要是从公平的角度考虑（类似于我们生活中排队买东西的例子）</li>
</ul>
<p>（2）算法规则：</p>
<ul>
<li>按照作业&#x2F;进程到达的先后顺序进行服务</li>
<li>按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务</li>
</ul>
<p>（3）用于作业（进程）调度：</p>
<ul>
<li>用于作业调度时，考虑的是哪个作业先到达后备队列</li>
<li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
</ul>
<p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130210703184.png" alt="在这里插入图片描述"><br>（4）先来先服务调度算法的优缺点：</p>
<ul>
<li>优点：公平，算法实现简单</li>
<li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li>
<li>即先来先服务调度算法对长作业有利，对短作业不利</li>
<li>先来先服务调度算法是不会导致饥饿的</li>
</ul>
<p>（5）先来先服务调度算法概述：<br><img src="https://img-blog.csdnimg.cn/20201130210935307.png" alt="在这里插入图片描述"><br><strong>二. 短作业优先调度算法（SJF）</strong></p>
<p>（1）算法思想：</p>
<ul>
<li>追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</li>
</ul>
<p>（2）算法规则：</p>
<ul>
<li>最短的作业&#x2F;进程优先得到服务（所谓”最短“，是指要求服务时间最短）</li>
</ul>
<p>（3）用于作业（进程）调度：</p>
<ul>
<li>即可用于作业调度，也可用于进程调度</li>
<li>用于进程调度时称为”短进程优先算法（SPF）</li>
</ul>
<p>（4）是否可抢占：</p>
<ul>
<li>SJF和SPF是非抢占式的算法</li>
<li>但是也有抢占式的版本——最短剩余时间优先算法（SRTN）</li>
</ul>
<p>例题：<br>使用非抢占式的短作业优先调度算法SJF<br><img src="https://img-blog.csdnimg.cn/20201130211155717.png" alt="在这里插入图片描述"><br>使用抢占式的短作业优先调度算法SRTN<br><img src="https://img-blog.csdnimg.cn/20201130211246631.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130211314119.png" alt="在这里插入图片描述"><br>使用短作业优先算法需要注意：<br><img src="https://img-blog.csdnimg.cn/20201130211352171.png" alt="在这里插入图片描述"><br>（5）短作业优先调度算法的优缺点：</p>
<ul>
<li>优点：最短的平均等待时间，平均周转时间</li>
<li>缺点：对短作业有利，对长作业不利。可能产生饥饿现象。</li>
</ul>
<p>（6）短作业优先调度算法概述：<br><img src="https://img-blog.csdnimg.cn/20201130211613567.png" alt="在这里插入图片描述"><br>对FCFS和SJF两种算法的思考：</p>
<blockquote>
<p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题。</p>
</blockquote>
<blockquote>
<p>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。</p>
</blockquote>
<p><strong>那么，我们能不能设计一个算法，即考虑到各个作业的等待时间，也能兼顾运行时间?</strong></p>
<p><strong>三. 高响应比优先调度算法（HRRN）</strong></p>
<p>（1）算法思想</p>
<ul>
<li>要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</li>
</ul>
<p>（2）算法规则</p>
<ul>
<li>在每次调度时先计算各个作业（进程）的响应比，选择响应比最高的作业（进程）为其服务<br><img src="https://img-blog.csdnimg.cn/20201130211754256.png" alt="在这里插入图片描述"></li>
</ul>
<p>（3）用于作业（进程）调度</p>
<ul>
<li>即可用于作业调度，也可用于进程调度</li>
</ul>
<p>（4）是否可抢占?</p>
<ul>
<li>非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比</li>
</ul>
<p>（5）高响应比优先算法优缺点</p>
<ul>
<li>优点：综合考虑了等待时间和运行时间（要求服务时间）</li>
<li>等待时间相同时，要求服务时间短的优先（SJF的优点） 要求服务时间相同时，等待时间长的优先（FCFS的优点）</li>
<li>缺点：对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
<p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130212008856.png" alt="在这里插入图片描述"><br>（6）高响应比优先算法概述<br><img src="https://img-blog.csdnimg.cn/20201130212058968.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130212130899.png" alt="在这里插入图片描述"></p>
<h4 id="13-调度算法思想及规则（下）"><a href="#13-调度算法思想及规则（下）" class="headerlink" title="13. 调度算法思想及规则（下）"></a>13. 调度算法思想及规则（下）</h4><p><img src="https://img-blog.csdnimg.cn/20201130212331519.png" alt="在这里插入图片描述"><br><strong>四. 时间片轮转调度算法（RR）</strong></p>
<p>（1）算法思想</p>
<ul>
<li>公平的，轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</li>
</ul>
<p>（2）算法规则</p>
<ul>
<li>按照各进程到达就绪队列的顺序，轮转让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
</ul>
<p>（3）用于作业（进程）调度</p>
<ul>
<li>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li>
</ul>
<p>（4）是否可抢占?</p>
<ul>
<li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。</li>
</ul>
<p>（5）时间片轮转调度算法的优缺点</p>
<ul>
<li>优点：公平：响应快，适用于分时操作系统，不会导致饥饿</li>
<li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</li>
</ul>
<p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130212553334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.当时间片大小为2时：<img src="https://img-blog.csdnimg.cn/20201130212649602.png" alt="在这里插入图片描述"><br>时刻流程图：<br>（1）0-5时刻（2）6-11时刻（3）12-16时刻<br><img src="https://img-blog.csdnimg.cn/20201130212749185.png" alt="在这里插入图片描述"><br>2.当时间片大小为5时：<br><img src="https://img-blog.csdnimg.cn/20201130212856809.png" alt="在这里插入图片描述"><br>同一道例题，我们对比用先来先服务调度算法<br><img src="https://img-blog.csdnimg.cn/20201130212939750.png" alt="在这里插入图片描述"></p>
<blockquote>
<ul>
<li>我们发现：如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li>
<li>如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</li>
</ul>
</blockquote>
<p>（6）时间片轮转调度算法概述<br><img src="https://img-blog.csdnimg.cn/2020113021310935.png" alt="在这里插入图片描述"><br><strong>五. 优先级调度算法</strong></p>
<p>（1）算法思想</p>
<ul>
<li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
</ul>
<p>（2）算法规则</p>
<ul>
<li>每个作业（进程）有各自的优先级，调度时选择优先级最高的作业&#x2F;进程</li>
</ul>
<p>（3）用于作业（进程）调度</p>
<ul>
<li>既可以用与作业调度，也可以用于进程调度。甚至还会用于I&#x2F;O调度。</li>
</ul>
<p>（4）是否可抢占?</p>
<ul>
<li>抢占式，非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可。而抢占式还需要在就绪队列变化时，检查是否会发生抢占。</li>
</ul>
<p>（5）优先级调度算法的优缺点</p>
<ul>
<li>优点：用优先级区分紧急程度，重要程度，适合于实时操作系统。可灵活的调整对各种作业（进程）的偏好程度。</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。</li>
</ul>
<p>例题：<br><img src="https://img-blog.csdnimg.cn/20201130213317568.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130213344547.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201130213417756.png" alt="在这里插入图片描述"><br>（6）优先级调度算法概述<br><img src="https://img-blog.csdnimg.cn/20201130213614701.png" alt="在这里插入图片描述"><br>思考：<br><img src="https://img-blog.csdnimg.cn/20201130213647557.png" alt="在这里插入图片描述"><br><strong>六. 多级反馈队列调度算法（简述）</strong><br><img src="https://img-blog.csdnimg.cn/20201130213738863.png" alt="在这里插入图片描述"><br>例题：<br><img src="https://img-blog.csdnimg.cn/20201130213856668.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130213937102.png" alt="在这里插入图片描述"></p>
<h4 id="14-进程同步与进程互斥"><a href="#14-进程同步与进程互斥" class="headerlink" title="14. 进程同步与进程互斥"></a>14. 进程同步与进程互斥</h4><p><img src="https://img-blog.csdnimg.cn/20201130214104149.png" alt="在这里插入图片描述"><br><strong>什么是进程同步?</strong></p>
<p>我们来看一个管道通信的例子：<br><img src="https://img-blog.csdnimg.cn/20201130214341266.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>异步性是指：各并发执行的进程以各自独立的，不可预知的速度向前推进</p>
</blockquote>
<ul>
<li>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。</li>
<li>进程间的直接制约关系就是源于它们之间的相互合作。</li>
</ul>
<p><strong>什么是进程互斥?</strong><br><strong>进程的并发需要共享的支持，各个并发执行的进程不可避免地需要共享一些系统资源。</strong><br><img src="https://img-blog.csdnimg.cn/20201130214558494.png" alt="在这里插入图片描述"><br>对临界资源地互斥访问，可以在逻辑上分为如下四个部分：<br>1.进入区 2.临界区 3.退出区 4.剩余区</p>
<blockquote>
<p>注意：<br>临界区是进程中访问临界资源的代码段<br>进入区和退出区是负责实现互斥的代码段 </p>
</blockquote>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：<br><img src="https://img-blog.csdnimg.cn/20201130214717696.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130214754398.png" alt="在这里插入图片描述"></p>
<h4 id="15-生产者消费者问题"><a href="#15-生产者消费者问题" class="headerlink" title="15. 生产者消费者问题"></a>15. 生产者消费者问题</h4><p>问题描述：</p>
<blockquote>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（这里的产品理解为某种数据）</p>
</blockquote>
<p>1.整理思路<br>（1）生产者，消费者共享一个初始为空，大小为n的缓冲区。<br>如图：缓冲区的大小为5<br><img src="https://img-blog.csdnimg.cn/20201130215058140.png" alt="在这里插入图片描述"><br>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p>
<p>（2）如果缓冲区已经满了，生产者进程依然向缓冲区里写数据，此时生产者进程必须等待，当缓冲区中有空的时候才能向缓冲区里写数据。<br><img src="https://img-blog.csdnimg.cn/20201130215223162.png" alt="在这里插入图片描述"><br>（3）只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。<br><img src="https://img-blog.csdnimg.cn/20201130215336495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（4）缓冲区是临界资源，各进程必须互斥地访问。<br><img src="https://img-blog.csdnimg.cn/20201130215509458.png" alt="在这里插入图片描述"><br>2.关系分析<br><img src="https://img-blog.csdnimg.cn/20201130215623641.png" alt="在这里插入图片描述"></p>
<ul>
<li>当生产者进程向缓冲区放入一个产品后，此时信号量需要执行一个V操作</li>
<li>当消费者进程在缓冲区取走一个产品前，此时信号量需要执行一个P操作</li>
</ul>
<p>3.代码实现<br><img src="https://img-blog.csdnimg.cn/20201130215737664.png" alt="在这里插入图片描述"><br>实现两对同步关系：<br><img src="https://img-blog.csdnimg.cn/20201130215814431.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为缓冲区是临界资源，各进程必须互斥地访问，所以我们还需要设置互斥信号量</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201130215918585.png" alt="在这里插入图片描述"><br>4. 代码分析<br>执行V操作的进程会唤醒对应执行P操作的进程：<br><img src="https://img-blog.csdnimg.cn/20201130220006653.png" alt="在这里插入图片描述"><br><strong>思考：能否改变相邻P，V操作的顺序?</strong><br><img src="https://img-blog.csdnimg.cn/20201130220054407.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130220153459.png" alt="在这里插入图片描述"></p>
<h4 id="16-读者与写者问题"><a href="#16-读者与写者问题" class="headerlink" title="16. 读者与写者问题"></a>16. 读者与写者问题</h4><p>问题描述：</p>
<blockquote>
<p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致不一致的错误。</p>
</blockquote>
<p>因此要求：<br>（1）允许多个读者可以同时对文件执行读操作<br>（2）只允许一个写者往文件中写信息<br>（3）任意写者在完成写操作之前不允许其他读者或写者工作<br>（4）写者执行写操作前，应让己有的读者和写者全部退出</p>
<p>注意：</p>
<ul>
<li>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据。</li>
<li>读进程与写进程同时共享数据，可能导致读出的数据不一致的问题。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020113022041482.png" alt="在这里插入图片描述"><br>如果两个写进程同时共享数据，可能导致数据错误覆盖的问题</p>
<p>1.关系分析<br><img src="https://img-blog.csdnimg.cn/20201130220524804.png" alt="在这里插入图片描述"><br>2.如何实现<br><img src="https://img-blog.csdnimg.cn/20201130220617786.png" alt="在这里插入图片描述"><br>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能饿死。因此，这种算法中，读进程是优先的。</p>
<p>那么如何解决写进程饿死的状态呢，我们来看代码：<br><img src="https://img-blog.csdnimg.cn/2020113022072152.png" alt="在这里插入图片描述"><br>结论：在这种算法中，连续进入的多个读者可以同时读文件。写者和其他进程不能同时访问文件，写者不会饥饿，但也并不会是真正的写优先，而是相对公平的先来先服务原则。</p>
<blockquote>
<p>读者写者问题为我们解决复杂的互斥问题提供了一个参考思路。其核心思想在于设置了一个计数器（count）用来记录当前正在访问共享文件的读进程数。我们可以用（count）的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对（count）变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现一气呵成，自然应该想到用互斥信号量。</p>
</blockquote>
<h4 id="17-哲学家进餐问题"><a href="#17-哲学家进餐问题" class="headerlink" title="17. 哲学家进餐问题"></a>17. 哲学家进餐问题</h4><p>问题描述：</p>
<blockquote>
<p>一个圆桌上坐着5名哲学家，每两个哲学家之间的桌子上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。<br><img src="https://img-blog.csdnimg.cn/20201130221720966.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>1.关系分析</p>
<ul>
<li>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li>
</ul>
<p>2.整理思路</p>
<ul>
<li>哲学家问题只有互斥关系，但与之前遇到的问题不是的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li>
</ul>
<p>3.解决方案</p>
<ul>
<li>信号量设置。定义互斥信号量数组<code>chopstick[5]=&#123;1,1,1,1,1&#125;</code>用于实现对5个筷子的互斥访问。并对哲学家按<code>0-4</code>编号，哲学家<code>i</code>左边的筷子编号为<code>i</code>，右边的筷子编号为<code>(i+1)%5</code>，每个哲学家吃饭前依次拿起左，右两支筷子。<br><img src="https://img-blog.csdnimg.cn/20201130221927735.png" alt="在这里插入图片描述"></li>
<li>但是如果5个哲学家并发地拿起了自己左手边的筷子，那么会出现的问题是每位哲学家循环等待右边的人放下筷子（阻塞），发生死锁。<br><img src="https://img-blog.csdnimg.cn/2020113022201948.png" alt="在这里插入图片描述"></li>
</ul>
<p>如何防止死锁的发生呢?<br><img src="https://img-blog.csdnimg.cn/20201130222150915.png" alt="在这里插入图片描述"></p>
<p>4.解决思路<br>（1）最多允许四个哲学家同时进餐<br>（2）在每个哲学家进餐之前先判断哲学家是奇数还是偶数</p>
<p>当然，我们还可以这样解决死锁问题：</p>
<blockquote>
<p>我们可以规定仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020113022232081.png" alt="在这里插入图片描述"><br>我们用信号量<code>mutex</code>，保证了哲学家拿筷子这件事必须互斥的进行。即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p>
<h4 id="18-死锁的自述"><a href="#18-死锁的自述" class="headerlink" title="18. 死锁的自述"></a>18. 死锁的自述</h4><p><img src="https://img-blog.csdnimg.cn/20201130222532258.png" alt="在这里插入图片描述"><br>什么是死锁?<br>（1）我们来看一个哲学家进餐的问题<br><img src="https://img-blog.csdnimg.cn/20201130222622674.png" alt="在这里插入图片描述"><br>每位哲学家都在等待自己右边的人放下筷子，这些哲学家进程都因为等待筷子资源而被阻塞，即发生死锁。</p>
<p><strong>那么在并发环境下，各进程因竞争资源而造成的一种相互等待对方手里的资源，导致各进程都被阻塞，都无法向前推进的现象，就是死锁。</strong></p>
<p>死锁，饥饿，死循环的区别：<br><img src="https://img-blog.csdnimg.cn/20201130222819351.png" alt="在这里插入图片描述"><br><strong>死锁产生的必要条件：</strong></p>
<blockquote>
<p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生</p>
</blockquote>
<ol>
<li><p>互斥条件<br>只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子，打印机设备）。像内存，扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这些资源）。</p>
</li>
<li><p>不剥夺条件<br>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
</li>
<li><p>请求和保持条件<br>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
</li>
<li><p>循环等待条件<br>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
</li>
</ol>
<blockquote>
<p>注意： </p>
<ul>
<li>发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）。</li>
<li>如果同类资源大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</li>
</ul>
</blockquote>
<p>什么时候会发生死锁?<br><img src="https://img-blog.csdnimg.cn/20201130223110264.png" alt="在这里插入图片描述"><br><strong>总之，对不可剥夺资源的不合理分配，可能导致死锁</strong></p>
<p>死锁的处理策略：<br><img src="https://img-blog.csdnimg.cn/20201130223156758.png" alt="在这里插入图片描述"><br>预防死锁：<br><img src="https://img-blog.csdnimg.cn/2020113022323250.png" alt="在这里插入图片描述"><br>小结：<br><img src="https://img-blog.csdnimg.cn/20201130223317453.png" alt="在这里插入图片描述"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>sunning
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://suenning.com.cn/2023/02/01/%E6%8A%BD%E6%97%B6%E9%97%B4%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%B8%8B%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/" title="抽时间整理了一下大学操作系统的学习笔记（更新中）">https://suenning.com.cn/2023/02/01/抽时间整理了一下大学操作系统的学习笔记（更新中）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
</div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/01/%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" rel="prev" title="构造哈夫曼树，这一篇就够了">
      <i class="fa fa-chevron-left"></i> 构造哈夫曼树，这一篇就够了
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/01/%E4%BD%A0%E6%83%B3%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E5%9C%A8%E8%BF%99%E9%87%8C/" rel="next" title="你想要了解的黑客入门知识在这里">
      你想要了解的黑客入门知识在这里 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8A%9F%E8%83%BD"><span class="nav-number">1.</span> <span class="nav-text">1. 操作系统的概念及功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="nav-number">2.</span> <span class="nav-text">2. 操作系统的四个特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">3. 操作系统的运行机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-number">4.</span> <span class="nav-text">4. 操作系统的中断与异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%87%AA%E8%BF%B0"><span class="nav-number">5.</span> <span class="nav-text">5. 进程的自述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.</span> <span class="nav-text">6. 进程的状态与转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%8E%9F%E8%AF%AD"><span class="nav-number">7.</span> <span class="nav-text">7. 进程控制及原语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">8. 线程与多线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">9.</span> <span class="nav-text">9. 处理机调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">10.</span> <span class="nav-text">10. 进程调度的时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-number">11.</span> <span class="nav-text">11. 调度算法的评价指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">12. 调度算法思想及规则（上）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">13. 调度算法思想及规则（下）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">14.</span> <span class="nav-text">14. 进程同步与进程互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">15.</span> <span class="nav-text">15. 生产者消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-%E8%AF%BB%E8%80%85%E4%B8%8E%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">16.</span> <span class="nav-text">16. 读者与写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">17.</span> <span class="nav-text">17. 哲学家进餐问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-%E6%AD%BB%E9%94%81%E7%9A%84%E8%87%AA%E8%BF%B0"><span class="nav-number">18.</span> <span class="nav-text">18. 死锁的自述</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sunning</p>
  <div class="site-description" itemprop="description">且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SuenNing1999" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SuenNing1999" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_43964458" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43964458" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1878225963&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunning</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">147k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:14</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  



   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/fireworks.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

