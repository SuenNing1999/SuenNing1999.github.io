<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"suenning.com.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
<meta property="og:type" content="website">
<meta property="og:title" content="橘生淮南">
<meta property="og:url" content="https://suenning.com.cn/page/2/index.html">
<meta property="og:site_name" content="橘生淮南">
<meta property="og:description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sunning">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://suenning.com.cn/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>橘生淮南</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="橘生淮南" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">橘生淮南</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">C语言回顾——指针与链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:49:32" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们把数据类型分为<strong>基本数据类型</strong>与<strong>高级数据类型</strong>，基本数据类型中有：整数，浮点数，字符，指针，数组（已经定义好的），而高级数据类型：像结构体，共用体，枚举等。</p>
<p><strong>链表与数组</strong><br>相同点：<br>链表与数组都是<strong>按顺序存储若干个相同数据类型或相同成员的结构体</strong><br>不同点：<br>●数组各个元素的空间必须连续，而链表各个元素的空间不一定连续，可以分散存储在内存中。<br>●查找数组元素，只需要给出下标，而查找链表元素，需要根据链表的首结点记录地址，顺序查找下去；<br>●删除数组一个非尾部的元素，就要将后面的元素依次向前移动，以保证数组空间的连续性，而删除链表中的一个节点，只需要修改删除节点前后的指针。</p>
<p><strong>【链表的好处】</strong><br>●不需要预先分配存储空间；<br>●分配的空间可以根据程序的需要扩大和缩小；<br>●如果数据的数量不确定，或者经常变化，就要优先考虑使用链表；<br>●节约内存空间；</p>
<p><strong>如果元素个数确定，优先使用数组，如果元素个数不确定，优先使用链表</strong></p>
<p><strong>【链表的存储结构】</strong><br>链表的节点不仅包括元素值，也包括下一个元素的地址（数据域，指针域），即（元素，地址）<br>举个例子：如果链表包含四个元素，而首地址是1255，则：<br><img src="https://img-blog.csdnimg.cn/20200228122929885.png" alt="在这里插入图片描述"></p>
<p><strong>结点的表示：元素值与下一个元素的地址</strong></p>
<p>如上图：地址1255是结点自身的地址，不是指针域，Link1是数据域，1356是指向下一个结点的地址。</p>
<p><strong>【链表是一个结构体】</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;<span class="comment">//存放数据（数据域）</span></span><br><span class="line">struck LinkNode *next; <span class="comment">//存放下一个结点的地址（指针域）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">head</span>;</span><span class="comment">//*head是为了存放链表的首地址，必须声明表头指针</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200228130330685.png" alt="在这里插入图片描述"><br><strong>同数组一样，链表名称即为首地址，不过链表是个指针类型的结构体变量</strong></p>
<p>来个例子：用链表存放三个学生的信息<br><img src="https://img-blog.csdnimg.cn/20200228130643702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>【遍历链表】</strong><br>1.将链表h的各个节点的数据域输出<br>2.从第一个结点开始，只要p非空，就输出这个结点，并将p后移<br><img src="https://img-blog.csdnimg.cn/20200228131957587.png" alt="在这里插入图片描述"><br>我们为什么要把<code>struct Link *h</code>（头结点）作为函数的参数，因为我们在遍历链表的时候的顺序是从头到尾的，然后我们再将<strong>游标指针</strong>指向<strong>头结点</strong><code>struct Link *p=h;</code></p>
<p><strong>【声明链表】</strong><br><img src="https://img-blog.csdnimg.cn/20200228140102480.png" alt="在这里插入图片描述"><br>我们用head&#x3D;NULL;或是用 !head，判断链表为空；用p&#x3D;p-&gt;next；&#x2F;&#x2F;把下一个地址的值赋给本身</p>
<p><strong>【链表的插入操作】</strong><br><strong>当将一个值为x的结点s插入链表中，我们先用malloc函数动态申请内存，再赋值给s，s是插入点的指针；</strong><br><img src="https://img-blog.csdnimg.cn/20200228141211832.png" alt="在这里插入图片描述"><br><strong>【插入到链表的头部】</strong><br><img src="https://img-blog.csdnimg.cn/20200228141515994.png" alt="在这里插入图片描述"><br>如图：头指针*head为1255，当把链表插入到头部后，我们的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=head;<span class="comment">//将s的下一个结点指向head</span></span><br><span class="line">head=s;<span class="comment">//首结点赋值为s的值</span></span><br><span class="line"><span class="comment">//head总是表示头结点，当插入链表后，s变为头结点，所以我们要将s的值还给head</span></span><br></pre></td></tr></table></figure>
<p><strong>【插入到链表的中部】</strong><br><img src="https://img-blog.csdnimg.cn/20200228142700304.png" alt="在这里插入图片描述"><br>假如有一个指针p，p原先保存的地址是1356，而p-&gt;next是1475，但我们当将一个值为x的结点s插入链表中，如图：<br><img src="https://img-blog.csdnimg.cn/20200228142939676.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;<span class="comment">//s指针域指向原先p的指针域</span></span><br><span class="line">p-&gt;next=s;<span class="comment">//插入后，p的指针域指向s</span></span><br></pre></td></tr></table></figure>
<p><strong>【插入到链表的尾部】</strong><br>如何把一个链表插入非空链表尾部？<br><img src="https://img-blog.csdnimg.cn/2020022814325995.png" alt="在这里插入图片描述"><br>我们先要判断尾部！<br>直到p-&gt;next（指针域）为空值时，则到了链表的尾部，这是我们再将链表插入非空链表尾部。<br><img src="https://img-blog.csdnimg.cn/20200228144126133.png" alt="在这里插入图片描述"><br>具体实现：<br><img src="https://img-blog.csdnimg.cn/20200228144437894.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=p-&gt;next;<span class="comment">//如果p不是尾结点就往后移动</span></span><br><span class="line">p-&gt;next=s;<span class="comment">//最后让p的next结点指向p</span></span><br></pre></td></tr></table></figure>
<p><strong>【删除链表的结点】</strong><br><strong>1.【删除表头结点，直接更改头指针head】</strong><br><img src="https://img-blog.csdnimg.cn/20200228145054519.png" alt="在这里插入图片描述"><br>原head是头结点，地址是1255，指针域是1356，当我们删除第一个链表时，现在的head的地址变成1356，指针域是1475。即<code>head=head-&gt;next;</code></p>
<p><strong>2.【删除非表头结点】</strong><br><img src="https://img-blog.csdnimg.cn/20200228145538777.png" alt="在这里插入图片描述"><br>删除前，假设指针p的地址是1475，<strong>pre(p的前驱结点)-&gt;next等价于p，也就是地址1475</strong>，而p-&gt;next&#x3D;&#x3D;1008，当我们删除p的时候，于是<strong>pre(p的前驱结点)-&gt;next</strong>，从指向地址1475变为指向地址1008，即<code>（pre-&gt;next=p-&gt;next)</code>，这时指针p变成野指针，应该释放掉。</p>
<p><strong>【尾插法操作】</strong><br><img src="https://img-blog.csdnimg.cn/20200228150509569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//注意分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="keyword">struct</span> link *<span class="title function_">creat_link</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">h</span>=</span><span class="literal">NULL</span>;<span class="comment">//声明头结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">s</span>;</span><span class="comment">//声明插入结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">r</span>;</span><span class="comment">//声明尾结点</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	s=(<span class="keyword">struct</span> link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> link));<span class="comment">//对s进行动态内存分配</span></span><br><span class="line">	s-&gt;data=arr[i];<span class="comment">//数据域来自数组</span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾插法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是不是空链表</span></span><br><span class="line">	<span class="keyword">if</span>(h==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	h=s;<span class="comment">//将h赋上插入点的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	r-&gt;next=s;<span class="comment">//不是空链表，将尾指针赋上空链表的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	r=s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> link *h)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">p</span>=</span>h;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link</span> *<span class="title">head</span>;</span></span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=(<span class="type">int</span>)(rand()%<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	head=creat_link(arr,<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr values:&quot;</span>\n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);<span class="comment">//输出数组的值</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输出链表的值:\n&quot;</span>);</span><br><span class="line">output(head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>【头插法操作】</strong><br><img src="https://img-blog.csdnimg.cn/20200228154417407.png" alt="在这里插入图片描述"><br><strong>【共用体】</strong><br>●使用共用体，使多个变量共享一块内存<br>●目地是为了节约内存空间</p>
<p><strong>【共用体声明】</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">成员列表....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//共用体使用字节最长的成员所占的内存空间</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：初始化共用体只能给一个值的序列</strong><br><img src="https://img-blog.csdnimg.cn/20200228154950621.png" alt="在这里插入图片描述"><br>另外共用体中不要包含指针成员，因为共用体的成员值很容易发生改变。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">《数据结构》C语言版——循环队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:47:19" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>如果说可以用循环队列解决队列的虚假满的状态，那么什么是虚假满状态？</strong></p>
<p>假设当前顺序队列分配的最大空间是6，当队尾指针从5下标指向6下标时(6下标实际不存在)，说明此时队列已满，然而依然可以进行出队的操作，顺序队不能像顺序栈那样进行存储再分配扩大数组空间，所以队列的实际可用空间并未占满。</p>
<p>循环队列就是将顺序队列构造成为一个环状的队列空间，如图：<br><img src="https://img-blog.csdnimg.cn/20200408231920541.png" alt="在这里插入图片描述"></p>
<p><strong>注意：</strong></p>
<blockquote>
<p>此时当指针front&#x3D;指针rear时，无法判断队列空间是满还是空，有两种解决思路：<br>1.另设一个标志位区分队列空间是满还是空；<br>2.少用一个空间，约定以“队列头指针在队列尾指针的下一位置”作为队列满的状态标志。</p>
</blockquote>
<p>来吧！举个栗子吧，如图：<br>【情况1】<br><img src="https://img-blog.csdnimg.cn/20200408232244129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>初始化，队头指针front，队尾指针rear都指向0下标；<br>当存入数据元素1后，队尾指针rear从0下标指向1下标；<br>当存入数据元素2后，队尾指针rear从1下标指向2下标；<br>当存入数据元素3后，队尾指针rear从2下标指向3下标；<br>当存入数据元素4后，队尾指针rear从3下标指向4下标；<br>…<br>当存入数据元素8后，队尾指针rear从7下标指向0下标；(队列已满)<br>如何判断队头指针front与队尾指针rear重合时，队列是空还是满呢？我们假如用flag来标记队头指针front与队尾指针rear的重合状态，于是规定当flag&#x3D;0时：队列为空；当flag&#x3D;1时，队列为满。</p>
<p>【情况2】<br><img src="https://img-blog.csdnimg.cn/20200408233304879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们把7下标的空间空出不存放数据，当数据元素7进为6下标的空间后，队尾指针rear就指向了为7下标的空间(此时7下标空间是空的)，理论上8个空间只用了7个空间，但在逻辑上我们规定此时队列已满。当rear+1后，队头指针front与队尾指针rear重合，说明此时队列空间逻辑已满，我们先将队头指针所指空间的元素出队，队头指针前移指向1下标，此时再将元素进下标为7的空间，队尾指针rear前移(指向0下标)，当rear+1后，队头指针front与队尾指针rear又重合，说明此时队列空间逻辑又已满，依次循环往复，出队—&gt;队头指针front前移——&gt;后面入队——&gt;队尾指针rear前移(判断条件是rear+1后，队头指针front与队尾指针rear是否重合，不重合则可继续入队)。</p>
<p>但是，计算机是没有环状的存储空间的，依然是以线性存储的方式，那计算机如何判断什么时候队尾指针再次与队头指针重合呢？</p>
<p><strong>—————OK！那就是：进行模运算—————</strong></p>
<p>具体模运算是怎么实现的，文字显得苍白无力，还是那句话，把代码跑起来，慢慢体会！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 8<span class="comment">//定义队列初始化存放8个数据元素</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElmeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出顺序队列的结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElmeType *base;<span class="comment">//指针base指向有效的队列空间</span></span><br><span class="line">	<span class="type">int</span>      front;<span class="comment">//队头指针</span></span><br><span class="line">	<span class="type">int</span>      rear;<span class="comment">//队尾指针指向下一个有效的空间</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	Q-&gt;base=(ElmeType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElmeType)*MAXSIZE);<span class="comment">//开辟队列空间</span></span><br><span class="line">	assert(Q-&gt;base!=<span class="literal">NULL</span>);<span class="comment">//断言——是否开辟空间成功</span></span><br><span class="line">	Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队头指针和队尾指针都指向队列的0下标,此时队列为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue *Q,ElmeType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//数据入队后,队尾指针从当前空间指向下一个有效的空间,此时称队尾指针是伪指针;</span></span><br><span class="line"><span class="comment">//当伪指针所指下标+1后正好等于队列空间容量时,此时我们希望伪指针可以重新指向队头,而不是出界,于是进行模运算;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(Q-&gt;rear+1)%MAXSIZE——若模为0,则伪指针恰好指向队列的最后一个有效空间,我们需要让此时的伪指针重新指向0下标而不是最后一个有效空间;</span></span><br><span class="line"><span class="comment">//(始终都要将队列最后一个有效空间空出)循环开始:</span></span><br><span class="line">	<span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)<span class="comment">//若伪指针所指下标+1与队头指针指向相同的下标,此时判断为队列逻辑已满</span></span><br><span class="line">	<span class="keyword">return</span>;<span class="comment">//返回,理论上队列保留了队列最后一个有效空间</span></span><br><span class="line">	Q-&gt;base[Q-&gt;rear]=x;<span class="comment">//否则队列逻辑不满,继续在队尾指针所指下标进行入队,入队完成后,队尾指针又从当前空间指向下一个有效的空间</span></span><br><span class="line">	Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//当逻辑空间满后,模运算实现队尾指针重新指向0下标而不是最后一个有效空间;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示顺序队列元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队列中存放的元素:&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=Q-&gt;front;i!=Q-&gt;rear;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Q-&gt;base[i]);<span class="comment">//依次打印队头指针所指下标中的数据到队尾指针所指下标中的数据</span></span><br><span class="line">		i=(i+<span class="number">1</span>)%MAXSIZE;<span class="comment">//循环打印,7下标不能打印,重新回到0下标(循环时,队尾下标-队头下标=-1)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//出队一个元素,队头指针指向下一个有效的数据元素</span></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队头队尾指向相同,队列为空</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">//队头指针循环,模运算实现队头指针重新指向0下标而不是最后一个有效空间;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取队头元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(Queue *Q,ElmeType *v)</span><span class="comment">//指针v带回队头元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要获取队头,前提是队列不空</span></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队列为空</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	*v=Q-&gt;base[Q-&gt;front];<span class="comment">//必须在base所指的空间里取元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序队列的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q-&gt;rear - Q-&gt;front);</span><br><span class="line">	<span class="comment">//下标0开始存放数据,进队后,队尾指针指向下一个有效的新空间</span></span><br><span class="line">	<span class="comment">//队列中元素的个数正好是队尾队头所指的下标之差</span></span><br><span class="line">	<span class="comment">//但是当队列逻辑空间满后,再存储数据需要先出队,再进行入队,此时队尾队头所指的下标之差为-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队列置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(Q-&gt;base);<span class="comment">//释放base所指的队列空间</span></span><br><span class="line">	Q-&gt;base=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Queue Q;</span><br><span class="line">	ElmeType e;<span class="comment">//定义队头元素</span></span><br><span class="line">	InitQueue(&amp;Q);<span class="comment">//&amp;Q是传入队列的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将1,2,3,4,5,6,7,8依次入队\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		EnQueue(&amp;Q,i);</span><br><span class="line">	&#125;</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;进行出队\n&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将元素10入队\n&quot;</span>);</span><br><span class="line">	EnQueue(&amp;Q,<span class="number">10</span>);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;进行出队\n&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将元素20入队\n&quot;</span>);</span><br><span class="line">	EnQueue(&amp;Q,<span class="number">20</span>);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ClearQueue(&amp;Q);</span><br><span class="line">	DestroyQueue(&amp;Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200409130442630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E6%A0%88%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E6%A0%88%E9%93%BE/" class="post-title-link" itemprop="url">《数据结构》C语言版——栈链</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:47:48" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>顺序栈是分配一段连续的内存空间，需要两个指针，即指针top与指针base，指针top指向栈顶，指针base指向栈底，而<strong>链栈</strong>每个结点的地址是不连续的，所以只需要一个栈顶指针即可，相比于单链表，<strong>栈链的操作只能在栈顶进行。</strong></p>
<p>入栈前，旧的栈顶结点是新入栈结点的后继结点，栈顶指针重新指向新入栈的结点；<br>出栈前，新的栈顶结点是即将出栈结点的后继结点，栈顶指针指向出栈结点的后继(即指向新的栈顶结点，把出栈结点释放)；</p>
<p>空口无凭，纸上的概念都显得苍白无力，让我们把代码开起来，慢慢细品！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言——如果条件返回错误，则终止程序执行</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的栈链</span></span><br><span class="line"><span class="comment">/*给出结点结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域(指向下一个结点的地址)</span></span><br><span class="line">&#125;ListNode,*pNode;<span class="comment">//定义结点类型,定义结点的指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出链栈结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	pNode top;<span class="comment">//指针top指向栈顶元素</span></span><br><span class="line">	<span class="type">size_t</span> size;<span class="comment">//结点的个数</span></span><br><span class="line">&#125;ListStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s-&gt;top=(StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); <span class="comment">//栈顶指针指向新申请的结点  </span></span><br><span class="line">	assert(s-&gt;top!=<span class="literal">NULL</span>);<span class="comment">//判断申请空间是否为空</span></span><br><span class="line">	s-&gt;top = <span class="literal">NULL</span>;<span class="comment">//栈顶指针初始化</span></span><br><span class="line">	s-&gt;size=<span class="number">0</span>;<span class="comment">//栈中元素初始化为0个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链栈是否为空*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmptyStack</span><span class="params">(ListStack *s)</span><span class="comment">//给出链栈的位置</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;size == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(ListStack *s, ElemType x)</span><span class="comment">//给出链栈的位置和即将入栈的元素</span></span><br><span class="line">&#123;</span><br><span class="line">	StackNode *p=(StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));<span class="comment">//指针p指向申请的新结点</span></span><br><span class="line">	assert(p!=<span class="literal">NULL</span>);</span><br><span class="line">	p-&gt;data = x;<span class="comment">//入栈的元素保存新结点的数据域</span></span><br><span class="line">    p-&gt;next = s-&gt;top;<span class="comment">//新结点的指针域保存栈顶指针的地址</span></span><br><span class="line">    s-&gt;top = p;<span class="comment">//栈顶指针重新指向新结点</span></span><br><span class="line">	s-&gt;size++;<span class="comment">//栈中元素增加</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PopStack</span><span class="params">(ListStack *s, ElemType *v)</span></span><br><span class="line">&#123;</span><br><span class="line">		StackNode *p=s-&gt;top;<span class="comment">//指针p指向栈顶</span></span><br><span class="line">		*v=s-&gt;top-&gt;data;<span class="comment">//指针v带回栈顶元素</span></span><br><span class="line">		s-&gt;top=s-&gt;top-&gt;next;<span class="comment">//栈顶指针指向栈顶结点的后继结点</span></span><br><span class="line">		<span class="built_in">free</span>(p);<span class="comment">//释放栈顶结点</span></span><br><span class="line">	    s-&gt;size--;<span class="comment">//栈中元素减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示链栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">		StackNode *p=s-&gt;top;<span class="comment">//指针p指向栈顶</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链栈中的数据元素:&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//栈不为空,执行</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,p-&gt;data);</span><br><span class="line">			p = p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">		&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取栈顶指针*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTopStack</span><span class="params">(ListStack *s,ElemType *v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*v=s-&gt;top-&gt;data;<span class="comment">//指针v带回栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈长*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LengthStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清空栈链*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	StackNode *p=s-&gt;top;<span class="comment">//指针p指向栈顶结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s-&gt;top=p-&gt;next;<span class="comment">//栈顶指针指向栈顶结点的后继结点</span></span><br><span class="line">		<span class="built_in">free</span>(p);<span class="comment">//释放栈顶结点</span></span><br><span class="line">		p=s-&gt;top;<span class="comment">//指针p重新指向栈顶结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top = <span class="literal">NULL</span>;<span class="comment">//否则栈顶指针置空</span></span><br><span class="line">	s-&gt;size = <span class="number">0</span>;<span class="comment">//栈中长度置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁栈链*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(ListStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	ClearStack(s);</span><br><span class="line">	<span class="built_in">free</span>(s-&gt;top);<span class="comment">//销毁最初创建的结点</span></span><br><span class="line">	s-&gt;top=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		ListStack  st;</span><br><span class="line">		ElemType e;</span><br><span class="line">		InitStack(&amp;st);</span><br><span class="line">		<span class="keyword">if</span>(IsEmptyStack(&amp;st))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;栈为空,初始化成功\n\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;栈非空!\n\n&quot;</span>);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;入栈\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			PushStack(&amp;st,i);</span><br><span class="line">		&#125;</span><br><span class="line">	    ShowStack(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="type">int</span> k=LengthStack(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈的长度为:%d \n\n&quot;</span>,k);</span><br><span class="line">		GetTopStack(&amp;st,&amp;e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈顶元素为:%d \n&quot;</span>,e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  		<span class="built_in">printf</span>(<span class="string">&quot;出栈\n&quot;</span>);</span><br><span class="line">		PopStack(&amp;st,&amp;e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">		ShowStack(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		PopStack(&amp;st,&amp;e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">		ShowStack(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		PopStack(&amp;st,&amp;e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">		ShowStack(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		PopStack(&amp;st,&amp;e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">		ShowStack(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		PopStack(&amp;st,&amp;e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">		ShowStack(&amp;st);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		PopStack(&amp;st,&amp;e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈的元素为:%d \n&quot;</span>,e);</span><br><span class="line">		ShowStack(&amp;st);</span><br><span class="line">		ClearStack(&amp;st);</span><br><span class="line">		DestroyStack(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200407203758677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88/" class="post-title-link" itemprop="url">《数据结构》C语言版——顺序栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:46:44" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>栈是限定仅在表面进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶，相应地，表头端称为栈底，不含元素的空表称为空栈。</p>
<p>顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置，通常的习惯做法是以top&#x3D;0表示空栈。</p>
<p>话不多说，把代码跑起来！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的顺序栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 8<span class="comment">//初始化顺序栈可以存放8个数据元素</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序栈的结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType *base;<span class="comment">//指针base指向开辟的栈空间</span></span><br><span class="line">	<span class="type">int</span> capacity;<span class="comment">//定义顺序栈的容量(最大容量)</span></span><br><span class="line">	<span class="type">int</span> top;<span class="comment">//定义栈顶指针(同时表示当前栈中的元素个数)</span></span><br><span class="line">&#125;SeqStack;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SeqStack *s)</span><span class="comment">//给出顺序栈的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//申请顺序栈的空间(元素类型)</span></span><br><span class="line">	s-&gt;base=(ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*STACK_INIT_SIZE);</span><br><span class="line">	assert(s-&gt;base!=<span class="literal">NULL</span>);<span class="comment">//不为空时空间申请成功</span></span><br><span class="line">	s-&gt;capacity=STACK_INIT_SIZE;<span class="comment">//栈的容量为初始化大小</span></span><br><span class="line">	s-&gt;top=<span class="number">0</span>;<span class="comment">//栈顶指针top指向0下标的位置,表示此时栈中一个数据元素都没有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(SeqStack *s)</span><span class="comment">//入栈判断栈是否满</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;top &gt;= s-&gt;capacity;<span class="comment">//指针top所指的下标正好与栈的容量相等,此时栈已满</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SeqStack *s)</span><span class="comment">//出栈判断栈是否空</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;top==<span class="number">0</span>;<span class="comment">//指针top所指的下标正好是0下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(SeqStack *s,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsFull(s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈空间已满,%d不能入栈\n&quot;</span>,x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;base[s-&gt;top]=x;<span class="comment">//当前指针top所指的位置来存放数据,指针base指向真实的栈空间</span></span><br><span class="line">	s-&gt;top++;<span class="comment">//指针top指向下一个可用的栈空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈空间已空,不能出栈\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top--;<span class="comment">//指针top指向上一个可用的栈空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取栈顶元素*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SeqStack *s,ElemType *v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈空间已空,不能取栈顶元素\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*v=s-&gt;base[s-&gt;top<span class="number">-1</span>];<span class="comment">//把栈顶元素存放在元素v的地址里,传回元素v</span></span><br><span class="line"><span class="comment">//因为入栈一个元素后,指针top就指向下一个空的栈空间,所以取栈顶元素,应该读取上一个栈空间里的元素,即用top-1的结果作为base的下标</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示栈中元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=s-&gt;top<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="comment">//因为入栈一个元素后,指针top就指向下一个空的栈空间,所以显示元素时,应该读取上一个栈空间里的元素</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s-&gt;base[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*栈的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> s-&gt;top;<span class="comment">//返回0则为空栈,返回1则栈的长度为1(此时栈中有1个元素)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;top=<span class="number">0</span>;<span class="comment">//栈顶指针指向0下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁栈*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(SeqStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(s-&gt;base);<span class="comment">//释放栈空间</span></span><br><span class="line">	s-&gt;base=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">	s-&gt;capacity=s-&gt;top=<span class="number">0</span>;<span class="comment">//栈容量,栈中的数据元素都置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SeqStack st;<span class="comment">//定义一个名为st的顺序栈</span></span><br><span class="line">	InitStack(&amp;st);</span><br><span class="line">	ElemType  v;<span class="comment">//定义临时元素v</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;入栈\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">	Push(&amp;st,i);<span class="comment">//把1,2,3,4,5依次入栈	</span></span><br><span class="line">	&#125;</span><br><span class="line">	Show(&amp;st);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈的长度为%d\n&quot;</span>,Length(&amp;st));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	GetTop(&amp;st,&amp;v);<span class="comment">//给出临时元素v的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d 是栈顶元素\n&quot;</span>,v);<span class="comment">//临时元素v就是栈顶元素,实现取栈顶元素</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出栈\n&quot;</span>);</span><br><span class="line">	Pop(&amp;st);</span><br><span class="line">	Show(&amp;st);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈的长度为%d\n&quot;</span>,Length(&amp;st));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;清除栈\n&quot;</span>);</span><br><span class="line">	Clear(&amp;st);</span><br><span class="line">	Show(&amp;st);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈的长度为%d\n&quot;</span>,Length(&amp;st));</span><br><span class="line">	Destory(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200406205941803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">《数据结构》C语言版——认识树和二叉树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:43:57" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>一.树的定义</strong><br>从数据结构角度看，树包含n（n≥0）个结点，当n&#x3D;0时，称为空树；非空树的定义如下： T&#x3D;(D，R)<br>其中，D为树中结点的有限集合，关系R满足以下条件：<br>●有且仅有一个结点d0∈D，它对于关系R来说没有前驱结点，结点d0称作树的根结点<br>●除根结点d0外，D中的每个结点有且仅有一个前驱结点，但可以有多个后继结点<br>●D中可以有多个终端结点</p>
<p>假如我们有一棵树T&#x3D;(D，R)，其中：D&#x3D;{A，B，C，D，E，F，G，H}，R&#x3D;{r}<br>r&#x3D;{&lt;A,B&gt;，&lt;A,C&gt;，&lt;A,D&gt;，&lt;C,E&gt;，&lt;C,F&gt;，&lt;D,G&gt;，&lt;E,H&gt;}，那我们该如何画出其逻辑结构图呢？</p>
<blockquote>
<p>解：A是根结点，其余结点分成三个互不相交的子集：　 T1&#x3D;{B}，T2&#x3D;{C，E，F，H}，T3&#x3D;{D，G}； T1、T2、T3都是根结点A的子树，且各自本身也是一棵树</p>
</blockquote>
<p>于是我们得到了逻辑结构图，如下：<br><img src="https://img-blog.csdnimg.cn/20200507202539574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>说明：树中结点之间的关系应为有向关系，在上图中，结点之间的连线即分支线都是有向的，默认箭头向下的。</p>
<p><strong>二.树的逻辑结构表示</strong><br>1.树形表示法：使用一棵倒置的树表示树结构，非常直观和形象<br>2.文氏图表示法：使用集合以及集合的包含关系描述树结构，如图：<br><img src="https://img-blog.csdnimg.cn/20200507202810117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.凹入表示法：使用线段的伸缩关系描述树结构<br><img src="https://img-blog.csdnimg.cn/20200507202906278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.括号表示法：将树的根结点写在括号的左边，除根结点之外的其余结点写在括号中并用逗号分隔<br><img src="https://img-blog.csdnimg.cn/20200507203030299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>三.树的基本术语</strong><br>1.什么是结点的度？</p>
<blockquote>
<p>树中每个结点具有的子树数或者后继结点数称为该结点的度</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507203857313.png" alt="在这里插入图片描述"><br>2.什么是树的度？</p>
<blockquote>
<p>树中所有结点的度的最大值称之为树的度</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507203945890.png" alt="在这里插入图片描述"><br>3.什么是分支结点？</p>
<blockquote>
<p>度大于0的结点称为分支结点或非终端结点。 度为1的结点称为单分支结点，度为2的结点称为双分支结点，依次类推…</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204105919.png" alt="在这里插入图片描述"><br>4.什么是叶子节点？</p>
<blockquote>
<p>度为零的结点称为叶子结点或终端结点</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204212515.png" alt="在这里插入图片描述"><br>5.什么是孩子结点？</p>
<blockquote>
<p>一个结点的后继称之为该结点的孩子结点</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204308413.png" alt="在这里插入图片描述"><br>6.什么是双亲结点？</p>
<blockquote>
<p>一个结点称为其后继结点的双亲结点</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204445323.png" alt="在这里插入图片描述"><br>7.什么是子孙结点？</p>
<blockquote>
<p>一个结点的子树中除该结点外的所有结点称之为该结点的子孙结点</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204524721.png" alt="在这里插入图片描述"><br>8.什么是祖先结点？</p>
<blockquote>
<p>从树根结点到达某个结点的路径上通过的所有结点称为该结点的祖先结点（不含该结点自身）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204619245.png" alt="在这里插入图片描述"><br>9.什么是兄弟结点？</p>
<blockquote>
<p>具有同一双亲的结点互相称之为兄弟结点</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204700667.png" alt="在这里插入图片描述"><br>10.什么是结点层次？</p>
<blockquote>
<p>树具有一种层次结构，根结点为第一层，其孩子结点为第二层，如此类推得到每个结点的层次</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/202005072047591.png" alt="在这里插入图片描述"><br>11.什么是树的高度？</p>
<blockquote>
<p>树中结点的最大层次称为树的高度或深度</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204836660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>12.什么是森林？</p>
<blockquote>
<p>零棵或多棵互不相交的树的集合称为森林</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200507204918807.png" alt="在这里插入图片描述"><br><strong>四.树的性质</strong><br>性质1：  树中的结点数等于所有结点的度数加1</p>
<p>性质2：度为m的树中第i层上至多有m^(i-1)个结点，这里应有i≥1</p>
<blockquote>
<p>推广：当一棵m次树的第i层有m^(i-1)个结点（i≥1）时，称该层是满的，若一棵m次树的所有叶子结点在同一层，除该层外其余每一层都是满的，称为满m次树。显然，满m次树是所有相同高度的m次树中结点总数最多的树。也可以说，对于n个结点，构造的m次树为满m次树或者接近满m次树，此时树的高度最小。</p>
</blockquote>
<p>让我们来道经典例题巩固一下：<br>若一棵三次树中度为3的结点为2个，度为2的结点为1个，度为1的结点为2个，则该三次树中总的结点个数和度为0的结点个数分别是多少？</p>
<blockquote>
<p>解：设该三次树中总结点个数、度为0的结点个数、度为1的结点个数、度为2的结点个数和度为3的结点个数分别为n、n0、n1、n2和n3。<br>显然，每个度为i的结点在所有结点的度数之和中贡献i个度。依题意有：n1&#x3D;2，n2&#x3D;1，n3&#x3D;2。<br>由树的性质1可知：n &#x3D; 所有结点的度数之和+1　<br>                                  &#x3D; 0×n0+1×n1+2×n2+3×n3+1<br>                                  &#x3D; 1×2+2×1+3×2+1<br>                                  &#x3D;11 　　<br>又因为n&#x3D;n0+n1+n2+n3 　　<br>即：n0&#x3D;n-n1-n2-n3&#x3D;11-2-1-2&#x3D;6 　　<br>所以该三次树中总的结点个数和度为0的结点个数分别是11和6。</p>
</blockquote>
<p><strong>五.二叉树</strong><br><strong>1.二叉树的递归定义</strong><br>二叉树或者是一棵空树，或者是一棵由一个根结点和两棵互不相交的分别称做根结点的左子树和右子树所组成的非空树，左子树和右子树又同样都是一棵二叉树。</p>
<blockquote>
<p>注意：二叉树与度为2的树是不同的！<br>度为2的树至少有3个结点，而二叉树的结点数可以为0；<br>度为2的树不区分子树的次序，而二叉树中的每个结点最多有两个孩子结点，且必须要区分左右子树，即使在结点只有一棵子树的情况下也要明确指出该子树是左子树还是右子树</p>
</blockquote>
<p><strong>2.二叉树的5种形态</strong><br><img src="https://img-blog.csdnimg.cn/20200507214311919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3.二叉树的性质</strong><br>性质1：非空二叉树上叶结点数等于双分支结点数加1，即n0&#x3D;n2+1<br>（我们约定：二叉树上叶结点数为n0，单分支结点数为n1，双分支结点数为n2）</p>
<blockquote>
<p>例如：一棵二叉树中总结点个数为200，其中单分支结点个数为19，求其叶子结点个数。<br>解：n&#x3D;200，n1&#x3D;19。又n&#x3D;n0+n1+n2，由性质1得，n2&#x3D;n0-1，所以有： n&#x3D;2n0-1+n1<br>即n0&#x3D;(n-n1+1)&#x2F;2&#x3D;91，所以这样的二叉树中叶子结点个数为91。</p>
</blockquote>
<p>性质2：非空二叉树上第i层上至多有2^(i-1)个结点，这里应有i≥1</p>
<p>性质3：高度为h的二叉树至多有2^h-1个结点（h≥1）</p>
<p>性质4：对完全二叉树中编号为i的结点（1≤i≤n，n≥1，n为结点数）有：<br>（1）若i≤|n&#x2F;2|，即2i≤n，则编号为i的结点为分支结点，否则为叶子结点；<br>（2）若n为奇数，则每个分支结点都既有左孩子结点，也有右孩子结点。若n为偶数，则编号最大的分支结点只有左孩子结点，没有右孩子结点，其余分支结点都有左、右孩子结点。<br>（3）若编号为i的结点有左孩子结点，则左孩子结点的编号为2i；若编号为i的结点有右孩子结点，则右孩子结点的编号为(2i+1)。<br>（4）除树根结点外,若一个结点的编号为i，则它的双亲结点的编号为|i&#x2F;2|，也就是说，当i为偶数时，其双亲结点的编号为i&#x2F;2，它是双亲结点的左孩子结点，当i为奇数时，其双亲结点的编号为(i-1)&#x2F;2，它是双亲结点的右孩子结点。</p>
<p><strong>4.满二叉树</strong><br>在一棵二叉树中，当第i层的结点数为2^(i-1)个时，则称此层的结点数是满的，当一棵二叉树中的每一层都满时，且叶子结点在同一层上，则称此树为满二叉树。<br><img src="https://img-blog.csdnimg.cn/20200507224023729.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>满二叉树特性：除叶子结点以外的其他结点的度皆为2。</p>
</blockquote>
<p><strong>5.完全二叉树</strong><br>在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干个结点，则称此树为完全二叉树。<br><img src="https://img-blog.csdnimg.cn/20200507224045349.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>完全二叉树特性：二叉树中至多只有最下边两层结点的度数小于2。</p>
</blockquote>
<p><strong>6.层序编号</strong><br>从根结点为1开始，按照层次从小到大、同一层从左到右的次序顺序编号。如图：<br><img src="https://img-blog.csdnimg.cn/20200507215323561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>六.二叉树的遍历</strong><br>二叉树的遍历运算是<strong>指按一定的次序访问树中的所有结点，使每个结点恰好被访问一次。其中遍历次序保证了二叉树上每个结点均被访问一次且仅有一次。</strong></p>
<p> <strong>1.先序遍历</strong><br>① 访问根结点<br>② 先序遍历左子树<br>③ 先序遍历右子树</p>
<p> <strong>2.中序遍历</strong><br>① 中序遍历左子树<br>② 访问根结点<br>③ 中序遍历右子树</p>
<p> <strong>3.后序遍历</strong><br>① 后序遍历左子树<br>② 后序遍历右子树<br>③ 访问根结点</p>
<p> <strong>4.层次遍历</strong><br>层次遍历是从根结点出发，按照从上向下，同一层从左向右的次序访问所有的结点，采用层次遍历得到的访问结点序列称为层次遍历序列。<br>层次遍历序列的特点：其第一个元素值为二叉树中根结点值。</p>
<p><strong>七.二叉树的存储结构</strong><br>1.顺序存储结构<br><img src="https://img-blog.csdnimg.cn/20200507215730437.png" alt="在这里插入图片描述"><br>用一组连续的存储单元存放二叉树中的结点<br><img src="https://img-blog.csdnimg.cn/20200507215745479.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200507215810488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用“#”补齐为一个完整二叉树<br><img src="https://img-blog.csdnimg.cn/20200507215900468.png" alt="在这里插入图片描述"><br>2.二叉链存储结构<br>链表中的<strong>每个结点包含两个指针，分别指向对应结点的左孩子和右孩子</strong>（注意在树的孩子兄弟链表存储结构中，每个结点的两个指针分别指向对应结点的第一个孩子和下一个兄弟）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span></span></span><br><span class="line"><span class="class">&#123;</span>  ElemType data;			<span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>	<span class="comment">//指针域</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure>
<p>●data表示数据域，用于存储放入结点值（默认情况下为单个字母）<br>●lchild 和 rchild 分别表示左指针域和右指针域，分别存储左孩子和右孩子结点（即左、右子树的根结点）的存储地址<br>●当某结点不存在左或右孩子时，其 lchild 或 rchild 指针域取特殊值NULL<br><img src="https://img-blog.csdnimg.cn/20200507220212290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>八.二叉树基本运算实现算法</strong><br>采用括号表示法表示的二叉树字符串str，且每个结点的值是单个字符。<br>用ch扫描str，其中只有4类字符，各类字符的处理方式：<br>1.若ch&#x3D;’(‘：<strong>表示前面刚创建的p结点存在着孩子结点，需将其进栈</strong>，以便建立它和其孩子结点的关系。然后开始处理该结点的左孩子，因此置k&#x3D;1，表示其后创建的结点将作为这个结点（栈顶结点）的左孩子结点；</p>
<p>2.若ch&#x3D;’)’：<strong>表示以栈顶结点为根结点的子树创建完毕</strong>，将其退栈；</p>
<p>3.若ch&#x3D;’,’：<strong>表示开始处理栈顶结点的右孩子结点</strong>，置k&#x3D;2；</p>
<p>4.其他情况：只能是单个字符，表示要创建一个新结点p，根据k值建立p结点与栈顶结点之间的联系，当k&#x3D;1时，表示p结点作为栈顶结点的左孩子结点，当k&#x3D;2时，表示p结点作为栈顶结点的右孩子结点。</p>
<p><strong>（1）创建二叉树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBTree</span><span class="params">(BTNode * &amp;bt,<span class="type">char</span> *str)</span></span><br><span class="line">&#123;  BTNode *St[MaxSize],*p=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="type">int</span> top=<span class="number">-1</span>,k,j=<span class="number">0</span>;</span><br><span class="line">   <span class="type">char</span> ch;</span><br><span class="line">   bt=<span class="literal">NULL</span>;		<span class="comment">//建立的二叉树初始时为空</span></span><br><span class="line">   ch=str[j];</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span> (ch!=<span class="string">&#x27;\0&#x27;</span>)			    <span class="comment">//str未扫描完时循环</span></span><br><span class="line">   &#123;	<span class="keyword">switch</span>(ch)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:top++;St[top]=p;k=<span class="number">1</span>; <span class="keyword">break</span>;    <span class="comment">//为左孩子结点</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:top--;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:k=<span class="number">2</span>; <span class="keyword">break</span>;		     <span class="comment">//为右孩子结点</span></span><br><span class="line">	<span class="keyword">default</span>:p=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">		p-&gt;data=ch;p-&gt;lchild=p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (bt==<span class="literal">NULL</span>)		     <span class="comment">//p为二叉树的根结点</span></span><br><span class="line">		　　bt=p;</span><br><span class="line">		<span class="keyword">else</span>			     <span class="comment">//已建立二叉树根结点</span></span><br><span class="line">		&#123;   <span class="keyword">switch</span>(k) </span><br><span class="line">		　　&#123;</span><br><span class="line">		　　<span class="keyword">case</span> <span class="number">1</span>:St[top]-&gt;lchild=p;<span class="keyword">break</span>;</span><br><span class="line">		　　<span class="keyword">case</span> <span class="number">2</span>:St[top]-&gt;rchild=p;<span class="keyword">break</span>;</span><br><span class="line">		　　&#125;</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      j++;　ch=str[j];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）销毁二叉树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyBTree</span><span class="params">(BTNode *&amp;bt)</span></span><br><span class="line">&#123;   <span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　　&#123;	</span><br><span class="line">　　	DestroyBTree(bt-&gt;lchild);</span><br><span class="line">		DestroyBTree(bt-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(bt);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）求二叉树高度</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BTHeight</span><span class="params">(BTNode *bt)</span> </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> lchilddep,rchilddep;</span><br><span class="line">    <span class="keyword">if</span> (bt==<span class="literal">NULL</span>) <span class="keyword">return</span>(<span class="number">0</span>); 		   <span class="comment">//空树的高度为0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;  </span><br><span class="line">		lchilddep=BTHeight(bt-&gt;lchild);  <span class="comment">//求左子树的高度</span></span><br><span class="line">		rchilddep=BTHeight(bt-&gt;rchild);  <span class="comment">//求右子树的高度</span></span><br><span class="line">		<span class="keyword">return</span> (lchilddep&gt;rchilddep)? (lchilddep+<span class="number">1</span>):(rchilddep+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（4）求二叉树结点个数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BTNode *bt)</span>		<span class="comment">//求二叉树bt的结点个数</span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> num1,num2;</span><br><span class="line">	<span class="keyword">if</span> (bt==<span class="literal">NULL</span>)			<span class="comment">//为空树时返回0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">  	 &#123;   </span><br><span class="line">		num1=NodeCount(bt-&gt;lchild);	<span class="comment">//求左子树结点个数</span></span><br><span class="line">		num2=NodeCount(bt-&gt;rchild);	<span class="comment">//求右子树结点个数</span></span><br><span class="line">		<span class="keyword">return</span> (num1+num2+<span class="number">1</span>);		<span class="comment">//返回和加上1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（5）求二叉树叶子结点个数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BTNode *bt)</span>	<span class="comment">//求二叉树bt的叶子结点个数</span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> num1,num2;</span><br><span class="line">	<span class="keyword">if</span> (bt==<span class="literal">NULL</span>)		<span class="comment">//空树返回0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild==<span class="literal">NULL</span>) </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;		<span class="comment">//为叶子结点时返回1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	 &#123;	</span><br><span class="line">		num1=LeafCount(bt-&gt;lchild);	<span class="comment">//求左子树叶子结点个数</span></span><br><span class="line">		num2=LeafCount(bt-&gt;rchild); 	<span class="comment">//求右子树叶子结点个数</span></span><br><span class="line">		<span class="keyword">return</span> (num1+num2);		<span class="comment">//返回和</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（6）以括号表示法输出二叉树</strong><br>1.对于非空二叉树bt，先输出其元素值；<br>2.当存在左孩子结点或右孩子结点时，输出一个“(”符号；<br>3.递归处理左子树；<br>4.有右子树时输出一个“,”符号；<br>5.递归处理右子树；<br>6.最后输出一个“)”符号；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DispBTree</span><span class="params">(BTNode *bt)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;  </span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,bt-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (bt-&gt;lchild!=<span class="literal">NULL</span> || bt-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">         &#123; </span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);			<span class="comment">//有子树时输出&#x27;(&#x27;</span></span><br><span class="line">	　    DispBTree(bt-&gt;lchild);	<span class="comment">//递归处理左子树</span></span><br><span class="line">		  <span class="keyword">if</span> (bt-&gt;rchild!=<span class="literal">NULL</span>)	<span class="comment">//有右子树时输出&#x27;,&#x27;</span></span><br><span class="line">	   	  <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		　DispBTree(bt-&gt;rchild);	<span class="comment">//递归处理右子树</span></span><br><span class="line">		　<span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);			<span class="comment">//输出一个&#x27;)&#x27;</span></span><br><span class="line">    	 &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（7）先序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;   </span><br><span class="line">	<span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　	　&#123;	</span><br><span class="line">　		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,bt-&gt;data);</span><br><span class="line">		PreOrder(bt-&gt;lchild);</span><br><span class="line">		PreOrder(bt-&gt;rchild);</span><br><span class="line">　　  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先序遍历序列的特点：其第一个元素值为二叉树中根结点值。</p>
<p><strong>（8）中序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;   </span><br><span class="line">	<span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　	　&#123;	</span><br><span class="line">　　	InOrder(bt-&gt;lchild);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,bt-&gt;data);</span><br><span class="line">		InOrder(bt-&gt;rchild);</span><br><span class="line">　　  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历序列的特点：若已知二叉树的根结点值，以该值为界，将中序遍历序列分为两部分，前半部分为左子树的中序遍历序列，后半部分为右子树的中序遍历序列。</p>
<p><strong>（9）后序遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;  </span><br><span class="line">	 <span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　	　&#123;	</span><br><span class="line">　　	PostOrder(bt-&gt;lchild);</span><br><span class="line">		PostOrder(bt-&gt;rchild);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,bt-&gt;data);</span><br><span class="line">　    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历序列的特点：最后一个元素值为二叉树中根结点值</p>
<p><strong>（10）层次遍历</strong><br>层次遍历算法的实现过程：<br>1.先将根结点进队；<br>2.在队不空时循环：从队列中出队一个结点p，访问它；若它有左孩子结点，将左孩子结点进队；若它有右孩子结点，将右孩子结点进队。<br>3.如此操作直到队空为止。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *bt)</span></span><br><span class="line">&#123;   </span><br><span class="line">	BTNode *p;</span><br><span class="line">　　BTNode *qu[MaxSize];	<span class="comment">//定义循环队列,存放二叉链结点指针</span></span><br><span class="line">　　<span class="type">int</span> front,rear;		<span class="comment">//定义队头和队尾指针</span></span><br><span class="line">　　front=rear=<span class="number">0</span>;		<span class="comment">//置队列为空队列</span></span><br><span class="line">　　rear++; </span><br><span class="line">　　qu[rear]=bt;	<span class="comment">//根结点指针进入队列</span></span><br><span class="line">　　<span class="keyword">while</span> (front!=rear)		<span class="comment">//队列不为空循环</span></span><br><span class="line">　　&#123;	</span><br><span class="line">　　	front=(front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">		p=qu[front];			<span class="comment">//出队结点p</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,p-&gt;data);	<span class="comment">//访问该结点</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>)		<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">		&#123;   </span><br><span class="line">			rear=(rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	　		qu[rear]=p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>)		<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">		&#123;   </span><br><span class="line">			rear=(rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	　　	qu[rear]=p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（11）二叉树的拷贝</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CopyBTree</span><span class="params">(BTNode *bt,BTNode *&amp;nt)</span></span><br><span class="line"><span class="comment">//由二叉树bt复制产生二叉树nt</span></span><br><span class="line">&#123;   </span><br><span class="line">	<span class="keyword">if</span> (bt!=<span class="literal">NULL</span>)</span><br><span class="line">　	　&#123;	</span><br><span class="line">　　		nt=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));	<span class="comment">//复制根结点</span></span><br><span class="line">			nt-&gt;data=bt-&gt;data;</span><br><span class="line">			CopyBTree(bt-&gt;lchild,nt-&gt;lchild);	<span class="comment">//递归复制左子树</span></span><br><span class="line">			CopyBTree(bt-&gt;rchild,nt-&gt;rchild);	<span class="comment">//递归复制左子树</span></span><br><span class="line">　	　&#125;</span><br><span class="line">　　<span class="keyword">else</span> nt=<span class="literal">NULL</span>;		<span class="comment">//bt为空树时nt也为空树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《数据结构》C语言版——顺序表学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:44:53" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储，即通过数据元素物理存储的连续性来反应元素之间逻辑上的相邻关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言————如果条件返回错误，则终止程序执行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQLIST_INT_SIZE 8<span class="comment">//初始化顺序表大小为存放8个元素</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出顺序表结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType *base;<span class="comment">//指针base指向一个真实开辟的顺序表空间</span></span><br><span class="line">	<span class="type">int</span> capacity;<span class="comment">//顺序表的空间容量大小</span></span><br><span class="line">	<span class="type">int</span> size;<span class="comment">//顺序表中的实际存放元素的个数(顺序表的长度)</span></span><br><span class="line">&#125;SeqList;<span class="comment">//SeqList为结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeqList</span><span class="params">(SeqList *<span class="built_in">list</span>)</span><span class="comment">//给出顺序表的位置</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;base=(ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*SEQLIST_INT_SIZE);<span class="comment">//为顺序表开辟空间，指针base指向开辟的空间</span></span><br><span class="line">	assert(<span class="built_in">list</span>-&gt;base !=<span class="literal">NULL</span>);<span class="comment">//判断空间是否开辟成功</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;capacity=SEQLIST_INT_SIZE;<span class="comment">//初始化顺序表的容量大小(可以存放8个元素)</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//定义顺序表的实际存放元素的个数为0(此时size是当前数组下标为0的地址)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾部插入*/</span></span><br><span class="line"><span class="comment">//先判断空间是否已满</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span><span class="comment">//给出顺序表的位置和要插入的元素</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size  &gt;=  <span class="built_in">list</span>-&gt;capacity)<span class="comment">//顺序表的实际存放元素的个数大于等于顺序表的开辟容量</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表空间已满\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>-&gt;base[<span class="built_in">list</span>-&gt;size]=x;<span class="comment">//插入元素的位置是当前size指向的位置(即当前下标的位置)</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size++;<span class="comment">//插入元素后，顺序表的实际存放元素的个数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示顺序表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_list</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size;++i)<span class="comment">//循环顺序表的长度</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">list</span>-&gt;base[i]);<span class="comment">//指针base取出下标为i的元素</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头部插入*/</span></span><br><span class="line"><span class="comment">//先判断空间是否已满</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size  &gt;=  <span class="built_in">list</span>-&gt;capacity)<span class="comment">//顺序表的实际存放元素的个数大于等于顺序表的开辟容量</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表空间已满，不能头部插入数据\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">list</span>-&gt;size;i&gt;<span class="number">0</span>;--i)<span class="comment">//循环实现插入新元素前，包括0下标以后的所有元素均后移</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i<span class="number">-1</span>];<span class="comment">//把下标为i-1的元素放在下标为i的位置上(后移)	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>-&gt;base[<span class="number">0</span>]=x;<span class="comment">//此时0下标空出，把新插入的元素放在顺序表的0下标位置上</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size++;<span class="comment">//插入元素后，顺序表的长度加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾删*/</span></span><br><span class="line"><span class="comment">//先判断空间是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_back</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表已空，不能尾部删除数据&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;<span class="comment">//顺序表的实际元素的个数减一，即有效数据减少一个，实现尾删</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头删*/</span></span><br><span class="line"><span class="comment">//先判断空间是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表已空，不能头部删除数据&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size<span class="number">-1</span>;++i)<span class="comment">//除0下标存放的元素不动，其他所有元素依次向前移动，共移动size-1次</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i+<span class="number">1</span>];<span class="comment">//把下标为i+1的元素放在下标为i的位置上</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;<span class="comment">//删除元素后，顺序表的长度减一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按位置插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_pos</span><span class="params">(SeqList *<span class="built_in">list</span>,<span class="type">int</span> pos,ElemType x)</span><span class="comment">//给出顺序表的位置，插入元素的位置，插入元素</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;<span class="built_in">list</span>-&gt;size)<span class="comment">//插入位置小于0或大于当前位置</span></span><br><span class="line"><span class="comment">//(假如顺序表中此时有4个元素，size=4，如果在下标为4的位置插入，实际上此时顺序表下标才为3，可以插入也就是尾插)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入的位置非法\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">list</span>-&gt;size;i&gt;pos;--i)<span class="comment">//i是当前在顺序表的位置，i如果大于要插入的位置，i就减一</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i<span class="number">-1</span>];<span class="comment">//把下标为i-1的元素放在下标为i的位置上(后移)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>-&gt;base[pos]=x;<span class="comment">//包括pos位置在内，pos及之后的元素都向后移动，直到i=pos时(此时循环结束)，插入新元素</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size++;<span class="comment">//插入元素后，顺序表的实际元素的个数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按位置查找*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span><span class="comment">//给出顺序表的位置，查找的元素</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size;++i)<span class="comment">//遍历顺序表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;base[i]==x)<span class="comment">//查找的元素等于表中下标为i的元素</span></span><br><span class="line">			<span class="keyword">return</span> i;<span class="comment">//返回下标</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//否则返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序表长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;<span class="comment">//返回顺序表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按位置删除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_pos</span><span class="params">(SeqList *<span class="built_in">list</span>,<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;=<span class="built_in">list</span>-&gt;size)<span class="comment">//插入位置小于0或大于等于当前位置</span></span><br><span class="line"><span class="comment">//(假如顺序表中此时有4个元素，size=4，如果在下标为4的位置删除，实际上此时顺序表下标才为3，所以删不到)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入的位置非法\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;<span class="built_in">list</span>-&gt;size<span class="number">-1</span>;++i)<span class="comment">//pos下标之前(包括pos)存放的元素不动，pos之后的元素依次向前移动，共移动size-pos-1次</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>-&gt;base[i]=<span class="built_in">list</span>-&gt;base[i+<span class="number">1</span>];<span class="comment">//把下标为i+1的元素放在下标为i的位置上(前移)</span></span><br><span class="line">	&#125;</span><br><span class="line">		<span class="built_in">list</span>-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值删除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dele_val</span><span class="params">(SeqList *<span class="built_in">list</span>,ElemType x)</span><span class="comment">//给出顺序表的位置，删除的元素</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pos=find(<span class="built_in">list</span>,x);</span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	delete_pos(<span class="built_in">list</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>-&gt;size<span class="number">-1</span>;++i)<span class="comment">//size-1相当于下标</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">list</span>-&gt;size-i<span class="number">-1</span>;++j)</span><br><span class="line"><span class="comment">//第0趟比较,j保证了循环到下标为size-1的元素,即最后一个元素</span></span><br><span class="line"><span class="comment">//第1趟比较,j保证了循环到下标为size-2的元素(最后一个元素沉底，不再进行比较)</span></span><br><span class="line"><span class="comment">//第2趟比较,j保证了循环到下标为size-3的元素</span></span><br><span class="line"><span class="comment">//第3趟比较,j保证了循环到下标为size-4的元素</span></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"><span class="comment">//第i趟比较,j保证了循环到下标为size-i-1的元素</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;base[j]&gt;<span class="built_in">list</span>-&gt;base[j+<span class="number">1</span>])<span class="comment">//相邻元素交换</span></span><br><span class="line">			&#123;</span><br><span class="line">			ElemType t=	<span class="built_in">list</span>-&gt;base[j];</span><br><span class="line">			<span class="built_in">list</span>-&gt;base[j]=<span class="built_in">list</span>-&gt;base[j+<span class="number">1</span>];</span><br><span class="line">			<span class="built_in">list</span>-&gt;base[j+<span class="number">1</span>]=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除顺序表中的数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//顺序表的长度置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*摧毁顺序表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory</span><span class="params">(SeqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">list</span>-&gt;base);<span class="comment">//把指针base所指的顺序表空间释放掉</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;base=<span class="literal">NULL</span>;<span class="comment">//把指针base初始化,预防野指针</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;capacity=<span class="number">0</span>;<span class="comment">//顺序表的容量大小为0</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//顺序表的实际存放元素的个数为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SeqList mylist;<span class="comment">//定义一个名为mylist的顺序表</span></span><br><span class="line">	InitSeqList(&amp;mylist);<span class="comment">//初始化mylist顺序表，&amp;为地址传递</span></span><br><span class="line">	ElemType item;<span class="comment">//定义插入的元素</span></span><br><span class="line">	<span class="type">int</span> pos;<span class="comment">//定义插入的位置</span></span><br><span class="line">	<span class="type">int</span> select=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(select)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [1]push_back(尾插)         [2]push_front(头插)  *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [3]show_list(显示)         [4]pop_back(尾删)    *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [5]pop_front(头删)         [6]insert_pos(随插)  *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [7]find(查找)              [8]length(求长度)    *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [9]delete_pos(按位置删)    [10]dele_val(按值删) *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [11]sort(排序)             [12]clear(清除)      *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [13]destory(销毁)          [0]quit(退出系统)    *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;select);</span><br><span class="line">		<span class="keyword">if</span>(select==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>;<span class="comment">//退出系统</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span>(select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)<span class="comment">//逗号表达式</span></span><br><span class="line">			&#123;</span><br><span class="line">			push_back(&amp;mylist,item);</span><br><span class="line">			&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			push_front(&amp;mylist,item);</span><br><span class="line">			&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			show_list(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		pop_back(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		pop_front(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的位置:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pos);</span><br><span class="line">	    insert_pos(&amp;mylist,pos,item);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的数据:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">		pos=find(&amp;mylist,item);</span><br><span class="line">		<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;查找的数据%d不存在\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;查找的数据%d在顺序表中的%d下标位置\n&quot;</span>,item,pos);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表的长度为:%d\n&quot;</span>,length(&amp;mylist));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的位置:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pos);</span><br><span class="line">		delete_pos(&amp;mylist,pos);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的数据:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">		dele_val(&amp;mylist,item);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">		sort(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">12</span>:		</span><br><span class="line">		clear(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">		destory(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入的选择错误，请重新输入:\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序：<br><img src="https://img-blog.csdnimg.cn/20200404212304970.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">《数据结构》C语言版——顺序队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:45:52" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>和顺序栈类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素外，尚需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。</p>
<p>为了在C语言中描述方便起见，<strong>初始化</strong>建空队列的时候，令<strong>front&#x3D;rear&#x3D;0，每次插入新的队列尾元素时，“队尾针增1”；每当删除队列头元素时，“头指针增1”；</strong></p>
<p>因此，在非空队列中，头指针始终指向队列头元素，而队尾指针始终指向队列尾元素的下一个位置，即队尾指针指向的空间是下一个能正常入队的空间，如图：<br><img src="https://img-blog.csdnimg.cn/20200408211853334.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 8<span class="comment">//定义队列初始化存放8个数据元素</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElmeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出顺序队列的结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElmeType *base;<span class="comment">//指针base指向有效的队列空间</span></span><br><span class="line">	<span class="type">int</span>      front;<span class="comment">//队头指针记录队头元素的下标</span></span><br><span class="line">	<span class="type">int</span>      rear;<span class="comment">//队尾指针记录队尾元素的下一个元素的下标</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	Q-&gt;base=(ElmeType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElmeType)*MAXSIZE);<span class="comment">//开辟队空间</span></span><br><span class="line">	assert(Q-&gt;base!=<span class="literal">NULL</span>);</span><br><span class="line">	Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队头指针和队尾指针都指向队列的0下标,此时队列为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue *Q,ElmeType x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//入队时,新入队元素是在队尾指针指向当前下标地址进行入队,入队完成后,队尾指针指向下一个下标地址	</span></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear &gt;= MAXSIZE)<span class="comment">//当队尾指针指向的下标与队空间大小相同时,队已满</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	Q-&gt;base[Q-&gt;rear]=x;</span><br><span class="line">	Q-&gt;rear++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示顺序队列元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队列中存放的元素:&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=Q-&gt;front;i&lt;Q-&gt;rear;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Q-&gt;base[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//进队一个元素,队尾指针指向下一个有效的空间(新空间)</span></span><br><span class="line"><span class="comment">//出队一个元素,队头指针指向下一个有效的数据元素</span></span><br><span class="line"><span class="comment">//当某一时刻,出队了一个元素后,队头指针指向下一个(新空间)时,此时说明队头指针和队尾指针都指向队列的同一个下标地址</span></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队列为空</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	Q-&gt;front++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取队头元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(Queue *Q,ElmeType *v)</span><span class="comment">//指针v带回队头元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要获取队头,前提是队列不空</span></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="comment">//队列为空</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	*v=Q-&gt;base[Q-&gt;front];<span class="comment">//必须在base所指的空间里取元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序队列的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q-&gt;rear - Q-&gt;front);<span class="comment">//下标0开始存放数据,进队后,队尾指针指向下一个有效的新空间</span></span><br><span class="line">	<span class="comment">//队列中元素的个数正好是队尾队头所指的下标之差</span></span><br><span class="line">	<span class="comment">//例如队头指针指向0下标,队尾指针指向3下标,此时队中有3(3-0)个元素,即已存放数据在0,1,2下标中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队列置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁顺序队列*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(Q-&gt;base);<span class="comment">//释放base所指的队列空间</span></span><br><span class="line">	Q-&gt;base=<span class="literal">NULL</span>;<span class="comment">//预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Queue Q;</span><br><span class="line">	ElmeType e;<span class="comment">//定义队头元素</span></span><br><span class="line">	InitQueue(&amp;Q);<span class="comment">//&amp;Q是传入队列的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;入队\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		EnQueue(&amp;Q,i);</span><br><span class="line">	&#125;</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队列	&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队列	&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队列	&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队列	&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队列	&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队列	&quot;</span>);</span><br><span class="line">	DeQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ClearQueue(&amp;Q);</span><br><span class="line">	DestroyQueue(&amp;Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200408225413181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《数据结构》C语言版——单链表学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:40:54" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>链表中的数据是以结点来表示的，每个结点的构成：**元素(数据元素的映象) + 指针(指示后继元素存储位置)**，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p>
<p>●头结点是在链表的开始结点之前附加的一个结点(结点没有有效的数据元素)<br>●第一个结点（或称首元结点）是链表中存储第一个有效数据元素的结点</p>
<p>在链表这里，小萌新想说一定要把’’<strong>指针的指向，谁是谁的前驱结点，谁是谁的后继结点</strong>‘’搞清楚，多画图，慢慢领会！</p>
<p>话不多说，把代码敲起来!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span><span class="comment">//断言——如果条件返回错误，则终止程序执行</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型，即为存放整型数据的单链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出结点结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域(指向下一个结点的地址)</span></span><br><span class="line">&#125;ListNode,*pNode;<span class="comment">//定义结点类型,定义结点的指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*给出单链表结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	pNode first;<span class="comment">//first指向头结点(单链表中有效结点的前一个结点,即头结点)</span></span><br><span class="line">	pNode last;<span class="comment">//last指向最后一个结点(尾结点)</span></span><br><span class="line">	<span class="type">size_t</span> size;<span class="comment">//结点的个数</span></span><br><span class="line">&#125;List;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化单链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;first=<span class="built_in">list</span>-&gt;last=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));<span class="comment">//申请一个结点,同时用指针first和指针last指向这个结点</span></span><br><span class="line">	assert(<span class="built_in">list</span>-&gt;first!=<span class="literal">NULL</span>);<span class="comment">//判断申请空间是否为空</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;first-&gt;next=<span class="literal">NULL</span>;<span class="comment">//头结点的指针域初始化为空(头结点的指针域存放第一个有效结点的地址)</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//初始化有效结点个数为0个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾部插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode *s=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));<span class="comment">//申请一个结点,用指针s指向这个结点(用指针s保存这个结点的地址)</span></span><br><span class="line">	assert(s!=<span class="literal">NULL</span>);<span class="comment">//判断是否申请空间成功</span></span><br><span class="line">	s-&gt;data=x;<span class="comment">//x存放在新结点的数据域</span></span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//新结点的指针域为空</span></span><br><span class="line"><span class="comment">//链接</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;last-&gt;next=s;</span><br><span class="line"><span class="comment">//list-&gt;last代表最后一个结点,list-&gt;last-&gt;next代表最后一个结点的指针域,该指针域保存指针s(即保存新结点地址)</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;last=s;<span class="comment">//last指针后移,用last指针代替s指针指向最后一个结点(即新插入的结点)</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size++;<span class="comment">//插入后,结点数增加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示单链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_list</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义指针p指向单链表中的第一个有效结点(注意不是头结点)</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//如果结点不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>,p-&gt;data);<span class="comment">//打印该结点的数据域</span></span><br><span class="line">    p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;该结点已空\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头部插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_front</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode *s=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">	s-&gt;data=x;<span class="comment">//x存放在新结点的数据域</span></span><br><span class="line">	s-&gt;next=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//新结点指针域保存第一个有效结点的地址(本来第一个有效结点的地址是让头结点的next保存的)</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;first-&gt;next=s;<span class="comment">//用头结点的指针域保存指针s(即新结点的地址)</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//如果此时只有头结点，当插入第一个有效结点时</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;last=s;<span class="comment">//则更改last指针，让其指向第一个有效结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>-&gt;size++;<span class="comment">//插入后,结点数增加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尾删*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_back</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//除头结点外，一个有效结点都没有，无法进行删除操作</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	ListNode *p=<span class="built_in">list</span>-&gt;first;<span class="comment">//定义一个指针p指向头结点</span></span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="built_in">list</span>-&gt;last)<span class="comment">//当头结点后(即list-&gt;first-&gt;next)不是尾结点时</span></span><br><span class="line">	p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">list</span>-&gt;last);<span class="comment">//当头结点后是尾结点时,释放尾结点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;last=p;<span class="comment">//此时指针last指向p指针所指的结点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;last-&gt;next=<span class="literal">NULL</span>;<span class="comment">//last结点的指针域置为空</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size--;<span class="comment">//删除后，结点数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*头删*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop_front</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//除头结点外，一个有效结点都没有</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义一个指针p指向头结点后第一个有效结点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;first-&gt;next=p-&gt;next;<span class="comment">//头结点的后继结点是第二个有效结点(即p-&gt;next),头结点的指针域保存第二个有效结点的地址</span></span><br><span class="line">	<span class="built_in">free</span>(p);<span class="comment">//释放p指针所指的结点,实现头删</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">1</span>)<span class="comment">//如果此时只有头结点和最后一个结点,删除last结点时,需要把last指针指向头结点</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">list</span>-&gt;last=<span class="built_in">list</span>-&gt;first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>-&gt;size--;<span class="comment">//删除后，结点数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值插入(从小到大)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_val</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//申请要插入的数据</span></span><br><span class="line">	ListNode *s=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));<span class="comment">//申请一个结点,用指针s指向这个结点(指针s保存了这个结点的地址)</span></span><br><span class="line">	assert(s!=<span class="literal">NULL</span>);<span class="comment">//判断是否申请空间成功</span></span><br><span class="line">	s-&gt;data=x;<span class="comment">//x存放在新结点的数据域</span></span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//新结点的指针域为空</span></span><br><span class="line"></span><br><span class="line">	ListNode *p=<span class="built_in">list</span>-&gt;first;<span class="comment">//定义一个p指针指向头结点</span></span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;data &lt; x)<span class="comment">//当头结点有后继结点并且后继结点的数据域小于要插入的数值</span></span><br><span class="line">	p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)<span class="comment">//如果头结点后无其他结点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>-&gt;last=s;<span class="comment">//把last指针指向新的结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;next=p-&gt;next;<span class="comment">//否则新结点的指针域保存第一个有效结点的地址(本来第一个有效结点的地址是让头结点的next保存的)</span></span><br><span class="line">    p-&gt;next=s;<span class="comment">//头结点的指针域保存新结点的地址,实现插入</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值查找*/</span></span><br><span class="line">ListNode* <span class="title function_">find</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义一个指针p指向头结点后第一个有效结点(即头结点的后继)</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=x)<span class="comment">//如果后继结点不为空并且结点的数据域不为要查找的数值</span></span><br><span class="line">	p=p-&gt;next;<span class="comment">//则p指向下一个结点</span></span><br><span class="line">	<span class="keyword">return</span> p;<span class="comment">//返回当前结点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单链表长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按值删除*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dele_val</span><span class="params">(List *<span class="built_in">list</span>,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//除头结点外，一个有效结点都没有</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	ListNode *p=find(<span class="built_in">list</span>,x);<span class="comment">//定义指针p保存find函数返回的当前结点的地址</span></span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//如果结点的地址为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;要删除的数据不存在\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="built_in">list</span>-&gt;last)<span class="comment">//如果结点地址正好是尾结点</span></span><br><span class="line">	&#123;</span><br><span class="line">		pop_back(<span class="built_in">list</span>);<span class="comment">//通过pop函数进行尾部删除</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//否则</span></span><br><span class="line">	&#123;</span><br><span class="line">			ListNode *q=p-&gt;next;<span class="comment">//定义指针q指向当前结点(要删除数据的结点)的后继结点</span></span><br><span class="line">			p-&gt;data=q-&gt;data;<span class="comment">//用下一个结点的数据域覆盖当前要删除结点的数据域</span></span><br><span class="line">			p-&gt;next=q-&gt;next;<span class="comment">//删除当前要删除结点的下一个结点(p-&gt;next=p-&gt;next-&gt;next)</span></span><br><span class="line">			<span class="built_in">free</span>(q);<span class="comment">//释放要删除数据结点的后继结点</span></span><br><span class="line">			<span class="built_in">list</span>-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*排序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span> || <span class="built_in">list</span>-&gt;size==<span class="number">1</span>)<span class="comment">//只有头结点或只有头尾两个结点</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	ListNode *s=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义一个指针s指向头结点的后继结点</span></span><br><span class="line">	ListNode *q=s-&gt;next;<span class="comment">//定义指针q指向s指针指向结点的后继结点</span></span><br><span class="line"><span class="comment">//断开链表</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;last=s;<span class="comment">//last指针指向s</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;last-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾结点的指针域为空</span></span><br><span class="line"><span class="comment">//按值插入</span></span><br><span class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)<span class="comment">//判断指针q指向s指针指向结点的后继结点是否为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		s=q;<span class="comment">//若不为空,指针s下移结点(指针s指向断开链表后的第一个结点)</span></span><br><span class="line">		q=q-&gt;next;<span class="comment">//q指针下移(指针q指向s指向断开链表后的第一个结点的后继)</span></span><br><span class="line">	ListNode *p=<span class="built_in">list</span>-&gt;first;<span class="comment">//定义一个p指针指向头结点</span></span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;data &lt; s-&gt;data)<span class="comment">//当头结点有后继结点并且后继结点的数据域小于断开链表后的第一个结点</span></span><br><span class="line">	p=p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)<span class="comment">//如果p所指结点的next为空,则此时p指向尾结点,相当于尾插(更改last指针的指向)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>-&gt;last=s;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;next=p-&gt;next;<span class="comment">//否则断开的结点在头结点与第一个有效结点之间比较,若不满足while,则进行插入</span></span><br><span class="line">	<span class="comment">//指针s指向那个断开的结点,断开的结点的指针域保存第一个有效结点的地址</span></span><br><span class="line">    p-&gt;next=s;<span class="comment">//头结点的指针域保存断开结点的地址</span></span><br><span class="line">	<span class="comment">//此时断开的结点成为第一个有效结点,实现数据域从小到大排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除单链表中的数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="number">0</span>)<span class="comment">//只有头结点不需要清除</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	ListNode *p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//定义指针p指向第一个有效结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>-&gt;first-&gt;next=p-&gt;next;<span class="comment">//头结点后为第二个有效结点</span></span><br><span class="line">		<span class="built_in">free</span>(p);<span class="comment">//释放第一个有效结点</span></span><br><span class="line">		p=<span class="built_in">list</span>-&gt;first-&gt;next;<span class="comment">//p重新指向第一个有效结点(是刚才的第二个有效结点)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>-&gt;last=<span class="built_in">list</span>-&gt;first;<span class="comment">//while完毕后,链表中只剩头结点,将尾指针指向头结点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;size=<span class="number">0</span>;<span class="comment">//结点个数置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*摧毁单链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destory</span><span class="params">(List *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	clear(<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">list</span>-&gt;first);<span class="comment">//释放头结点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;first=<span class="built_in">list</span>-&gt;last=<span class="literal">NULL</span>;<span class="comment">//预防野指针,都置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	List mylist;<span class="comment">//定义一个名为mylist的单链表,内部有三个成员,均为随机值</span></span><br><span class="line">	InitList(&amp;mylist);<span class="comment">//初始化mylist单链表，&amp;为地址传递</span></span><br><span class="line">	ElemType item;<span class="comment">//定义插入的元素</span></span><br><span class="line">	ListNode *p=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> select=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(select)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [1]push_back(尾插)         [2]push_front(头插)  *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [3]show_list(显示)         [4]pop_back(尾删)    *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [5]pop_front(头删)         [6]insert_val(按值插)*\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [7]find(查找)              [8]length(求长度)    *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [9]dele_val(按值删除)      [10]sort(排序)       *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [11]clear(清除)            [12]destory(销毁)    *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;* [0]quit(退出系统)                               *\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;***************************************************\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;select);</span><br><span class="line">		<span class="keyword">if</span>(select==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>;<span class="comment">//退出系统</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span>(select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)<span class="comment">//逗号表达式,item!=-1时插入</span></span><br><span class="line">			&#123;</span><br><span class="line">			push_back(&amp;mylist,item);</span><br><span class="line">			&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据(-1结束):&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item),item!=<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			push_front(&amp;mylist,item);</span><br><span class="line">			&#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			show_list(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		pop_back(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		pop_front(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">	    insert_val(&amp;mylist,item);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的数据:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">	    p=find(&amp;mylist,item);</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;要查找的数据在链表中不存在\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表的长度为:%d\n&quot;</span>,length(&amp;mylist));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的数据:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;item);</span><br><span class="line">    	dele_val(&amp;mylist,item);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		sort(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">11</span>:		</span><br><span class="line">		clear(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">		destory(&amp;mylist);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入的选择错误，请重新输入:\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200406104358973.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suenning.com.cn/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%93%BE%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sunning">
      <meta itemprop="description" content="且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橘生淮南">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88%E2%80%94%E2%80%94%E9%93%BE%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">《数据结构》C语言版——链队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:11:37 / 修改时间：16:42:42" itemprop="dateCreated datePublished" datetime="2023-02-01T16:11:37+08:00">2023-02-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>队列：只允许在一端进行插入，在另一端进行删除的线性表</p>
<p><strong>链队列：使用链表实现的队列，具有队头指针和队尾指针，指示队列元素所在的位置</strong></p>
<p><strong>链队列特性：</strong><br>●只能队尾插入元素，在队头删除元素<br>●先进先出（First In First Out）的线性表，先进入的元素出队，后进入的元素才能出队</p>
<p>队列示意图：<br><img src="https://img-blog.csdnimg.cn/20200407235045226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>空链队列：<br><img src="https://img-blog.csdnimg.cn/20200407235120552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>链队的入栈操作：<br><img src="https://img-blog.csdnimg.cn/2020040723514797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>链队的出栈操作：<br><img src="https://img-blog.csdnimg.cn/20200407235207967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>————————纸上得来终觉浅，绝知此事要躬行————————</strong></p>
<p>话不多说，把代码开起来，这样晦涩的概念才不会显得苍白无力！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span><span class="comment">//断言</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">//定义元素类型为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*链队的结点类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode,*PNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义链队结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PNode front;<span class="comment">//队头指针指向头结点</span></span><br><span class="line">	PNode tail;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化链队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建头结点</span></span><br><span class="line">	QueueNode *s=(QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">	assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">	Q-&gt;front=Q-&gt;tail=s;<span class="comment">//队头指针和队尾指针都指向新结点</span></span><br><span class="line">	Q-&gt;tail-&gt;next=<span class="literal">NULL</span>;<span class="comment">//队尾结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//队尾指针的next指向新创建的结点(新结点进行尾插)</span></span><br><span class="line">	<span class="comment">//更改尾指针tail的指向</span></span><br><span class="line">    QueueNode *s=(QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">	assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">	s-&gt;data=x;</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;<span class="comment">//新结点的指针域为空</span></span><br><span class="line">	Q-&gt;tail-&gt;next=s;<span class="comment">//尾结点的指针域保存新结点的地址</span></span><br><span class="line">	Q-&gt;tail=s;<span class="comment">//尾指针指向新结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展示链队元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	 QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;Front:&gt;&quot;</span>);</span><br><span class="line">	 <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p=p-&gt;next;<span class="comment">//指针p指向下一个有效结点</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;&lt;:Tail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DenQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//出队相当于头部删除结点的过程:头结点的next指向第一个有效结点的后继,然后释放第一个有效结点</span></span><br><span class="line"><span class="comment">//注意:如果删除队尾结点,需要将队尾指针tail再次指向头结点</span></span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;tail)<span class="comment">//空队列</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line">	Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">//头结点的指针域保存第二个有效结点的地址</span></span><br><span class="line">	<span class="built_in">free</span>(p);<span class="comment">//释放第一个有效结点</span></span><br><span class="line">	<span class="keyword">if</span>(p==Q-&gt;tail)<span class="comment">//此时删除最后一个结点(尾结点)</span></span><br><span class="line">	Q-&gt;tail=Q-&gt;front;<span class="comment">//队尾指针指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*取链队头元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(LinkQueue *Q,ElemType *v)</span><span class="comment">//用指针v带回链队头元素</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;tail)<span class="comment">//空队列</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line">	*v=p-&gt;data;<span class="comment">//p-&gt;data等价于Q-&gt;front-&gt;next-&gt;data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求链队长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;<span class="comment">//初始化长度为0</span></span><br><span class="line">	QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//只有结点不为空,len增加</span></span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*清除链队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue</span><span class="params">(LinkQueue *Q)</span><span class="comment">//除头结点外,对所有结点进行清除</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front==Q-&gt;tail)<span class="comment">//如果头指针与尾指针指向相同,则链队为空</span></span><br><span class="line">	<span class="keyword">return</span>;<span class="comment">//无需清除</span></span><br><span class="line">	QueueNode *p=Q-&gt;front-&gt;next;<span class="comment">//指针p指向头结点后第一个有效结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">//头结点的指针域保存第二个有效结点的地址</span></span><br><span class="line">		<span class="built_in">free</span>(p);<span class="comment">//释放第一个有效结点</span></span><br><span class="line">		p=Q-&gt;front-&gt;next;<span class="comment">//指针p重新指向头结点后第一个有效结点</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//释放完成后,对尾部指针进行修改</span></span><br><span class="line">	Q-&gt;tail=Q-&gt;front;<span class="comment">//队尾指针指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁链队*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(LinkQueue *Q)</span><span class="comment">//清除的前提下释放头结点实现销毁</span></span><br><span class="line">&#123;</span><br><span class="line">	ClearQueue(Q);</span><br><span class="line">	<span class="built_in">free</span>(Q-&gt;front);<span class="comment">//释放头结点</span></span><br><span class="line">	Q-&gt;front=Q-&gt;tail=<span class="literal">NULL</span>;<span class="comment">//队头和队尾指针都赋空,预防野指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	ElemType e;<span class="comment">//链队头元素</span></span><br><span class="line">	InitQueue(&amp;Q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		EnQueue(&amp;Q,i);</span><br><span class="line">	&#125;</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">	DenQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">	DenQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">	DenQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出队\n&quot;</span>);</span><br><span class="line">	DenQueue(&amp;Q);</span><br><span class="line">	GetHead(&amp;Q,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队头元素为:%d\n&quot;</span>,e);</span><br><span class="line">	ShowQueue(&amp;Q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;链队的长度为:%d\n&quot;</span>,Length(&amp;Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ClearQueue(&amp;Q);</span><br><span class="line">	DestroyQueue(&amp;Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200407234546380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk2NDQ1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sunning</p>
  <div class="site-description" itemprop="description">且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SuenNing1999" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SuenNing1999" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_43964458" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43964458" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1878225963&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sunning</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">147k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:14</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  



   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/fireworks.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

